{"pages":[{"title":"关于欧阳锋工作室","text":"14年6月份，我只身一人来到深圳，只觉一瞬，时间已过去将近4年。 4年的时间里，我见证了深圳速度。在一线城市里生活，你只有两个选择：要么奋斗，要么死亡！或许正是深圳的高压姿态锻造了我，4年的时间里，我始终保持高强度的学习状态。终于在自己的领域小有成就，我深知获取这些知识来之不易。也希望将自己的知识分享给大家。因此，在16年的时候我决定成立欧阳锋工作室。 遗憾的是，因为工作的关系，工作室一直处于闲置状态。从今天起，我希望欧阳锋工作室可以伴随你度过生活中的每一天。 未来，欧阳锋工作室将主要专注以下几个方面： 高质量技术博客分享 开源项目 在线教育 软件开发 我相信，只要坚持做一件事情，就一定可以成功。我也相信，机会总是留给有准备的人。我还相信，只有苦过、折腾过、哭过的人生才算完美。 奋斗的路上难免会形单影只，别怕孤单！我始终偏爱那些无畏困难、不问前程、坚持不懈的人们。关注欧阳锋工作室，让欧阳锋工作室陪伴你一起成长！ 关注渠道 微信公众号：欧阳锋工作室 简书：欧阳锋 新浪微博：欧阳锋工作室 Github: 欧阳锋工作室 我是欧阳锋，未来，我希望与你一起成长！","link":"/about/index.html"},{"title":"所有分类","text":"","link":"/categories/index.html"},{"title":"所有分类2","text":"","link":"/categories/other.html"},{"title":"所有标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"写在十分简历发布前夕","text":"关于十分简历十分简历是我们的第一个作品，这是一个微信小程序，用于生成漂亮的简历模板。 同时，考虑到用户的隐私问题，增加了私密简历功能。 那么，到底什么是私密简历呢？在传统的简历投递中，通常HR会将我们的简历打印下来，面试完成后，会留下面试者的简历。这在一定程度上可能造成用户的私密信息泄露。私密简历希望可以解决这个问题！ 相对传统的纸质简历，私密简历会生成一个专属于你的个人简历链接。通过这个私密简历链接，HR可以实时查看你的简历。你可以在小程序中设置一个简历过期时间，到达过期时间后简历会自动回收。为了进一步防止其他人查看你的简历，你还可以设置专属于当前私密简历的阅读密码。 与此同时，你还可以通过小程序随时开启或关闭当前私密简历。关闭后，将不再允许任何人查看当前私密简历，直到再次打开。 事实上，我最感兴趣的部分，恰好就是私密简历的开发。因为，确实存在一些公司的面试官会将用户的纸质简历随地丢弃，这就造成大概率简历内容泄密问题。 不过，肯定有人会说，现在的HR通常都会要求打印纸质简历，又有什么办法呢？所有的进步当然不是一时间可以改进的，也许未来这样的情况会随着这类产品的普及开始变得不一样。我坚信，传统的纸质简历终究被遗弃。 十分简历的点子来自于之前团队的一个小伙伴，当时，公司刚刚成立，我希望用一个小而精的产品宣告公司的诞生，同时展示团队强大的开发实力。 因此，公司成立后的第一件事情，就是号召大家天马行空，思考第一个连接公司与世界的产品。最后发现，这个简历产品的思路有点意思，而且也不至于太过于复杂。于是，这个产品就成为了我们连接世界的第一个作品。 确立了产品原型之后，真正的挑战开始了！ 挑战一：后端开发后端开发是我们面临的第一个挑战。事实上，我的第一份工作就是后端开发，并且进行了将近一年的时间，确实有一定的积累，但这并不能给我带来很大的帮助。因为，时间已经过去了差不多5年。此后的4年时间里，我一直从事移动平台软件开发。关于后端的知识点，大抵忘记了，现在捡起来，难度不少！ 而且，时间过去了这么久，之前的技术也慢慢地被淘汰了。为此，我决定重新开始！ 第一步：确定技术选型 这一步我选择了相对麻烦、但已经实践成熟的解决方案： Web框架：Spring Boot + Apache Shiro 数据库框架：MyBatis 服务注册与发现：Eureka Server 路由网关：Zuul1 编程语言：Kotlin 第二步：解决路由网关难题 在路由网关的技术选型上，最终确立了使用Zuul1作为路由网关框架。实际上，还有一个更好的选择是Spring Cloud Gateway。但使用Spring网关需要结合更多的新知识去做，而且还需要自己去处理数据库的事务问题，的确会带来不少的麻烦。加上在当时考察的文章中，发现Spring的网关性能并不能带来本质上的提升。因此，最终确立了以Zuul作为后端的路由网关框架。 在确定了技术框架之后，第一个需要的解决的问题就是，如何通过一个字段标识路由到不同的服务层逻辑。例如：通过版本号路由到不同的逻辑服务层，避免版本之间相互干扰等等。遗憾的是，Zuul的路由处理是静态配置的，这就需要对Zuul进行扩展，建立一个可以进行动态路由配置的网关框架。 在这一部分问题的处理上，从最开始的设计到最终整个后端框架定型，差不多花掉了半个月左右的时间。一方面要考虑动态配置，另一方面需要考虑到网关的性能问题。通过不断地尝试，查资料，总算解决了这个问题。这个问题的难度，在这次整个产品开发过程中排名第一。 第三步：整合安全框架 这里的安全架构不仅仅指的是数据加密。当然，因为未来会涉及到付费交易，毫无疑问，我们的数据是进行过加密处理的。但这里，我要说的是，Java安全框架的接入问题。 考虑到未来开发的便利性，我希望用一个安全框架帮助接管用户权限控制、分配等问题。为此，首选的当然是Spring Security。但实际试用下来，发现Spring Security设计的过于复杂，可用性不高。并且，灵活性也受到了限制，不得不另辟蹊径。最终确定了使用Apache Shiro作为平台的安全框架。 Apache Shiro从一定程度上规避了Spring Security的不少问题，从一开始阅读文档就能感受到其简洁的设计。Apache Shiro的接入相对Spring Security就简单了许多，而且可定制性也提升了不少。最终，安全框架接入顺利完成。 第四步：搞定逻辑层编码 实际上，我在早年从事Java后端开发的时候，我们还使用的是SSH（Spring, Struts2, Hibernate）的组合。而现在Struts已经慢慢地被淘汰了，取而代之的是Spring MVC + MyBatis + Spring。同时，为了进一步降低Java Web开发的难度，Spring官方推出了Spring Boot。相对传统的Java Web开发，Spring Boot几乎可以脱离配置文件，使用注解完成所有配置，亲和力提升不少。 因此，我最终选择了使用Spring Boot来构建我们的Web应用。但所有的这些对于我而言都是全新的知识点，不得不从重新学习，好在之前的基础还算比较扎实，上手很快。 挑战二：小程序开发搞定了后端开发的难题，第二个挑战接踵而至：小程序开发。 团队成员中几乎都没有小程序开发的工作经验。实际上，团队成员中有一位同学有一定的小程序开发经验。但事实证明，这位同学的开发经验依然非常浅，并不足以支撑整个小程序的开发。为此，我决定亲自学习小程序，帮助大家完成小程序端的架构。制定小程序开发规范。 小程序的开发难度相对较低，但也踩了不少坑，关于这一部分的经历，我会用另外一篇文章记录下来。 小程序开发过程中，最大的问题来自团队成员，其中一个小伙伴是兼职参与开发。由于学习知识较慢， 同时对自己自信心不够。加上生活的一些琐事，即使分配了足够简单的任务也未能顺利完成，这就导致了整个研发过程被拉长。 最后，在Release的版本库中，我惊奇地发现，我最终参与了70%以上的小程序代码开发。看到这种场景，心中五味杂陈，这显然不是一个良性循环。 这也让下定决心，从明年开始，租写字楼，正式招人办公。兼职员工将由全职员工带队进行工作安排，处理。并适当给予兼职员工一定的资金鼓励。 挑战三：Web前端开发Web前端开发在这次开发的难度排行榜中可以排名第二。团队成员中，几乎没有一个人拥有前端开发工作经验。其中一个同学做过极少一段时间的前端开发，因此，我让他牵头开发了第一个模板。 但在第一个模板的开发过程中，也是不断地磕磕绊绊，走了不少弯路。那一段时间，是整个开发阶段最艰苦的时段，我跟这位同学每天从早上忙到晚上12点。持续了连续10天左右，没有周末，没有午休。好在终于顺利完成了第一个模板的开发。 模板开发完成后，整个产品的基础形态第一次呈现在了大家的面前。前期由于时间过于紧张，在我们的产品原型中，并没有一个充分的流程可以展示完整。以至于兼职参与开发的同学们在理解产品的设计上出现了不少问题。这种理解上的问题后来也让我头疼不已，这也是这次开发过程中获得的宝贵教训之一。 关于Web前端的技术选型，也走了一些弯路。最开始，我考虑使用Vue + TS的组合作为前端开发。最终架构完成后却发现，这个组合对于前端开发的难度提升了不少。这在很大程度上会拖延项目的开发进度。因此，马上放弃了这个组合。转而使用大家比较容易掌握的jQuery。事实上，模板页作为我们的单页应用，使用jQuery已经完全足够了。 确定了技术选型之后，依然出现了一些问题。由于第一位同学开发的比较匆忙，没有形成一定的规范。导致第二位同学接力的时候出现了一头雾水的情况。因此，第二位同学不得不重新去学习Webpack，重新去设计自己的代码架构，这在一定程度上也拖慢了整个开发进度。 事实上，在整个开发进程中，Web前端的开发比重确实占据了不少。这个挑战的难度在本次开发过程中应该可以排名第二。 第一阶段总结在整个十分简历的开发过程，就像在做一次冒险，所有的知识对于我们来说，都是陌生的。我们需要从0开始学习，恰好是这种从0开始学习的勇气让我更加自信我可以搞定任何事情，不会再惧怕第一次。同时，我也坚信，这一次难忘的开发经历，会让团队中坚持到最后的同学都有了一往无前、无所畏惧的勇气。 这是一次十分难忘的开发经历，也是我们第一次勇敢地探索未知的世界，最终克服了重重困难，将十分简历带到了大家的面前。 这不是结束，这恰好是我们故事的开头！ 最后，感谢所有参与十分简历开发的同学们，为自己鼓个掌吧！你们所经历的，不仅仅是开发了一个产品，而是克服了内心对于未知事物的恐惧，敢于踏出第一步。这种收获，必将让你们终身受益！ 后记送给中途离开十分简历开发的同学们在十分简历的开发过程中，有两位同学中途离开了开发团队。第一位同学是因为同时在开发另外一个产品，时间有限，不能同时兼顾两个产品开发，最终选择了另外一个产品的开发。这是完全可以理解的，这是个人选择问题，也是眼界问题。这样的同学，在后续团队扩展中，将不会再次接收。因为，有了第一次这样的选择，就会有下一次。这样的同学不能稳定产出，稳定投入，会因为种种问题摇摆不定。 另外一位同学，因为受不了我的严厉性格，在中途选择了离开。这当然更加容易理解，这样的的离开于我而言，几乎是完全无感的。相反，如果一位同学在开发中投入了很多，对团队的奉献很大。突然选择了离开，对我的打击反而会比较大。而类似这位同学这样的一个原因，选择离开。对于我，反而会感觉到欣慰，因为即使这样的同学留下来，也并不能跟我走到最后。他的抗压能力，以及他的意志力决定他不能走的很远。创业的路就像攀登珠峰一样，随时都有掉下去摔死的风险。你也许感觉不到你要摔死，我不得不用最严厉的语气骂醒你，你在“爬山”，你不应该睡觉！但类似这样的同学，在后续开发中，作为员工可以再次接收，因为他至少符合稳定产出的条件，只是意志力会薄弱一些，这个可以慢慢改善。 所有两位同学的离开，都是非常恰当的时机，在团队初期选择离开也是对于团队小伙伴最大的尊重。请离开的同学放心，我对大家不会有任何的责备，我非常开心大家可以在初期就选择离开了团队，这很重要。就像进行一场计划好的旅行，在旅行前10天就有人中途离场，这其实很好。我们还可以重新组织同学加入到这场旅行中来，这是一件好事，我要感谢大家。同时，大家的离开也有利于筛选更优秀的员工。当然，也希望离开的两位同学工作顺利，一切顺风顺水。 微信扫描下方二维码体验小程序","link":"/2019/01/12/写在十分简历发布前夕/"},{"title":"2017年终总结","text":"2017年对于我来说，是收获的一年。这一年，我放弃了一份稳定的工作，去尝试了一份生死未卜的事业。我以为我会后悔，相反，我很庆幸这个决定。虽然，失去了稳定，却在跌宕起伏中收获了不一样的精彩… 这一年，我在公司主要负责移动部门技术管理工作。移动部门技术同学水平参差不齐、管理涣散是前期遇到的最大的一个问题。为此，我制定了一个简单的计划： 定期工作汇报 技术培训 代码Review 定期会议 定期工作汇报定期工作汇报的效果是显著的，在汇报工作的过程中，通过互相对比，彼此会看到自己的不足，加以改进。在工作汇报的设计上，我没有采用日报的形式，我认为日报有点太过机械化了，甚至有可能导致一定的负面情绪。因此，我把工作汇报集中在周二和周四，仅仅两天的时间既不会太紧凑，也不会太松散。虽然工作汇报在团队中形成了一个良好的氛围，但因为技术实力薄弱带来的问题依然暴露了很多。以至于在团队中出现了一些负面情绪，前端同学在抱怨后端开发，后端开发也在推责前端，气氛一度紧张。在这样一种情形下，我认为技术培训工作已经迫在眉睫了。 技术培训技术培训工作是这一年最用心的工作之一，培训的核心主要集中在Kotlin语言。团队中几乎所有的同学对Kotlin语言都是陌生的，仅仅停留在最基础的用法上面，这显然不行！针对这个问题，我将培训内容集中在Kotlin重难点攻克上面。 回顾过去一年，我大约进行了十多次技术培训，内容包括： Kotlin基础知识 Kotlin难点攻克 Git基础用法（针对公司全员） Android常见问题解决方案 从Swift看Kotlin 基础网络知识 基础调试技巧培训（adb，gradle，Linux) 其中一部分内容是作为技术分享课程进行的，准备这些课程其实并不容易。但依然有极少数同学对于培训课程不屑一顾，即使在课堂上再三强调过的问题，在实际开发中依然屡屡再犯。为此，在技术层面上，我想我还需要做更多的工作。 Code Review与往常不一样，这一次我决定使用Pull Request的方式合并代码。这样，我可以对每一次提交进行Code Review。每一次的Pull Request我都会逐行检查，并且会对每一次的打回整理一个完整的文档描述问题出在哪里。 不得不说，Code Review的效果是显著的，团队中一些代码风格很差的同学。经过几次代码被打回的洗礼之后，代码风格有了很大的改善。然而，遗憾的是，后期由于工作过于繁忙，这个部分的工作也慢慢取消了。 整体而言，Code Review的确带动了团队整体编码水平的提升。编码能力提高之后，问题减少了许多。不过，由于前期遗留的一些老问题，导致部分低级错误依然在犯，真是让人心力交瘁。与此同时，团队中另外一个问题也慢慢暴露了出来。你可以很明显地感觉到，团队整体的凝聚力、核心价值观是缺失的，以至于针对同一个问题每个人的聚焦点完全不一样。部分同学采取“当一天和尚撞一天钟”的做法。因此，我认为核心价值观的建设必须尽快搞起来。 定期会议为了建立团队核心价值观，我决定定期开展一些会议。然而，由于时间的关系，仅组织了几场会议。但在每次例会结束的时候，我都会做一些核心价值观引导。我一直认为，一个没有核心价值观的公司是一个不完整的公司。这有点类似于“精神出轨”和“肉体出轨”，两者都非常可怕，在IT公司，“精神出轨”的最终症状往往就是“肉体出轨”。但核心价值观的建设是一个漫长的过程，每次会议开完，总感觉收效甚微。内心就像嚼一块过期的臭豆腐，五味杂陈。为此，我改变了策略，决定先带动部分同学，再通过部分同学带动其他同学。有点像旧社会的“让一部分人先富起来”的感觉。这一部分的工作真是举步维艰，不过，好在最后的结果还不错。最终，大部分同学都形成了统一的价值观。 以上，是过去一年我在工作上所做的一些尝试，其实都是一些老生常谈的套路，但实践下来的效果其实还不错。 回首2017年，的确是完全献给工作的一年。这一年，我常常奋战到深夜，即使在周末，也是如此。这一年，我几乎没有出去旅游，甚至于几公里外的徒步都没有。相对往年，时间显得更加稀缺，但与此同时带来的回报也是双倍的。在团队管理上，我有了新的见解；在技术上，我也有了新的突破；在人际关系处理上，我也有了新的进步。 伴随收获随之而来的就是遗憾，这一年主要有两个遗憾。第一个遗憾，对于团队，始终感觉有些亏欠。这一年，我给团队的关键词是“技术”。因此，在团队感情集结、团队建设方面做的工作太少。以至于直到年尾，大家对彼此依然有些陌生，这不得不说是一个很大的遗憾。第二个遗憾，是对自己，17年我给自己定的关键词是“运动”。然而，由于工作的繁忙，锻炼并没有按计划进行，以至于体质一再下降，这不得不说又是一个遗憾，这一部分希望2018年能够及时弥补上来。 明天就是农历2018年了，突然意识到，我已经三十岁了，虽然我很不愿意承认。三十而立，我希望自己可以有一些新的突破。因此，我给自己的2018预设了几个目标，希望在2019年之前可以顺利完成。 最后，感谢所有陪伴我度过2017年的小伙伴们，2018年我会更加努力，让你看到一个更优秀的欧阳锋。这一年我给自己定的年度关键字是“稳”，无论是在事业上，还是在身体上，亦或者是其它方面，都希望可以稳扎稳打、稳步向前。 我是欧阳锋，即使而立之年，我依然相信，只要坚持做一件事情，就一定会成功。我始终偏爱那些无畏困难、不问前程、坚持不懈的人们。我始终怀揣着梦想，2018年我会从“新”出发。2018，祝福正在看文章的你，也能高挂云帆，傲视沧海。 遇见欧阳锋，希望你没有后悔，2018年再见。","link":"/2018/02/15/about ouyangfeng/2017年终总结/"},{"title":"欧阳锋档案馆","text":"你好，欢迎来到欧阳锋档案馆！你可能已经看过了我的一些文章，但对应欧阳锋工作室可能依然比较陌生。这篇文章主要记录当前欧阳锋工作室的主要关注渠道，以及最新的一些进展。 关注渠道官方网站：http://www.youngfeng.com 微信公众号：欧阳锋工作室(微信号：OuyangfengOffice) 新浪微博：欧阳锋工作室 GitHub：https://github.com/yuanhoujun 简书：https://www.jianshu.com/u/db019edd34b4 交流群iOS交流群：468167089Kotlin语言交流群：329673958 我是欧阳锋，我期待着与你的邂逅 &lt;&lt;","link":"/2018/02/28/about ouyangfeng/欧阳锋档案馆/"},{"title":"是你自己选择了安逸，别怪路途太遥远","text":"“老同学，我的工作好无聊，每天有大把的时间却不知道如何打发。我也不知道这个工作的意义在哪里？” 这是两年前我的一个高中同学给我发来的微信消息。一年后，我再次收到他发来的微信消息 “嘿，哥们！我到清远工作了”，“做运维了吗？”，“不是，还是公务员”，“…..” 他是我的铁哥们，叫赵亦然。他在大学的主修专业是计算机，莫名其妙地做了公务员。现在在利用业余时间学习系统运维。他说，他想去考红帽子认证工程师。希望可以换个工作，并详细询问了我关于深圳系统运维工程师的一些事情。可是，正如你所见，一年后，一切照旧。工作依旧，抱怨依然。 曾几何时，公务员已经成为了年轻人选择工作的第一标准，也成为了父母口中的金饭碗。而对于年轻人，选择公务员这个职业，大多都是出于无奈。当然，也不排除部分同学的确对从政有很大的兴趣。 严格来讲，这个结论也许有失偏颇。但从我周围的情况来看，结果确实是这样。不信，问问你的公务员朋友，也许你也会得到下面这样一段对话。 A：为什么你选择做公务员？B：大学的时候，没有目标，不知道自己喜欢什么，就想着考着试试看。没想到，真考上了，就一直做下来了… 然而，很多同学在真正从事这个职业的时候就开始后悔，公务员机械式的工作方式让他们痛苦不堪。但一想到放弃，想到要放弃这安逸的工作，想到对未知的恐惧，马上就打消了这个念头。 公务员职业如此，软件行业也是如此。我是一名软件工程师，在工作中也遇到了很多类似情况的小伙伴。他们并不喜欢编程，却因为IT行业高额薪资而逼迫自己从事这个行业。 同样地，他们也是痛苦的，如果你正好处在这样一个阶段，你应该可以感同身受。而如果你恰好做了自己喜欢的工作，你不妨试想一下，让你从事一份你并不喜欢的工作是什么滋味。 拿身边的一些朋友举例，因为并不热爱编程，以至于在对话中很难听到他跟你讨论编程。平时也很少看到他在代码层面的产出，大多是朋友圈晒晒图，或者玩玩游戏，以至于编程技术始终在原地踏步。而一旦离开原有单位跳槽的时候，问题就来了。这类同学往往面临找工作困难的问题，部分同学甚至容易出现因为找工作而情绪低迷的问题。每次听到这类抱怨，我都不知道如何安慰他们。因为，这其实就是一个因果关系而已。你自己不努力，谁能帮你？ 有时候，我也劝他们，换一份工作吧，去做你真正喜欢的事业。结果你应该可以想见，耳朵是听进去了，行动却没有跟上。 有人可能觉得，IT行业应该不好混，因为是技术活。这样的同学可以过得轻松自在吗？其实不然，在IT公司总有一部分同学可以独挑大梁，以至于复杂的工作他都可以帮你搞定。这部分同学就做一些“扫扫地、擦擦桌子”的工作就行了。日子不仅过得逍遥快活，还烙下个优秀员工的称号。 不仅身边的同学和朋友是这样，我的妹妹也是如此。 毕业后，她选择了在一所市里的普通小学教书。为了获得教师许可证，她几经磨难。如此艰难的求职过程，我以为她应该喜欢这份工作。可事实，却并非如此。 一天我突然收到她发来的消息 “哥，学生们太不听话了，领导们还屡次刁难我。我决定，换个工作，我想去长沙，做点其他的事情，我不太适合当老师”。为此，我给她推荐了文员或者前台或者培训机构指导老师一类的工作。我以为，一年后我应该能看到她有所举动。可事实上，当我再次见到她的时候。很明显，她已经取消了这个计划。 每年都有无数的人挣扎在痛苦工作的边缘，想要放弃吧，又害怕没有一技之长找不到工作。坚持吧，又如坐针毡、心如刀绞。看似面露微笑，其实心里在骂娘。早上起来先骂一遍自己傻逼，然后扭头坐上上班的地铁。 我非常喜欢一句话：如果你觉得很难，那是因为你在走上坡路。人对于未知的事物都会充满恐惧，以至于迈出第一步往往是最艰难的。 试想一下，如果让你每天早上8点起来慢跑一个小时，坚持1年，你能做到吗？毫无疑问，能够做到的人寥寥无几。事实上，这事并没有想象的那么困难。你不敢去做，只是因为你给自己预设了太多门槛，你害怕面对未知的事情。 挖掘本性往往是一个痛苦的过程，可顺遂本性的安逸，永远不过是原地踏步、无所作为。 有人说，有一种鸟生来就没有脚，以至于它必须不停地飞，才不至于摔死。其实，人生就是这样，停在树上休息，不如奋力往前飞，看到更美的风景。有人问我，你为什么可以坚持一直学习，你有什么动机。其实，我的动机很简单，我不想在我80岁的时候，当我的孙子问起我来的时候，我无话可说。人生多一点挫折，多一点磨难，没什么不好。 其实，你仔细算一下，人生不过3万天而已。与其一直做着自己不喜欢的工作混混度日，还不如跳出来，勇敢去做自己擅长的事情。用1万天去摸索，1万天去热爱，最后的1万天用来安享晚年。 余生可贵，请别再抱怨！是你自己选择了安逸，何必怪路途太遥远！ 备注：文章并没有歧视任何职业的意思，请勿产生误解。 我是欧阳锋，你中枪了吗？那还不点个赞 ~","link":"/2018/03/05/comprehensive article/是你自己选择了安逸，别怪路途太遥远/"},{"title":"最完整的Markdown基础教程","text":"提到Markdown，很多人首先想到的是简单、Easy等等。的确，Markdown为简单而生。Markdown是由一个叫 JOHN GRUBER 的哥们发明的，它的语法用一篇文章就可以说完。不相信吗？让我们来试试看… 基础语法标题Markdown支持6种级别的标题，对应html标签 h1 ~ h6 123456# h1## h2### h3#### h4##### h5###### h6 以上标记效果如下： h1h2h3h4h5h6除此之外，Markdown还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制 1234这是一级标题===这是二级标题--- 使用这种方式处理标题仅有两种表现形式，即一级标题和二级标题。遗憾的是，简书并不支持这种语法。因此，我们用一张图来展示效果：这种处理方式在Github的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。 段落及区块引用需要记住的是，Markdown其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为html标签，因此使用Markdown分段非常简单，前后至少保留一个空行即可。 而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown提供了一个特殊符号>用于段首进行强调，被强调的文字部分将会高亮显示 1&gt; 这段文字将被高亮显示... 以上标记显示效果如下： 这段文字将被高亮显示… 插入链接或图片Markdown针对链接和图片的处理也比较简单，可以使用下面的语法进行标记12[点击跳转至百度](http://www.baidu.com)![图片](https://user-gold-cdn.xitu.io/2018/4/18/162d75d959444389?w=1240&amp;h=703&amp;f=jpeg&amp;s=56927) 以上标记显示效果如下： 点击跳转至百度 注： 引用图片和链接的唯一区别就是在最前方添加一个感叹号。 列表Markdown支持有序列表和无序列表两种形式： 无序列表使用*或+或-标识 有序列表使用数字加.标识，例如：1. 123456789101112131415* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子 以上标记显示效果如下： 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 注：这里比较有趣的地方是，对于有序列表，Markdown将只关注你的第一个项目的数字编号。例如：如果第一个项目编号是3，以此类推，第二个项目应该是4，最终将显示为3、4、5。而如果你指定了第一个编号，后面的编号指定错误也没有关系，Markdown将只在乎你的第一个项目编号。 使用列表的一些注意事项如果在单一列表项中包含了多个段落，为了保证渲染正常，*与段落首字母之间必须保留四个空格 123456* 段落一 小段一* 段落二 小段二 以上标记显示效果如下： 段落一 小段一 段落二 小段二 另外，如果在列表中加入了区块引用，区域引用标记符也需要缩进4个空格 1234* 段落一 &gt; 区块标记一* 段落二 &gt; 区块标记二 段落一 区块标记一 段落二 区块标记二 注：记住一个原则，如果在和列表配合使用的时候出现了问题，就缩进一次，四个空格或者一个制表符代表一次缩进。如果一次缩进没有解决问题，那就两次。 分隔线有时候，为了排版漂亮，可能会加入分隔线。Markdown加入分隔线非常简单，使用下面任意一种形式都可以 12***--- *产生分隔线的语法要求比较松，符号之间添加空格也可以。 强调有时候，我们希望对某一部分文字进行强调，使用*或_包裹即可。使用单一符号标记的效果是斜体，使用两个符号标记的效果是加粗 12345*这里是斜体*_这里是斜体_**这里是加粗**__这里是加粗__ 这里是斜体这里是斜体 这里是加粗这里是加粗 高级用法插入代码块Markdown在IT圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码。 方法是，使用反引号`进行包裹即可。如果是行内代码引用，使用单个反引号进行包裹 这是一段var x = 3行内代码 如果插入一整段代码，需要至少使用两个以上反引号进行包裹， 看效果： 123fun (x: Int, y: Int): Int { return x + y} 注：很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧esc键下面的第一个键点击即可。 插入表格表格是Markdown语法中比较复杂的一个，其语法如下： 123表头|条目一|条目二:---:|:---:|:---:项目|项目一|项目二 以上标记显示效果如下： 表头 条目一 条目二 项目 项目一 项目二 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。 其它特殊符号处理Markdown使用反斜杠\\插入语法中用到的特殊符号。在Markdown中，主要有以下几种特殊符号需要处理： 123456789101112\\ 反斜线` 反引号* 星号_ 底线{} 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号 例如，如果你需要插入反斜杠，就连续输入两个反斜杠即可：\\\\ => \\ 。 注：在内容中输入以上特殊符号的时候一定要注意转义，否则将导致内容显示不全，甚至排版混乱。 如何给文字上色使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做： 先用Markdown编辑完成 导出为html，在需要上色的部分手动添加标签&lt;font color='#ff0000'&gt;&lt;/font&gt;保存即可。 Markdown软件推荐如果你是一个Mac用户，我推荐你使用开源的 MacDown： 如果你愿意花钱的话，一些收费产品其实更好。例如：Byword，Ulysses，Typora等等都很不错。 日常使用，我就用Macdown。写书，我就用Ulysses。 简单总结Markdown是一门比html更简单的标记语言，其主要用于日常写作。最终通过相应的编辑器或者脚本转换成html用于页面渲染。如果你是一个作家，或者是一个程序员，Markdown对你来说是一门必备的技能。掌握Markdown真的很简单，如你所见，这篇文章使用了这么短的篇幅就已经将Markdown的语法全部介绍完了。 不过，由于Markdown基础语法的限制，出现了一些针对Markdown语法的加强版本。它支持的语法特性更多，但这不是我们这篇文章的讨论范围。如果你希望快速掌握Markdown，很简单，动起来吧！ 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。","link":"/2018/04/18/it tips/最完整的Markdown基础教程/"},{"title":"2018最新Kotlin基础视频教程上线了","text":"从5月份开始制作这个视频，历时两个多月，终于在网易云课堂与大家见面了… 视频特色 在前期课程中，使用普通编辑器进行编码，治疗你的IDE依赖症 所有课程均使用live coding的方式授课，保持与你的频率一致 每节课程课后都准备了相应的习题供大家巩固练习 课程覆盖面广，线下效果持续跟踪 项目实战部分是一个非常有意思的小项目，使用控制台完成类QQ聊天室功能（支持文字消息、文件发送、文件下载等功能） 课程目录 Kotlin基础环境配置、变量与空值安全 一等公民函数基础语法 高阶函数、lambda表达式与匿名函数 面向对象知识点（类、接口、继承、扩展等） Kotlin语言中多样的class类型、对象以及枚举 强大的集合与控制流处理 操作符重载 更安全的泛型处理 代理模式及其应用 协程简介 析构、注解与异常处理 Kotlin与Java互通的那些事儿 控制台版本QQ聊天室项目实战 一些感想这是我第一次真正尝试录制视频教程，种种原因，导致整个视频的录制、剪辑加发布审核一共花掉了两个多月，将近三个月。而且还是离职在家，全职的情况下。 即便如此，事实上，这个视频依然没有达到我的要求。但我想，第一次永远是青涩的，想要一步到位永远不过是痴人说梦。我坚信下一个视频我会做的更好。因此，也希望大家对这个视频提出宝贵的意见。 视频介绍看这里在Kotlin交流群中，不少同学希望我能够出露脸视频。为了满足大家的愿望，我在课程的开始部分录制了一段真人解说视频。如果你不想看文字介绍的话，请移步到这里：http://study.163.com/course/courseLearn.htm?courseId=1005686004&amp;share=2&amp;shareId=400000000535034#/learn/video?lessonId=1052950023&amp;courseId=1005686004 如何观看这个视频教程目前，该视频教程仅上线了网易云课堂，同学们可以移步至这里观看：http://study.163.com/course/introduction.htm?courseId=1005686004&amp;share=2&amp;shareId=400000000535034 课程问题解惑如果你在使用Kotlin视频教程的时候遇到了任何问题，欢迎来我的Kotlin语言交流群里面提问。只要是关于视频课程的内容，一定有问必答。如果你没有购买这个视频教程，也可以添加这个QQ交流群，群里的小伙伴都非常热情。如果遇到了Kotlin语言问题，也可以在群里提问，同样会有问必答。 视频课程资料课程源码：https://github.com/yuanhoujun/kotlin-video-tutorial 习题答案：关注微信公众号【欧阳锋工作室】，回复“Kotlin视频教程”索取 Kotlin语言交流群 唯一官方Kotlin语言交流群：329673958，期待您的加入。","link":"/2018/07/09/kotlin/2018最新Kotlin基础视频教程上线了/"},{"title":"Kotlin难点解析：extension和this指针","text":"扩展（extension）是Kotlin语言中使用非常简单的一个特性。这篇文章并不是要讲解扩展的基本用法，而是解决在一些复杂场景中，扩展容易让人产生迷惑的一些问题。除了扩展，本篇文章还将讲解this指针在Kotlin语言中的基础用法。 扩展函数难点解析大多数场景下，你都能轻松搞定Kotlin扩展。可是，看看下面这个题目，你还能脱口而出，告诉我答案是什么吗？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647open class E {}open class E1: E() {}open class A { open fun E.f() { println(&quot;E.f in A&quot;) } open fun E1.f() { println(&quot;E1.f in A&quot;) } fun call(e: E) { e.f() }}class A1: A() { override fun E.f() { println(&quot;E.f in A1&quot;) } override fun E1.f() { println(&quot;E1.f in A1&quot;) }}fun main(args: Array&lt;String&gt;) { // a） A().call(E()) // b） A1().call(E()) // c） A().call(E()) // d） A().call(E1())} 问题：请告诉a，b，c，d位置代码执行的输出结果是什么？ 对于这个问题，恐怕你在纸上写写画画半天也不一定能给出正确答案吧。关于这个问题，其实我之前的一篇文章 [Kotlin] Lambda and Extension 中有提到过。可是，我认为这篇文章关于这部分的解释不够清晰，有必要再详细阐述一次。 Ok，let’s started。 为了解决这个问题，官方提出了两个新的概念：dispatch receiver和extension receiver。 dispatch receiver：中文翻译为分发接收者。所谓的分发接收者，就是声明这个扩展方法所在的类。即：在哪个类中声明，那个类就是你的分发接收者。 extension receiver：中文翻译为扩展接收者。所谓的扩展接收者，就是你实际扩展的那个类。举个例子：你针对Int类扩展了一个方法add，这个add方法的扩展接收者就是Int类实例。 为了简化，这里我们将dispatch receiver简称为DR，将extension receiver简称为ER。 还记得多态的概念吗？多态是一种运行时概念，即对象的类型要等到运行时才能最终确定。因此，一些语言中也将多态叫做类型延迟加载。解决上面这个问题我们需要关注就是扩展函数是否会产生多态行为。 这里我们将产生多态行为的技术叫做动态解析，与之相反的行为称之为静态解析。 为了解决上面的问题，你需要记住下面这个规则： DR类型是动态解析的 与之相反，ER类型是静态解析的 先看上面例子的a、b部分，很显然： a代码中f函数的DR是类A，ER是类E b代码中f函数的DR是类A1，ER是类E 参照上面的规则，由于DR类型是动态解析的。在A1类中我们重写了E的扩展函数f，运行时最终会执行A1类中扩展的f方法。a部分很明显会输出A类中扩展的f方法。因此，最终的输出结果如下： 12E.f in AE.f in A1 继续看c、d部分，c、d部分的DR都是A，而对于ER，c、d分别是E、E1。参照上面的规则，ER是静态解析的。在call方法声明的地方，我们传入的对象类型是E，这就决定了无论扩展方法是来自E还是其子类，将始终执行E类的扩展方法。因此，c、d部分将输出同样的结果： 12E.f in AE.f in A 由此可见，如果你牢记上述两条规则，解决问题将变得非常容易。为了加强你的记忆，我用一个表格总结上面的知识点： - DR ER 概念 扩展方法声明所在的类 声明扩展方法的类 解析方式 动态解析 静态解析 PS：由于新版本Kotlin中针对扩展函数也加入了override关键字，这非常有助于DR和ER的理解。如果你在使用Kotlin，强烈建议你更新到最新版本。 不太一样的this指针在Java语言中，如果你在内部类中需要外部类的引用可以将this写在类名后面。可是，试试看Kotlin，果断不行。 为了获得外部类的引用，Kotlin语言引入了@符号。举个例子： 1234567class Outer { inner class Inner { fun f() { println(this@Outer) } }} 可以看到，为了获取外部类的引用，只需要在@后面接外部类的名称即可。 如果对应一个扩展函数，this引用指向是什么呢？先说答案，扩展函数中的this指针指向ER，即实际扩展的那个类对象。 123fun Outer.foo() { println(this)} 这里的this指向foo函数的接收者Outer类实例。 this指针还有一种场景是用在lambda表达式中，这是一种比较特殊的使用场景。lambda表达式本身没有任何接收者，如果是在全局声明一个lambda表达式，将不能使用this指针。而如果是在某个类或者扩展方法中使用this指针，将指向实际所在类或者扩展方法的接收者。 如果你习惯了Kotlin语言的这种表达方式，this指针的指向就不再是一个问题了。在你习惯这种用法之前，我用一个表格简单总结一下this指针的用法： 位置 指向 类中 默认指向当前类实例，使用@操作符指向具体外部类实例 扩展函数 默认指向扩展函数的接收者 lambda表达式 默认指向实际所在类实例或所在扩展函数的接收者 总结关于扩展，大多数情况下，你不会遇到文章开头那种复杂的情况。如果遇到了这种情况，只要清楚地区分DR和ER，并牢记DR和ER的解析方式，就能轻松应对了。对于this指针，与Java语言不一样的地方是，为了引用具体类的实例，Kotlin语言使用@符号。个人认为，这种表述方式更自然。如果遇到某些比较复杂的情况，只需要弄清楚接收者，问题就引刃而解了。","link":"/2018/04/14/kotlin/Kotlin难点解析：extension和this指针/"},{"title":"你是否也被Kotlin语言的object绕晕了呢","text":"近日，在笔者的Kotlin语言交流群中。的确发现了一些同学对object的用法有一些疑问。于是，出现了下面这样错误的用法： 很自然的想法，c是一个接口类型的成员变量，访问外部类的成员变量，这不是理所应当的吗？ 即使查看Kotlin官方文档，也有这样一段描述： Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it. Java handles this case with anonymous inner classes. Kotlin slightly generalizes this concept with object expressions and object declarations. 核心意思是：Kotlin使用object代替Java匿名内部类实现。 很明显，即便如此，这里的访问应该也是合情合理的。从匿名内部类中访问成员变量在Java语言中是完全允许的。 这个问题很有意思，解答这个我们需要生成Java字节码，再反编译成Java看看具体生成的代码是什么。 借助JD-GUI，我们可以看到下面的内容： 1234567891011121314151617181920public final class Outer{ private String a; public static final class c implements Moveable { public static final c INSTANCE; static { c localc = new c();INSTANCE = localc; } public void move() { Moveable.DefaultImpls.move(this); } }} 很有意思，我们在Kotlin类中object部分的代码最终变成了下面这个样子： 12345678910public static final class c implements Moveable { public static final c INSTANCE; static { c localc = new c();INSTANCE = localc; } public void move() { Moveable.DefaultImpls.move(this); } } 这是一个静态内部类，很明显，静态内部类是不能访问外部类成员变量的。可是问题来了，说好的匿名内部类呢？ 这里一定要注意，如果你只是这样声明了一个object，Kotlin认为你是需要一个静态内部类。而如果你用一个变量去接收object表达式，Kotlin认为你需要一个匿名内部类对象。 因此，这个类应该这样改进： 123456789101112class Outer { private var a: String? = null // 用变量c去接收object表达式 private val c = object: Moveable { override fun move() { super.move() // 改进后，这里访问正常 println(a) } }} 为了避免出现这个问题，谨记一个原则：如果object只是声明，它代表一个静态内部类。如果用变量接收object表达式，它代表一个匿名内部类对象。 object能干啥？很自然地想到，Kotlin的object到底有什么作用。其实，从上文的表述来看。很明显，object至少有下面两个作用： 简化生成静态内部类 生成匿名内部类对象 其实，object还有一个非常重要的作用，就是生成单例对象。如果你需要在Kotlin语言中使用单例，非常简单，只需要使用object关键字即可。 123456789object Singleton { fun f1() { } fun f2() { }} 这种方式声明object和上面的方式略有区别，其最终会生成一个名为Singleton的类，并在类中生成一个静态代码块进行单例对象生成： 12345678910111213public final class Singleton{ public static final Singleton INSTANCE; public final void f1() {} public final void f2() {} static { Singleton localSingleton = new Singleton();INSTANCE = localSingleton; }} 在Kotlin语言中对方法进行访问的时候最终其实是通过INSTANCE实例进行中转的。 在Kotlin语言中还有一个很常用的object叫做伴随对象。所谓的伴随对象只不过是名字叫做Companion的object而已。它主要用于类中生成类似Java的静态变量，Kotlin语言针对这个变量会认为你只是希望生成一个静态变量，而不希望引入多余的类。如果你是和Java语言混合开发的话，可以使用一个注解生成和Java语言静态变量完全一样的效果。 简单总结Kotlin语言中使用object命名的方式的确容易让人误认为只要使用这个关键字就是生成了一个对象。而从上文的表述当中，你会发现，其实不同的使用姿势将产生不同的效果。因此，在日常使用中一定要学会随机应变。如果遇到了不明白的问题，不妨来看看这篇文章是否已经解答了你的问题。如果没有，请在文章下方留言告诉我。 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。","link":"/2018/04/14/kotlin/你是否也被Kotlin语言的object绕晕了呢/"},{"title":"关于Kotlin抛弃可检测的异常处理，你怎么看？","text":"可检测的异常英文翻译为Checked Exception，以下简称为CE。CE是一个备受争议的话题，有人主张CE是一个不可或缺的特性，也有人认为CE带来了一些问题，是一个冗余特性。这其中的支持者和反对者中都不乏软件行业的大佬。今天，我们借助这篇文章一起来讨论一下CE存在的必要性。 什么是CE部分同学可能还不知道CE到底是什么。因此，在开始命题之前，有必要给大家解释一下CE的概念。 CE其实你每天都在用，只是你不知道它的存在而已。看一个例子你就明白了： 1public void readString() throws IOException, FileNotFoundException {} 在这个函数声明的最后面，我们指定了函数可能抛出的异常，在使用的时候我们就可以针对具体的异常使用try {} catch() {}进行处理了。 由于我们在方法声明中指定了可能抛出的异常，因此方法具体可能抛出的异常是已知的，这就称之为可检测的异常（CE）。由于CE的声明来自编译阶段，因此IDE可能帮助你智能判断强制你针对某些异常进行处理，并给出友好提示。 这是一个很好的特性，不是吗？ 想象一下，如果有一天，我们不能在函数上指定可抛出的异常了，会怎样？我们无法确定函数可能抛出的异常，并且可能会因为没有正确处理某个异常而导致程序奔溃。 可是，就是有人认为CE多此一举，并且Kotlin语言就是其中的支持者。为什么会有人坚定地认为CE多此一举呢？这是下一个我们要讨论的话题。 关于CE的争论Java语言的CE设计借鉴了C++，而在受到Java影响的那些语言中，例如C#、Ruby等都去掉了CE的设计，这从实践的角度证明CE的存在确实意义不大。 在这个问题中，C#的主导工程师Anders Hejlsberg最有发言权。老实说，笔者并没有用过C#。可是，如果你搜索一下网络上关于C#和Java对比的文章你就会发现：C#被认为是一门比Java更优秀的编程语言，它始终在新增一些现代语言的特性，使你毫不费力地使用它。而Java作为一门古老的语言，受限于一些原始设计，在增加新特性时总是步履维艰，甚至有点不伦不类。 关于CE的设计，有人对Anders Hejlsberg进行过一次采访。采访的原文链接在这里：https://www.artima.com/intv/handcuffs.html 关于CE，Anders Hejlsberg认为它带来了两个问题版本问题和扩展问题。 所谓的版本问题是什么意思呢？Anders Hejlsberg举了一个例子： 假设有一个方法foo，它声明了抛出异常A、B和C，在下一个版本设计的时候，foo增加了一个新的特性，可能会抛出异常D。对于设计者来说，很明显这是一个大的改变，几乎可以确定的是，客户程序员不会去处理这个异常。为了避免出现问题，设计者不得不声明一个新的方法foo2，抛出一个新的异常。然后，客户程序员可以将针对foo的逻辑处理切换到foo2。 而所谓的扩展问题又是什么意思呢？这更好理解，以下来自Anders Hejlsberg的原话翻译并整理： 如果你在设计一个很小的系统，声明一个方法抛出一个异常，这很棒。可是，如果你尝试构建一个大的系统，其中包含了四、五个小系统的时候，问题来了。假设每个子系统可能抛出四到五个异常，而每上升一个系统，就犹如爬阶梯，异常数量会指数倍增加，最终你可能处理的异常将达到40个甚至80个。很显然，这是一个很糟糕的设计！ Anders Hejlsberg的话有理有据。可是，中国的 王垠 并不同意这个观点。关于Kotlin的CE设计，他写了一篇文章专门讲了这个问题，文章的原稿在这里：Kotlin 和 Checked Exception 看完王垠的文章，你会发现，他并不赞同Anders Hejlsberg的话。他认为，所谓的版本问题和扩展问题，其实都来自于程序员的滥用。只要处理得当，CE带来的好处是无法取代的。 其实，关于CE的争论还远不止Anders Hejlsberg和王垠两人。互联网上有很多关于这个问题的讨论。如果你感兴趣，可以Google了解一下。 你怎么看？很显然，Kotlin语言受到了C#设计的影响，手起刀落，去掉了CE的设计。对于客户程序员来说，显而易见的一个改变是，你再也不能在Kotlin的方法声明中指定可能抛出的异常了。对于Kotlin语言的这种设计，你是赞成还是反对呢？ 欢迎参与投票讨论扫描下方二维码关注欧阳锋工作室，回复“CE”参与投票，或在所有文章中选择同名文章进行投票。 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。","link":"/2018/04/27/kotlin/关于Kotlin抛弃可检测的异常处理，你怎么看？/"},{"title":"测测你的Kotlin基础","text":"本次测试满分160分，测测看，你能拿几分 &lt;&lt;&lt; 1）Kotlin语言有基本数据类型吗？（5分）2）Kotlin中有哪些访问控制符，分别代表什么意思？默认访问控制符是什么？（5分）3）Kotlin接口是否允许有方法实现？是否允许声明成员变量？（5分）4）Sealed类有什么作用？（5分）5）Kotlin语言中如何实现类似Java创建匿名内部类对象？（10分）6）Kotlin的扩展相对继承有什么优势？扩展方法的执行是否也遵循多态？（10分）7）如果一个类同时实现多个接口，接口中存在同名方法，如何解决冲突？（5分）8）Kotlin语言中是否存在static关键字，如果没有，如何声明静态变量，并实现与Java互通（5分）9）使用Kotlin语言是否一定不会出现空指针异常？为什么？（10分）10）Kotlin语言中推荐使用什么方式判断两个对象是否相等？如何判断两个对象是同一个对象？（5分）11）如果使用Foo&lt;out T: TUpper&gt;这种方式声明泛型，使用Foo&lt;*&gt;这种方式接收该对象实例，代表什么意思？如何理解Kotlin泛型，与Java有什么区别？（10分）12）如何自定义setter/getter方法？（5分）13）使用语句var x = null声明变量x是否合法？如果合法，x的具体类型是什么？(5分)14）下面这段代码的输出结果是什么？（10分）123val list = listOf(1, 2, 3)list.add(4)println(list) 15）下面这段代码的执行结果是什么？（5分）123456789// Kotlin端object A { fun init() { println(&quot;A init&quot;) }}// Java端A.init() 16）下面代码的执行结果是什么？（5分）123fun sum(a: Int, b: Int) = { a + b }println(sum(1, 3)) 17）下面代码的执行结果是什么？（5分）12println(null is Any)println(null!! is Nothing) 18）下面代码的执行结果是什么？（10分）123456789101112131415class A { init() { f() } val a = &quot;a&quot; fun f() { println(a) }}fun main(args: Array&lt;String&gt;) { A()} 19）下面代码的执行结果是什么？（10分）12println(127 as Int? === 127 as Int?)println(128 as Int? === 128 as Int?) 20）下面代码的执行结果是什么？如果运行异常，应该怎样修改才能达到预期效果？（10分）1234(1..5).forEach { if (it == 3) break println(it)} 21）下面代码的执行结果是什么？如果运行异常，应该怎样修改，为什么要这样修改？（10分）123val A.x: Int = 3println(A().x) 22）下面这段代码的执行结果是什么？（10分）12345678910111213fun isOdd(x: Int) = x % 2 != 0fun length(s: String) = s.lengthfun &lt;A, B, C&gt; compose(f: (B) -&gt; C, g: (A) -&gt; B): (A) -&gt; C { return { x -&gt; f(g(x)) }}fun main(args: Array&lt;String&gt;) { val oddLength = compose(::isOdd, ::length) val strings = listOf(&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;) println(strings.filter(oddLength))} 注：本篇例子Kotlin版本为1.2.31，更新版本可能存在部分差异 下面是你的基础等级： 得分 评价 0 ~ 80 基础较差 80 ~ 108 基础较好 108 ~ 160 基础很棒 查看答案方法微信扫描下方二维码关注欧阳锋工作室，回复“Kotlin测试题答案”即可获取当前测试题答案 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。","link":"/2018/04/27/kotlin/测测你的Kotlin基础/"},{"title":"Android两行代码实现仿微信滑动返回效果","text":"iPhone滑动关闭页面是一个非常讨喜的设计。滑动关闭可以让你聚焦屏幕内容，而不需要因为返回突然切换思维到屏幕下方寻找返回按钮。事实上，在使用Android手机的时候，我经常这样做。原因是，Android不同机型的返回按钮位置不一样。以至于在更换机型后我常常找不到返回按钮，需要一段时间的适应期。而滑动关闭就可以有效地避免这个问题，目前已经有很多类型的Android应用开始支持滑动关闭，比如你熟悉的微信、快手等都已经支持了滑动返回效果。使用 Snake 框架你只需要两行代码就可以搞定滑动关闭集成… 如果你还不知道Snake是什么，请关注简书下面的文章： Snake 让你轻松实现类似iOS滑动关闭功能 Snake版本升级到0.0.5啦 将滑动关闭进行到底 Snake版本再升级，支持类iPhone X上滑退出到桌面功能 初体验如果你需要在Activity中实现滑动关闭效果，使用如下两个步骤即可： 在你的Application中对Snake进行初始化：Snake.init(this) 在你的Activity类的onCreate方法中对其进行托管：Snake.host(this) 以上两个方法已经完成了Activity滑动关闭集成，为了开启滑动关闭功能，你还需要在Activity类顶部添加@EnableDragToClose注解 Snake设计思路为了保证Snake框架尽可能灵活，我使用了注解实现单页固定滑动参数配置。而全局配置则使用单独的snake.xml文件进行配置。同时，为了支持动态关闭和开启，在Snake类中提供了相关API用于动态控制滑动关闭和开启。 设计目标看过Snake官方文档的同学会发现，Snake并不提供左滑关闭或者其它方向关闭页面的设置，Snake也没有提供不同的关闭效果设置。没有这样设计的原因很简单，因为这种关闭效果并不常见，这样的设计不过是哗众取宠，浪费时间，且增加使用难度。 我的目标是：尽可能简化Snake设计，仅提供必要API，且专注于滑动关闭效果实现。 新版本来了这是本篇文章的重点，昨天，Snake 0.3.0 版本已经发布了。 0.3.0版本主要针对Fragment提供了继承方式集成： 使用方法按照下面的对应关系，改变你的Fragment父类就可以完成滑动关闭集成: android.app.Fragment =&gt; com.youngfeng.snake.app.Fragment android.support.v4.app.Fragment =&gt; com.youngfeng.snake.support.v4.app.Fragment 注意：使用继承方式集成的情况下，原来的API完全可以通用。你可以选择使用Snake的API进行滑动控制，也可以使用父类中的方法进行滑动控制，这取决于你自己。甚至实例创建你依然可以交给newProxy/newProxySupport接口。 详细信息，请查看官方文档：https://github.com/yuanhoujun/Android_Slide_To_Close 交流群QQ群：288177681如果你在使用Snake的过程中，遇到任何问题，请使用QQ群联系我。 我是 欧阳锋，开源的道路上，我与你同行。","link":"/2018/03/06/open source/Android两行代码实现仿微信滑动返回效果/"},{"title":"Kotlin语言中的泛型设计哲学","text":"Kotlin语言的泛型设计很有意思，但并不容易看懂。关于这个部分的官方文档，我反复看了好几次，终于弄明白Kotlin语言泛型设计的背后哲学。这篇文章将讲述Kotlin泛型设计的整个思考过程及其背后的哲学思想，希望可以解答你心中的疑问。不过，可以预见地，即使看完，你也未必完全明白这篇文章在说什么，但至少希望你通过这篇文章可以快速掌握Kotlin泛型的用法。 Kotlin泛型的设计初衷我们认为，Kotlin是一门比Java更优秀的JVM编程语言，Kotlin泛型设计的初衷就是为了解决Java泛型设计中一些不合理的问题。这样说可能不够直观，看下面这个例子： 123 List&lt;String&gt; strs = new ArrayList&lt;&gt;();// 这里将导致编译错误，Java语言不允许这样做 List&lt;Object&gt; objs = strs; 很明显，String和Object之间存在着安全的隐式转换关系。存放字符串的集合应该可以自由转换为对象集合。这很合理，不是吗？ 如果你这样认为的话，就错了！继续往下看，我们扩展这个程序： 12345List&lt;String&gt; strs = new ArrayList&lt;&gt;();List&lt;Object&gt; objs = strs;objs.add(1);String s = strs.get(0); 很明显，这不合理！我们在第一个位置存入了整型数值1，却在取的时候将它当成了字符串。strs本身是一个字符串集合，用字符串接收读取的数据的逻辑是合理的。却因为错误的类型转换导致了不安全写入出现了运行时类型转换问题，因此，Java语言不允许我们这样做。 大多数情况下，这种限制没有问题。可是，在某些情况下，这并不合理。看下面的例子： 1234567interface List&lt;T&gt; { void addAll(List&lt;T&gt; t);}public void copy(List&lt;String&gt; from, List&lt;Object&gt; to) { to.addAll(from);} 这是一个类型绝对安全的操作，但在Java语言中这依然是不允许的。原因是，泛型是一个编译期特性，一旦指定，运行期类型就已经固定了。换而言之，泛型操作的类型是不可变的。这就意味着，List并不是List的子类型。 为了允许正确执行上述操作，Java语言增加了神奇的通配符操作魔法。 123interface List&lt;T&gt; { void addAll(List&lt;? extends T&gt; t);} ? extends T意味着集合中允许添加的类型不仅仅是T还包括T的子类，但这个集合中可以添加的类型在集合参数传入addAll时就已经确定了。因此，这并不影响参数集合中可以存放的数据类型，它带来的一个直接影响就是addAll方法参数中终于可以传入泛型参数是T或者T的子类的集合了，即上面的copy方法将不再报错。 这很有意思，在使用通配符之前我们并不能传入类型参数为子类型的集合。使用通配符之后，居然可以了！这个特性在C#被称之为协变（covariant）。 协变这个词来源于类型之间的绑定。以集合为例，假设有两个集合L1、L2分别绑定数据类型F、C，并且F、C之间存在着父子关系，即F、C之间存在着一种安全的从C-&gt;F的隐式转换关系。那么，集合L1和L2之间是否也存在着L2-&gt;L1的转换关系呢？这就牵扯到了原始类型转换到绑定类型的集合之间的转换映射关系，我们称之为“可变性”。如果原始类型转换和绑定类型之间转换的方向相同，就称之为“协变”。 用一句话总结协变：如果绑定对象和原始对象之间存在着相同方向的转换关系，即称之为协变。 PS：以上关于协变的概念来自笔者的总结，更严谨的概念请参考C#官方文档。 文章开头我们将不可变泛型通过通配符使其成为了可变泛型参数，现在我们知道这种行为叫做协变。很明显，协变转换中写入是不安全的。因此，协变行为仅仅用于读取。如果需要写入怎么办呢？这就牵扯到了另外一个概念逆变（contravariance）。 逆变与协变恰恰相反，即如果F、C之间存在着父子转换关系，L1、L2之间存在着从L1-&gt;L2的转换关系。其绑定对象的转换关系与原始对象的转换关系恰好相反。Java语言使用关键字super（？super List）实现逆变。 举个例子：假设有一个集合List&lt;? super String&gt;，你将可以安全地使用add(String)或set(Int，String)方法。但你不能通过get(Int)返回String对象，因为你无法确定返回的对象是否是String类型，你最终只能得到Object。 因此，我们认为，逆变可以安全地写入数据，但并不能安全地读取，即最终不能获取具体的对象数据类型。 为了简化理解，我们引入官方文档中 Joshua Bloch 说的一句话： Joshua Bloch calls those objects you only read from Producers, and those you only write to Consumers. He recommends: “For maximum flexibility, use wildcard types on input parameters that represent producers or consumers” Joshua Bloch是Java集合框架的创始人，他把那些只能读取的对象叫做生产者；只能写入的对象叫做消费者。为了保证最大灵活性，他推荐在那些代表了生产者和消费者的输入参数上使用通配符指定泛型。 相对于Java的通配符，Kotlin语言针对协变和逆变引入两个新的关键词out和in。 out用于协变，是只读的，属于生产者，即用在方法的返回值位置。而in用于逆变，是只写的，属于消费者，即用在方法的参数位置。 用英文简记为：POCI = Producer Out , Consumer In。 如果一个类中只有生产者，我们就可以在类头使用out声明该类是对泛型参数T协变的： 123interface Link&lt;out T&gt; { fun node(): T} 同样地，如果一个类中只有消费者，我们就可以在类头使用in声明该类是对泛型参数T逆变的： 123interface Repo&lt;in T&gt; { fun add(t: T)} out等价于Java端的? extends List通配符，而in等价于Java端的? super List通配符。因此，类似下面的转换是合理的： 1234567891011121314151617interface Link&lt;out T&gt; { fun node(): T}fun f1(linkStr: Link&lt;String&gt;) { // 这是一个合理的协变转换 val linkAny: Link&lt;Any&gt; = linkStr}interface Repo&lt;in T&gt; { fun add(t: T)}fun f2(repoAny: Repo&lt;Any&gt;) { // 这是一个合理的逆变转换 val repoStr: Repo&lt;String&gt; = repoAny} 小结：协变和逆变协变和逆变对于Java程序员来说是一个全新的概念，为了便于理解，我用一个表格做一个简单的总结： - 协变 逆变 关键字 out in 读写 只读 可写 位置 返回值 参数 角色 生产者 消费者 类型投影在上面的例子中，我们直接在类体声明了泛型参数的协变或逆变类型。在这种情况下，就严格限制了该类中只允许出现该泛型参数的消费者或者生产者。很显然，这种场景并不多见，大多数情况下，一个类中既存在着消费者又存在着生产者。为了适应这种场景，我们可以将协变或逆变声明写在方法参数中。Kotlin官方将这种方式叫做 类型投影（Type Projection）。 这里我们直接使用官方文档的例子： 12345678910111213141516class Array&lt;T&gt;(val size: Int) { fun get(index: Int): T { /* ... */ } fun set(index: Int, value: T) { /* ... */ }}fun copy(from: Array&lt;Any&gt;, to: Array&lt;Any&gt;) { assert(from.size == to.size) for (i in from.indices) to[i] = from[i]}val ints: Array&lt;Int&gt; = arrayOf(1, 2, 3)val any = Array&lt;Any&gt;(3) { &quot;&quot; } // 由于泛型参数的不变性，这里将出现问题copy(ints, any) 很明显，我们希望from参数可以接收元素为Any或其子类的任意元素，但我们并不希望修改from，以防止出现类似文章开头的问题。因此，我们可以在from参数中添加out修饰，使其协变： 12fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) {} 一旦添加out修饰符，你就会发现，当你尝试调用set方法的时候，编译器将会提示你在out修饰的情况下禁止调用该方法。 注：Java语言在使用”协变“的情况下，from参数依然可以调用set方法。从这里可以看出，Kotlin语言在泛型安全控制上比Java更加精细。 星号投影除了上述明确的类型投影方式之外，还有一种非常特殊的投影方式，称之为星号投影（star projection）。 在某些情况下，我们并不知道具体的类型参数信息。为了适应这种情况，Java语言中我们会直接忽略掉类型参数： 12345678class Box&lt;T&gt; { public void unPack(T t) { ... }}// 在不确定类型参数的情况下，我们会这样做Box box = new Box(); 在Kotlin语言中，我们使用星号对这种情况进行处理。因为，Kotlin针对泛型有严格的读写区分。同样地，使用*号将限制泛型接口的读写操作： Foo&lt;out T: TUpper&gt;，这种情况下，T是协变类型参数，上边界是TUpper。Foo&lt;*&gt;等价于Foo，这意味着你可以安全地从Foo&lt;*&gt;读取TUpper类型。 Foo&lt;in T&gt;，在这种情况下，T是逆变类型参数，下边界是T。Foo&lt;*&gt;等价于Foo，这意味着在T未知的情况下，你将无法安全写入Foo&lt;*&gt;。 Foo&lt;T: TUpper&gt;，在这种情况下，T是不可变的。Foo&lt;*&gt;等价于你可以使用Foo安全读取值，写入等价于Foo，即无法安全写入。 泛型约束在泛型约束的控制上，Kotlin语言相对于Java也技高一筹。在大多数情况下，泛型约束需要指定一个上边界。这同Java一样，Kotlin使用冒号代替extends： 1fun &lt;T: Animal&gt; catch(t: T) {} 在使用Java的时候，经常碰到这样一个需求。我希望泛型参数可以约束必须同时实现两个接口，但遗憾的是Java语言并没有给予支持。令人惊喜的是，Kotlin语言对这种场景给出了自己的实现： 1234fun &lt;T&gt; swap(first: List&lt;T&gt;, second: List&lt;T&gt;) where T: CharSequence, T: Comparable&lt;T&gt; { } 可以看到，Kotlin语言使用where关键字控制泛型约束存在多个上边界的情况，此处应该给Kotlin鼓掌。 总结Kotlin语言使用协变和逆变来规范可变泛型操作，out关键字用于协变，代表生产者。in关键字用于逆变，代表消费者。out和in同样可以用于方法参数的泛型声明中，这称之为类型投影。在针对泛型类型约束的处理上，Kotlin增加了多个上边界的支持。 Kotlin语言最初是希望成为一门编译速度比Scala更快的JVM编程语言！为了更好地设计泛型，我们看到它从C#中引入了协变和逆变的概念。这一次，我想，它至少同时站在了Scala和C#的肩膀上。 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。","link":"/2018/04/17/kotlin/Kotlin语言中的泛型设计哲学/"},{"title":"Kotlin 代理模式","text":"代理模式是23种经典设计模式之一，代理模式被认为是继承的更好替代解决方案；因为代理比继承更加灵活，在Java语言中，通过反射可以实现动态代理，动态代理可以实现AOP编程，即：可以动态地往已有类中添加逻辑；比如：实现事务的自动提交，异常的自动捕获，热修复等等; 在Kotlin语言中，代理模式是默认支持的，不需要任何额外的代码，你只需要记住一个关键字by。我们不妨来试一下: 12345678910111213141516interface Base { fun sayHi()}class BaseImpl : Base { override fun sayHi() { println(&quot;BaseImpl-&gt;sayHi&quot;) }}class Derived(b: Base) : Base by bfun main(args: Array&lt;String&gt;) { val b = BaseImpl() val derived = Derived(b) derived.sayHi()} 这里Derived作为BaseImpl的代理类，拥有BaseImpl类中的所有方法，Derived将代理BaseImpl类执行BaseImpl类中的所有方法，就像继承自BaseImpl类一样。这样说起来有点抽象，来看一下Kotlin编译器具体为我们做了一些什么。但是，怎么看呢？教大家一个方法！大家都知道，Kotlin和Java均是JVM语言，最终均转换到同样的Java字节码，这样我们就可以先将Kotlin编译为.class文件，再反编译为.java文件，看看对应的Java代码，我们就可以看到更多的细节。下面是最终反编译生成的Java代码: 12345678public final class Derived implements Base { public Derived(@NotNull Base b) { this.$$delegate_0 = b; } public void sayHi() { this.$$delegate_0.sayHi(); }} 这里，我们可以清楚地看到，Kotlin编译器为我们动态添加了一个成员变量$$delegate_0，这个成员变量代表被代理的对象，这里对应的是BaseImpl对象，Derived里面的sayHi方法最终调用是代理对象的sayHi方法，即Kotlin编译器帮我们提供了一个非常漂亮的代理模式实现。 代理属性在一些情况下，我们可能希望某些属性延迟加载，即在我们正在需要的时候才对它赋值；亦或者我们希望可以随时监听属性值的变化；在上述这些场景中，代理属性就可以发挥作用了。 代理属性的语法格式如下： 123456789101112131415161718class DelegateProperty { val d: String by Delegate()}class Delegate { operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): String { return &quot;Invoke getValue() , thisRef = $thisRef , property name = ${property.name}&quot; } operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: String) { println(&quot;Invoke setValue() , thisRef = $thisRef , property name = ${property.name} , value = $value&quot;) }}fun main(args: Array&lt;String&gt;) { val dp = DelegatedProperty() dp.d = &quot;Value0&quot; // Invoke setValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d , value = Value0 println(dp.d) // Invoke getValue() , thisRef = DelegatedProperty@2ef1e4fa , property name = d} 这里的代理是如何实现的呢？我们知道，Kotlin的属性值会自动生成set/get方法，而代理类通过代理set/get方法生成相应的代理方法，这里的方法对应关系如下： 1234// thisRef对应代理对象的引用，property对应代理属性的反射属性封装// 注意这里的代理方法一定要添加operator关键字，operator关键字是重载操作符关键字，后续的文章中会讲到，敬请期待get() -&gt; operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;)set() -&gt; operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) Kotlin标准库提供了一些常用代理的方法实现，即上文提到的几种代理，先来看第一种：延迟加载。 延迟加载Kotlin提供了一个lazy方法用于实现延迟加载，lazy方法有一个lambda表达式参数，用于对属性进行初始化赋值，而一旦完成赋值，该lambda表达式将不会再次调用。lambda表达式调用发生在第一次使用该属性的时候，即实现了属性赋值的延迟加载。来看一个简单的例子: 1234567891011// 使用标准库实现的lazy函数，实现属性的延迟加载private val lazyValue: String by lazy { println(&quot;调用该初始赋值表达式完成赋值&quot;) // 这里是实际赋值 &quot;Hello, world&quot;}fun main(args: Array&lt;String&gt;) { // 仅在第一次会调用lazy方法的lambda表达式 println(lazyValue) // 打印：调用该初始赋值表达式完成赋值 println(lazyValue) // 打印： Hello, world, 再次调用将不再调用lambda表达式} lazy方法是一个线程安全的延迟加载方法，为了加深大家的理解，根据上面的原理，我们尝试自己来实现一个非线程安全的延迟加载方法，看具体实现： 1234567891011121314151617181920212223242526272829private object UNINITIALIZE_VALUEclass MyLazy&lt;T&gt;(initialize: ()-&gt;T) { private var value: Any? = UNINITIALIZE_VALUE private val initialize = initialize operator fun getValue(thisRef: Any? , property: KProperty&lt;*&gt;): T { if(value == UNINITIALIZE_VALUE) { value = initialize() } return value as T } operator fun setValue(thisRef: Any? , property: KProperty&lt;*&gt; , value: T) { this.value = value }}// 为了和标准库区分，使用__lazy命名fun &lt;T&gt; __lazy(initialize: () -&gt; T): MyLazy&lt;T&gt; = MyLazy(initialize)var lazyValue1 by __lazy { println(&quot;自定义lazy初始化赋值表达式被调用&quot;) &quot;Hello , world&quot;}fun main(args: Array&lt;String&gt;) { // 自定义延迟加载函数__lazy println(lazyValue1) lazyValue1 = &quot;Other value&quot; println(lazyValue1)} 由此可见，实现一个延迟加载接口并不复杂，最重要的是要理解延迟加载的过程以及实现原理。总结实现延迟加载接口，需要注意三个地方： 需要提供初始化lambda表达式参数，用于初始赋值 需要实现代理属性对象的setValue/getValue方法，如果是val则只需要实现getValue即可 需要严格确保属性不会被多次初始化 Observable属性Kotlin标准库还提供了一个可观察属性，这个属性使用观察者模式实现，如果属性值发生变化则会调用相应的回调lambda接口通知使用者，先看一个具体的例子: 123456789var observableValue by Delegates.observable(&quot;Initial value&quot;) { prop , old , new -&gt; println(&quot;$old -&gt; $new&quot;)}fun main(args: Array&lt;String&gt;) { println(observableValue) // 打印：Initial value observableValue = &quot;Hello&quot; // 打印: Initial value -&gt; Hello println(observableValue) // 打印：Hello} 这里的具体实现，感兴趣的同学请参看文章开头的方法进行追踪！ Storing Properties in a Map这也是Kotlin标准库提供的一个非常有用的特性，它主要用于JSON数据的解析。看官方的例子： 123456789class User(val map: Map&lt;String, Any?&gt;) { val name: String by map val age: Int by map}val user = User(mapOf( &quot;name&quot; to &quot;John Doe&quot;, &quot;age&quot; to 25)) 该方法比较简单，这里就不再赘述了！ 总结至此，关于代理的介绍可以暂时告一段落了！代理模式是一个非常经典设计模式，在解决某些问题中可以发挥事半功倍的效果。幸运的是，Kotlin语言原生支持代理模式，实现代理模式如同声明一个属性一样简单。而且，代理模式的设计也非常漂亮，仅仅使用一个关键字by极尽简约之美。在日常编码中，一定要灵活运用代理模式，比如实现延迟加载，实现属性观察等等。KotterKnife 是一个非常经典的代理模式的实现例子，有兴趣的同学可以clone该仓库，查看源码，领会代理模式的优美。 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。 文章源码地址Kotliner: https://github.com/yuanhoujun/Kotliner,别忘了点击仓库右上方的star哦！","link":"/2016/08/22/kotlin/delegation/"},{"title":"也许你应该试试用Kotlin写Gradle脚本","text":"Android应用开发中，离不开Gradle脚本的构建。大部分Android开发同学忽视了脚本的力量，甚至有很大一部分同学不知道Gradle脚本是什么，用什么语言编写的；当然，也有相当一部分同学知道Gradle脚本是使用Groovy语言编写的，但对于Groovy语言却一窍不通，只是勉强可以看懂Gradle脚本。正所谓，知其然，但并不知其所以然… 换个角度看问题，熟练掌握Gradle脚本还需要精通Groovy语言，这对Android开发同学来说的确是一个不小的挑战。这种Java + Groovy的开发套餐对于普通的Android开发者来说的确存在一定的知识断层，显而易见的是，部分同学写的Gradle脚本简直“不堪入目”。时间回到去年5月份，Google IO大会上宣布了一个重磅消息，Android官方开始支持使用Kotlin语言进行应用开发。其实，在这个时间节点上，我已经在生产环境使用Kotlin开发Android将近一年。对于我来说，这无疑是一个让人欣喜若狂的消息。但，惊喜还远远不止这些，过了一段时间，我又看到了这篇文章 Kotlin Meets Gradle。很有诗意的标题：当Gradle邂逅Kotlin，文章的核心意思是：Gradle团队正在尝试使用Kotlin语言作为Gradle脚本的官方开发语言。 我想，也许，Android开发者的春天就要到了！ Why use Kotlin ?在写Gradle脚本的时候，最痛苦的莫过于没有任何提示，唯一的调试手段就是使用print方法打印调试日志。正如 Kotlin Meets Gradle 文中所说，当你使用Kotlin语言编写Gradle脚本的时候，你会发现一切都变得有趣起来。突然： 脚本代码可以自动补全了 源码之间可以互相跳转了 插件源码更容易看懂了 重构（Refactoring）也可以支持了… 当然，惊喜还不止这些，当你开始决定使用Kotlin语言的时候，仿佛一切都变得美好了起来！ Let’s start好了，废话不多说，接下来我们开始尝试用Kotlin语言编写Gradle脚本。由于当前 kotlin-dsl 正处于预发布状态（kotlin-dsl的最新版本是0.14.2，对应Gradle插件版本4.5），IDE的支持也不完善，为了更好的体验该功能，推荐大家使用如下配置： 实验室配置操作系统：macOS 10.13.2Android Studio： 3.1 Canary 9Gradle Wrapper： 4.5Gradle Plugin： 3.1.0-alpha9Kotlin：1.2.21 操作步骤首先，按照以往步骤创建一个Android工程： 接下来，改造开始，Gradle Script Kotlin脚本以.gradle.kts后缀结尾。因此，我们先将工程根目录settings.gradle更名为settings.gradle.kts。 这个地方的错误有两个原因： Kotlin语言中，单引号只能包裹字符，不能包裹字符串 Kotlin语言中，方法调用使用括号。仅在使用infix修饰的方法中可以省略括号。这里显然是一个正常调用方法。因此，我们修改为：1include(&quot;app&quot;) 接下来，修改根目录的build.gradle脚本，用同样的方式修改后缀，方法修改为括号调用，修改后的内容如下：1234567891011121314151617buildscript { repositories { google() jcenter() } dependencies { // 这里修改为括号调用即可 classpath(&quot;com.android.tools.build:gradle:3.0.1&quot;) }}allprojects { repositories { google() jcenter() }} 注意：在修改后缀名称的时候IDE会出现警告提示，这里可以忽略，选择continue即可。 由于我们手动修改了build.gradle脚本，为了保证工程可以使用这个脚本，需要在settings.gradle.kts中添加一行代码，让Gradle知道使用build.gradle.kts脚本构建。因此，最后的settings.gradle.kts代码如下：12include(&quot;app&quot;)rootProject.buildFileName = &quot;build.gradle.kts&quot; 最后一步，修改app模块build.gradle文件，这也是最复杂的一步，修改完后缀名后，你会看到整个脚本全部被红色标识错误： 别慌！还是一样的方式，这里我们先将这里的所有代码注释掉。在最上方逐一对应修改，apply plugin部分修改为:123plugins { id(&quot;com.android.application&quot;)} 接下来，修改android {}闭包部分。这里有两个小技巧，由于目前IDE的支持不是很完善，在输入的时候稍微等待一段时间，IDE会给出相应的提示。另外，如果没有提示，例如android {}闭包就没有任何提示，输入完成后展开右侧gradle面板，选择gradle/buid setup/init，双击执行： 在底部面板可以看到任务执行是否成功。注意，即使任务执行成功，脚本依然可能被红色标识，这是IDE支持不完善导致的，可以忽略。 修改完成后的内容如下：1234567891011121314151617181920android { compileSdkVersion(27) buildToolsVersion(&quot;27.0.2&quot;) defaultConfig { applicationId = &quot;com.youngfeng.kotlindsl&quot; minSdkVersion(15) targetSdkVersion(27) versionCode = 1 versionName = &quot;1.0&quot; testInstrumentationRunner = &quot;android.support.test.runner.AndroidJUnitRunner&quot; } buildTypes { getByName(&quot;release&quot;) { isMinifyEnabled = true proguardFiles(getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot;) } }} 注意：你在使用的过程中，依然可能会遇到无论如何都不生效的问题。这个时候别着急，使用./gradlew assembleDebug命令调试，查看终端找到错误原因。Windows用户去掉./执行即可。 最后的依赖部分，同样地，全部修改为括号调用即可。这里就不赘述了，文章的最后部分会提供操作视频，在使用过程中有任何问题可以打开操作视频参考，如果依然不能解决，可以在文章下方给我留言，我会在第一时间给你答复。修改后的内容如下：12345678dependencies { implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;)))) implementation(&quot;com.android.support:appcompat-v7:26.1.0&quot;) implementation(&quot;com.android.support.constraint:constraint-layout:1.0.2&quot;) testImplementation(&quot;junit:junit:4.12&quot;) androidTestImplementation(&quot;com.android.support.test:runner:1.0.1&quot;) androidTestImplementation(&quot;com.android.support.test.espresso:espresso-core:3.0.1&quot;)} 通过上面的步骤，从Groovy转换到Kotlin的步骤已经全部完成，你可以在终端输入./gradlew assembleDebug测试是否可以正常构建了： 统一依赖管理上面的步骤虽然完成了脚本的转换，但依赖的管理依然是混乱的，为了实现类似 Snake 工程的统一依赖管理，我们还需要做一些工作。 Gradle官方提供了使用 buildSrc 目录实现自定义任务和插件逻辑，这里我们可以使用它完成依赖的统一处理，一个完整的buildSrc目录结构如下： Deps类中，可以这样定义依赖结构：1234567891011121314151617181920212223object deps { object plugin { val gradle = &quot;com.android.tools.build:gradle:3.1.0-alpha09&quot; val kotlin = &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:1.2.21&quot; } object kotlin { val stdlibJre7 = &quot;org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.21&quot; } object android { object support { val compat = &quot;com.android.support:appcompat-v7:27.0.2&quot; val constraintLayout = &quot;com.android.support.constraint:constraint-layout:1.0.2&quot; } object test { val junit = &quot;junit:junit:4.12&quot; val runner = &quot;com.android.support.test:runner:1.0.1&quot; val espressoCore = &quot;com.android.support.test.espresso:espresso-core:3.0.1&quot; } }} 定义之后，我们就可以在脚本中直接引用了：123456789dependencies { implementation(fileTree(mapOf(&quot;dir&quot; to &quot;libs&quot;, &quot;include&quot; to listOf(&quot;*.jar&quot;)))) implementation(deps.kotlin.stdlibJre7) implementation(deps.android.support.compat) implementation(deps.android.support.constraintLayout) testImplementation(deps.android.test.junit) androidTestImplementation(deps.android.test.runner) androidTestImplementation(deps.android.test.espressoCore)} 是不是漂亮了许多？ 至此，整个转换过程就顺利完成了，为了保证转换的成功率，我推荐使用文章开头的实验室配置。如果版本过低，不保证可以转换成功。最新版本的kotlin-dsl会跟随最新版本的Gradle插件发布，因此一定要使用最新版本。另外，目前IDE对kts的支持依然不完善，即使正确的写法也会报错，这个一定要注意，不要被IDE欺骗了。 更详细的操作，请看视频教程腾讯视频：用Kotlin写Android Gradle脚本 一些建议虽然使用Kotlin语言写脚本是一件非常美妙的事情，但目前依然存在一些问题： IDE支持不完善 kotlin-dsl 正在快速开发中，语法变动较大 缺少官方文档 互联网上缺少相关资料，遇到问题很难追踪 因此，目前我并不推荐你在生产环境中使用，但可以作为日常学习练手之用。预计1.0版本的发布在今年6月份左右，正式版本发布后，我推荐你立即将Gradle脚本转换到Kotlin语言。 遇到问题，看这里 ==&gt;在使用的过程中，按照文章同样的步骤，你依然可能会遇到很多问题。因此，我为你整理了目前互联网上可以参考的资料，你可以收藏这篇文章。遇到问题别慌，来这里查找答案。 关于kotlin-dsl的开发路线图，请看这篇文章：https://blog.gradle.org/kotlin-scripting-update 如果你在使用过程中，遇到了任何问题，并且确定是 kotlin-dsl 的bug，请点这里：https://github.com/gradle/kotlin-dsl 并推送 issue 如果你遇到了知识盲点，并且在Google找不到答案。可以来 Slack#gradle频道反馈，我在 Slack 的昵称是Scott Smith，也欢迎你给我发送私信消息。 本篇文章例子完整代码，请点击这里：https://github.com/yuanhoujun/gradle-script-kotlin-example kts文档正在编写当中，具体进度，请点这里：https://github.com/gradle/kotlin-dsl-docs 欢迎加入Kotlin交流群如果你也喜欢Kotlin语言，欢迎加入我的Kotlin交流群： 329673958 ，一起来参与Kotlin语言的推广工作。","link":"/2018/01/26/kotlin/用Kotlin写Android-Gradle脚本/"},{"title":"那些年，我们看不懂的那些Kotlin标准函数","text":"Kotlin标准库中提供了一套用于常用操作的函数。最近，在我的Kotlin交流群中有人再次问到了关于这些函数的用法。今天，让我们花一点时间，一起看一下这些函数的用法。 Ready go &gt;&gt;&gt;注：这里所说的标准函数主要来自于标准库中在文件Standard.kt中的所有函数。 run#11234567@kotlin.internal.InlineOnlypublic inline fun &lt;R&gt; run(block: () -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block()} contract部分主要用于编译器上下文推断，这里我们忽略掉这部分代码。 观察源码发现，run方法仅仅是执行传入的block表达式并返回执行结果而已（block是一个lambda表达式）。 因此，如果你仅仅需要执行一个代码块，可以使用该函数 看一个例子： 123456789val x = run { println(&quot;Hello, world&quot;) return@run 1 }println(x)// 执行结果Hello，world1 run#21234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block()} 这个函数跟上面的函数功能是完全一样的。不同的是，block的receiver是当前调用对象，即在block中可以使用当前对象的上下文。 因此，如果你需要在执行的lambda表达式中使用当前对象的上下文的话，可以使用该函数。除此之外，两者没有任何差别 看一个例子： 1234567891011121314151617181920212223class A { fun sayHi(name: String) { println(&quot;Hello, $name&quot;) }}class B {}fun main(args: Array&lt;String&gt;) { val a = A() val b = a.run { // 这里你可以使用A的上下文 a.sayHi(&quot;Scott Smith&quot;) return@run B() } println(b)}// 执行结果Hello，Scott Smithb@2314 从例子中，我们可以看到，这个函数还可以用于对数据类型进行转换。 with1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return receiver.block()} 这个函数其实和run函数也是做了一样的事情。不同的是，这里可以指定block的接收者。 因此，如果你在执行lambda表达式的时候，希望指定不同的接收者的话，可以使用该方法 1234567891011121314class A { fun sayHi(name: String) { println(&quot;Hello, $name&quot;) }}fun main(args: Array&lt;String&gt;) { val a = A() with(a) { // 这里的接收者是对象a，因此可以调用a实例的所有方法 sayHi(&quot;Scott Smith&quot;) }} apply12345678@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block() return this} 可以看到，这个方法是针对泛型参数的扩展方法，即所有对象都将拥有该扩展方法。相对于run#2方法，apply不仅执行了block，同时还返回了receiver本身。 这在链式编程中很常用，如果你希望执行lambda表达式的同时而不破坏链式编程，可以使用该方法 看一个例子： 1234567891011121314151617181920212223class A { fun sayHi(name: String) { println(&quot;Hello, $name&quot;) } fun other() { println(&quot;Other function...&quot;) }}fun main(args: Array&lt;String&gt;) { val a = A() a.apply { println(&quot;This is a block&quot;) sayHi(&quot;Scott Smith&quot;) }.other()}// 执行结果This is a blockHello, Scott SmithOther function... also123456789@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.also(block: (T) -&gt; Unit): T { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } block(this) return this} 这个函数跟with又很像，不同的是，block带有一个当前receiver类型的参数。在block中，你可以使用该参数对当前实例进行操作。 这个函数和with完全可以互相通用，with函数可以直接在当前实例上下文中对其进行操作，而also函数要通过block参数获取当前类实例。因为用法完全一致，这里就不举例了 let1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R { contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) } return block(this)} 如果你使用过RxJava，可能会感到似曾相识，这其实就是RxJava的map函数。这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展函数。 如果你希望对当前数据类型进行一定的转换，可以使用该方法。该方法的block中同样可以使用当前receiver的上下文 看一个例子： 12345678910111213141516class Triangle {}class Rectangle {}fun main(args: Array&lt;String&gt;) { val tr = Triangle() val rect = tr.let { it -&gt; println(&quot;It is $it&quot;) return@let Rectangle() } println(rect)}// 执行结果It is Triangle@78308db1Rectangle@27c170f0 从例子中可以看到，我们成功地将三角形转换成了矩形，这就是let函数的作用。 takeIf12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeIf(predicate: (T) -&gt; Boolean): T? { contract { callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) } return if (predicate(this)) this else null} 这个函数也是针对泛型参数的扩展函数，所有类都将拥有这个扩展。这个函数使用了一个预言函数作为参数，主要用于判断当前对象是否符合条件。这个条件函数由你指定。如果条件符合，将返回当前对象。否则返回空值。 因此，如果你希望筛选集合中某个数据是否符合要求，可以使用这个函数 看一个例子： 1234567891011fun main(args: Array&lt;String&gt;) { val arr = listOf(1, 2, 3) arr.forEach { println(&quot;$it % 2 == 0 =&gt; ${it.takeIf { it % 2 == 0 }}&quot;) }}// 执行结果1 % 2 == 0 =&gt; null2 % 2 == 0 =&gt; 23 % 2 == 0 =&gt; null takeUnless12345678@kotlin.internal.InlineOnly@SinceKotlin(&quot;1.1&quot;)public inline fun &lt;T&gt; T.takeUnless(predicate: (T) -&gt; Boolean): T? { contract { callsInPlace(predicate, InvocationKind.EXACTLY_ONCE) } return if (!predicate(this)) this else null} 这个函数刚好与takeIf筛选逻辑恰好相反。即：如果符合条件返回null，不符合条件返回对象本身。 看一个例子： 1234567891011fun main(args: Array&lt;String&gt;) { val arr = listOf(1, 2, 3) arr.forEach { println(&quot;$it % 2 == 0 =&gt; ${it.takeUnless { it % 2 == 0 }}&quot;) }}// 执行结果1 % 2 == 0 =&gt; 12 % 2 == 0 =&gt; null3 % 2 == 0 =&gt; 3 看到了吗？这里的执行结果和takeIf恰好相反。 repeat12345678@kotlin.internal.InlineOnlypublic inline fun repeat(times: Int, action: (Int) -&gt; Unit) { contract { callsInPlace(action) } for (index in 0 until times) { action(index) }} 这个函数意思很明显，就是将一个动作重复指定的次数。动作对应一个lambda表达式，表达式中持有一个参数表示当前正在执行的次数索引。 看一个例子： 123456789fun main(args: Array&lt;String&gt;) { repeat(3) { println(&quot;Just repeat, index: $it&quot;) }}Just repeat, index: 0Just repeat, index: 1Just repeat, index: 2 简单总结最后，我们用一个表格简单总结一下这些函数的用法：函数|用途|特点|形式:—:|:—:|:—:|:—:run#1|执行block，并返回执行结果|block中无法获取接收者上下文|全局函数run#2|执行block，并返回执行结果|block中可以获取接收者上下文|扩展函数with|指定接收者，通过接收者执行block|block中可以获取接收者的上下文，可以对接收者数据类型做一定转换|全局函数apply|执行block，并返回接收者实例本身|block中可以获取接收者的上下文，可用于链式编程|扩展also|执行block，并返回接收者实例本身|block中有一个参数代表接收者实例，可用于链式编程|扩展let|执行block，并返回执行结果|block中有一个参数代表接收者实例，可以对接收者数据类型做一定转换|扩展takeIf|根据条件predicate判断当前实例是否符合要求|如果符合要求，返回当前实例本身；否则返回null|扩展函数takeUnless|根据条件predicate判断当前实例是否不符合要求|如果不符合要求，返回当前实例本身；否则返回null|扩展 搞定Receiver理解上面这几个函数，最重要的一点是要理解Receiver。遗憾的是，Kotlin官方文档中并没有针对Receiver的详细讲解。关于这部分的讲解，请扫描下方二维码关注欧阳锋工作室，回复搞定Receiver查看文章。 欢迎加入Kotlin交流群关于Kotlin，如果你有任何问题，欢迎加入我的Kotlin交流群： 329673958。当前群交流活跃，问题解答速度很快，期待你的加入。","link":"/2018/04/27/kotlin/那些年，我们看不懂的那些Kotlin标准函数/"},{"title":"记一次印象深刻的Bug追踪过程","text":"问题现象：使用安卓手机以小程序的形式分享产品到微信，使用微信打开，产品详情数据无法显示。而使用iPhone分享到微信，却始终可以正常打开，这个时候所有的矛头都指向了安卓同学。 逻辑设计说明：这里的分享数据来自H5接口，通过addJavascriptInterface自定义接口完成H5和Java端的数据传递，产品ID来自后台接口获取。 这个时候，安卓同学首先做出了响应，通过调试拿到了JS端的数据，以下是这位小陈同学的截图消息： 小陈同学这个时候把问题抛给了Web前端同学小徐，以为小徐传递了科学计数法的ID字符串。 大家看小陈同学的截图，图中的ID是使用字符串接收的，这个时候我已经完全排除问题出现在安卓端的可能性了。于是，我问小徐，H5有对参数进行处理吗？得到的答案如下： 大家看到图中，我已经给出了确定的答案，认为问题来自于后台。因为，后台同学之前的确出现过对ID进行toInt处理最终转换为负数的情况。现在在传递时出现这种低级错误的概率应该也挺高的。这段话抛出去之后，团队炸开了锅，有同学认为大家在互相推诿… 其实，还有很长的截图，这里没有展示出来。群里提到最多的一句话就是：iOS没问题啊。就连我们的运维同学以及UI设计同学都加入了“讨伐”队伍，种种迹象似乎都指向了安卓同学。这个时候，我们的安卓同学真是“哑巴吃黄连，有苦说不出”，心里的潜台词肯定是：我TM的就用string接收了一下，我招谁惹谁了我！ 但其实出现这种不知所踪的情况，完全可以理解，大家大都集中在单一平台开发，对于其它环节的理解难免有偏差。其实，用常识来理解这个问题的话，的确后台的概率比较大，前端同学对ID进行运算处理的概率几乎为0，这一点即使是刚刚入行的新手也不太可能。而我一直苦等的后台同学却迟迟没有响应，我目前始终无法确定问题到底来自于后台还是Web前端。直到我终于看到了下面的截图。 这个时候，我终于有九成的把握确定问题来自于Web前端了。可是，我知道我不能明说。前端同学已经在聊天记录中给出了证据，在Chrome的控制台打印出了正常的id值，到了安卓端却出现了异常。前端同学这个时候心里也有了一个定性结论，问题来自安卓端。这个时候，我只能亲自上场，而恰好我在外面，正在办理深圳户口，比较不便。于是，我微信给小陈发消息，嘱咐它把详情页的源码“爬”下来，我回来看看源码。 回到家的时候，我问小陈html源码是否已经“爬”了下来，他给我发来截图，我意识到前端使用了https协议，没法获取html源码。于是，我想了一个办法，在源码中嵌入一段代码，通过代码的形式获取WebView产品详情页的数据。这个方法果然奏效，不一会儿，小陈就发来了页面的html源码。 哎哟，我的天哪！混淆后的代码简直不堪入目，不过还好，我可以搜索方法关键字showShareView。可是，很遗憾没有搜索到，事件的绑定被放到了JS代码中。在这段源码中，我注意到一个文件名已经被混淆的JS文件，我猜想代码应该就在这里。可是，怎样抓到具体的方法呢？ 灵机一动！我之前在代码中让小陈把Debug权限开发给了H5，这次正好可以派上用场。可是，对于混淆后的代码，我心里依然有点打退堂鼓。 连上手机，在Chrome浏览器中输入chrome://inpsect，点击相应链接，非常顺利地进入了调试界面： 在控制台的Source中，我通过关键词搜索找到了混淆后的JS代码片段，在方法名前面增加了一个断点，等调试到底方法位置的时候。这个时候已经获取到了JS的上下文，直接通过this.gid打印出了当前产品ID信息，居然是一个非常正常的整型数字。大家注意，这已经是一个在安卓端出问题的产品了，在JS端居然显示是正常的。这个时候，我的大脑非常转动，我的第一感觉应该是webkit内核看到接收的字符串全是数字做了”自以为是“的转换。于是，我给出了团队如下的答案： 为了进一步确定我的猜想，我让小陈写了一个简单的Demo，通过JS接口传递一个非常大的数字字符串给Java端，看接收是否异常。不一会儿，我就得到了答案： 至此，我终于基本确定问题的原因了！猜测：JS在传递数据给安卓端的时候，应该是使用了基本数据类型。而webkit内核在处理的时候可能是以JS端数据类型为准，在传递到Java端时候做了转换。 为了验证这个猜想，我使用typeof打印id的数据类型，得到了如下结果： 于是，我告诉小徐，问题来自于你没有传递正确的数据类型给安卓端。其实这是比较危险的，不同CPU可以容纳的最大整型值是不一样的。如果iOS端和安卓处理一致，也是以JS端数据类型为准，只不过iOS的CPU字节宽度较大，恰好在iPhone高端机型上面没有出现而低端机型出现的话。其实问题依然存在，而如果iOS的确是以Native端数据类型为准。这就根本不是一个问题。但答案虽然给了团队，可是小徐仍然一脸狐疑，没有经验的CTO也是跟着一脸狐疑，加上解决问题的时间较长。小徐在发布更新的时候也遇到了问题，导致更新失败，问题持续，整个问题一直在持续。 这个时候，我告诉小徐，你发布更新后先别着急，确定更新成功后再告诉团队小伙伴。 一直到确定更新成功，我们再次尝试分享，问题终于引刃而解！ 问题虽然解决了，可是，安卓系统为什么要这样处理呢？为什么不能以Native端数据类型为准呢？带着这个疑问，我开始查看安卓源码。 阅读安卓源码是一个痛苦的过程，随着系统版本的升级，安卓系统的兼容性代码越来越多，这给阅读带来了极大的困难。加上安卓系统本身源码量巨大，阅读源码就像在一个巨大的森林中寻找宝藏一样。这个时候，其实你非常容易迷路，而我知道，只要我坚信我想要什么，就一定可以找到。 这里我们以addJavascriptInterface这个方法作为突破口，进入源码：1234public void addJavascriptInterface(Object object, String name) { checkThread(); mProvider.addJavascriptInterface(object, name); } 额，mProvider是什么鬼？难道WebView只是一个傀儡，真正处理业务的其实是mProvider？是的，没错！WebView只不过是一个壳而已！可是，mProvider的实现到底是什么呢？带着这个疑问，我们看到了如下mProvider实例创建的方法：123456789101112private void ensureProviderCreated() { checkThread(); if (mProvider == null) { // As this can get called during the base class constructor chain, pass the minimum // number of dependencies here; the rest are deferred to init(). mProvider = getFactory().createWebView(this, new PrivateAccess()); } } private static WebViewFactoryProvider getFactory() { return WebViewFactory.getProvider(); } 又出现了一个工厂方法，别怕，继续往下追踪：getProvider方法较长，我们截取部分，看下面源码：123456789101112131415161718192021222324252627static WebViewFactoryProvider getProvider() { synchronized (sProviderLock) { // For now the main purpose of this function (and the factory abstraction) is to keep // us honest and minimize usage of WebView internals when binding the proxy. if (sProviderInstance != null) return sProviderInstance; final int uid = android.os.Process.myUid(); if (uid == android.os.Process.ROOT_UID || uid == android.os.Process.SYSTEM_UID || uid == android.os.Process.PHONE_UID || uid == android.os.Process.NFC_UID || uid == android.os.Process.BLUETOOTH_UID) { throw new UnsupportedOperationException( &quot;For security reasons, WebView is not allowed in privileged processes&quot;); } StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskReads(); Trace.traceBegin(Trace.TRACE_TAG_WEBVIEW, &quot;WebViewFactory.getProvider()&quot;); try { Class&lt;WebViewFactoryProvider&gt; providerClass = getProviderClass(); Method staticFactory = null; try { staticFactory = providerClass.getMethod( CHROMIUM_WEBVIEW_FACTORY_METHOD, WebViewDelegate.class); } catch (Exception e) { if (DEBUG) { Log.w(LOGTAG, &quot;error instantiating provider with static factory method&quot;, e); } } 这里的单用户检测，安全调用之类的代码就先忽略了。集中注意力看Provider实例创建的代码，大家可以看到，这里的创建其实通过反射调用创建的。这里有一个关键的方法getProviderClass()，这个方法可能获取到真正的Provider类对象，跟踪这个方法调用，我们看到了如下的调用过程：getProviderClass() -&gt; getWebViewProviderClass 12345public static Class&lt;WebViewFactoryProvider&gt; getWebViewProviderClass(ClassLoader clazzLoader) throws ClassNotFoundException { return (Class&lt;WebViewFactoryProvider&gt;) Class.forName(CHROMIUM_WEBVIEW_FACTORY, true, clazzLoader); } 看到了吗？CHROMIUM_WEBVIEW_FACTORY 这才是真正的WebViewFactoryProvider类声明，跟进这个常量：1private static final String CHROMIUM_WEBVIEW_FACTORY = &quot;com.android.webview.chromium.WebViewChromiumFactoryProviderForO&quot;; 从命名ForO来看，这个类恰好是用于最新版本Android系统Oreo的。没错，这里我们就从最新版本的源码入手，找到真正的问题”元凶“。 可是，这个代码在哪里呢？你搜索安卓源码，根本搜索不到该类，这是为什么呢？也许你已经猜到了，其实这段代码就来自于Chrome核心工程 chromium。这段代码，大家通过谷歌搜索找找看，这里我们以官方版本的代码为准：WebViewChromiumFactoryProviderForO 具体代码很简单，如下：123456789package com.android.webview.chromium;class WebViewChromiumFactoryProviderForO extends WebViewChromiumFactoryProvider { public static WebViewChromiumFactoryProvider create(android.webkit.WebViewDelegate delegate) { return new WebViewChromiumFactoryProviderForO(delegate); } protected WebViewChromiumFactoryProviderForO(android.webkit.WebViewDelegate delegate) { super(delegate); }} LOL，可是，你以为真的很简单吗？其实不然，实现在父类，跟进父类。这个时候千万保持清醒，别跟丢了哦。我们想要的是Provider的创建过程，这个是Provider工厂类的真正类型，由它完成WebViewProvider的创建。 如果你已经忘了，我们再来回顾一下刚刚创建WebViewProvider的代码，别走神，看这里：12345678private void ensureProviderCreated() { checkThread(); if (mProvider == null) { // As this can get called during the base class constructor chain, pass the minimum // number of dependencies here; the rest are deferred to init(). mProvider = getFactory().createWebView(this, new PrivateAccess()); } } 看到了吗？这里拿到工厂类之后，调用了createWebView方法创建了Provider对象。那好办了，我们在WebViewChromiumFactoryProviderForO的父类WebViewChromiumFactoryProvider直接搜索createWebView方法即可。1234@Override public WebViewProvider createWebView(WebView webView, WebView.PrivateAccess privateAccess) { return new WebViewChromium(this, webView, privateAccess, mShouldDisableThreadChecking); } 怎么样，这段代码熟悉吗？这里直接返回了一个WebViewChromium对象，也就是说，WebView的所有操作，都由WebViewChromium帮忙完成。好吧，我们继续跟进这个类。可是跟进这个类做什么呢？哈哈，忘了吧，我们的目的是寻找addJavascriptInterface实现。稍等，容我先擦一把汗。 12345678910111213@Override public void addJavascriptInterface(final Object obj, final String interfaceName) { if (checkNeedsPost()) { mFactory.addTask(new Runnable() { @Override public void run() { addJavascriptInterface(obj, interfaceName); } }); return; } mAwContents.addJavascriptInterface(obj, interfaceName); } 稍微瞅一眼这个方法checkNeedsPost1234567protected boolean checkNeedsPost() { boolean needsPost = !mFactory.hasStarted() || !ThreadUtils.runningOnUiThread(); if (!needsPost &amp;&amp; mAwContents == null) { throw new IllegalStateException(&quot;AwContents must be created if we are not posting!&quot;); } return needsPost; } 简单理解一下，如果已经启动或者调用该方法的线程不在UI线程，则需要post到UI线程中去，这里很明显，我们的调用是在UI线程中。因此，我们之间走下面的分支: mAwContents.addJavascriptInterface(obj, interfaceName);。那么，问题来了，AwContent又是什么鬼？在哪里创建的呢？ 仔细查找这个类，我们发现AwContent是在initForReal方法中被创建的。而initForReal调用来自init方法。可是，init方法是在哪里调用的呢？答案是：WebView。看下面的截图： OK，继续往下，看AwContent是怎么创建的。1234567891011121314151617181920212223242526private void initForReal() { AwContentsStatics.setRecordFullDocument(sRecordWholeDocumentEnabledByApi || mAppTargetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP); mAwContents = new AwContents(mFactory.getBrowserContextOnUiThread(), mWebView, mContext, new InternalAccessAdapter(), new WebViewNativeDrawGLFunctorFactory(), mContentsClientAdapter, mWebSettings.getAwSettings(), new AwContents.DependencyFactory() { @Override public AutofillProvider createAutofillProvider( Context context, ViewGroup containerView) { return mFactory.createAutofillProvider(context, mWebView); } }); if (mAppTargetSdkVersion &gt;= Build.VERSION_CODES.KITKAT) { // On KK and above, favicons are automatically downloaded as the method // old apps use to enable that behavior is deprecated. AwContents.setShouldDownloadFavicons(); } if (mAppTargetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) { // Prior to Lollipop, JavaScript objects injected via addJavascriptInterface // were not inspectable. mAwContents.disableJavascriptInterfacesInspection(); } // TODO: This assumes AwContents ignores second Paint param. mAwContents.setLayerType(mWebView.getLayerType(), null); } 下面是一些版本兼容判断，与本文探讨主题无关，先忽略。好了，看到这里，大家是不是感觉被安卓源码忽悠的团团转，最开始我们天真地以为真正的调用来自WebView，安卓系统告诉我们来自WebViewProvider，我们以为这应该就是头了。可是现在又出现了一个AwContent。那么，它是不是真正的最终调用者呢？继续往下看：12345678910111213/** * @see ContentViewCore#addPossiblyUnsafeJavascriptInterface(Object, String, Class) */ @SuppressLint(&quot;NewApi&quot;) // JavascriptInterface requires API level 17. public void addJavascriptInterface(Object object, String name) { if (TRACE) Log.i(TAG, &quot;%s addJavascriptInterface=%s&quot;, this, name); if (isDestroyedOrNoOperation(WARN)) return; Class&lt;? extends Annotation&gt; requiredAnnotation = null; if (mAppTargetSdkVersion &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) { requiredAnnotation = JavascriptInterface.class; } mContentViewCore.addPossiblyUnsafeJavascriptInterface(object, name, requiredAnnotation); } 我擦，又来了一个调用对象mContentViewCore。Relax，继续往下看，看它的实现：12345678public void addPossiblyUnsafeJavascriptInterface(Object object, String name, Class&lt;? extends Annotation&gt; requiredAnnotation) { if (mNativeContentViewCore != 0 &amp;&amp; object != null) { mJavaScriptInterfaces.put(name, object); nativeAddJavascriptInterface(mNativeContentViewCore, object, name, requiredAnnotation, mRetainedJavaScriptObjects); }} 看方法名，nativeAddJavascriptInterface看起来最终调用来自于Native，继续往下看：12private native void nativeAddJavascriptInterface(int nativeContentViewCoreImpl, Object object, String name, Class requiredAnnotation, HashSet&lt;Object&gt; retainedObjectSet); 接下来看C++代码，这里的中间调用过程没有深究，但最终应该是来到了这里：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static void AddJavascriptInterface(JNIEnv *env, jobject obj, jint nativeFramePointer, jobject javascriptObj, jstring interfaceName){#ifdef ANDROID_INSTRUMENT TimeCounterAuto counter(TimeCounter::NativeCallbackTimeCounter);#endif WebCore::Frame* pFrame = 0; if (nativeFramePointer == 0) pFrame = GET_NATIVE_FRAME(env, obj); else pFrame = (WebCore::Frame*)nativeFramePointer; LOG_ASSERT(pFrame, &quot;nativeAddJavascriptInterface must take a valid frame pointer!&quot;); JavaVM* vm; env-&gt;GetJavaVM(&amp;vm); LOGV(&quot;::WebCore:: addJSInterface: %p&quot;, pFrame);#if USE(JSC) // Copied from qwebframe.cpp JSC::JSLock lock(false); WebCore::JSDOMWindow *window = WebCore::toJSDOMWindow(pFrame); if (window) { JSC::Bindings::RootObject *root = pFrame-&gt;script()-&gt;bindingRootObject(); JSC::Bindings::setJavaVM(vm); // Add the binding to JS environment JSC::ExecState* exec = window-&gt;globalExec(); JSC::JSObject *addedObject = WeakJavaInstance::create(javascriptObj, root)-&gt;createRuntimeObject(exec); const jchar* s = env-&gt;GetStringChars(interfaceName, NULL); if (s) { // Add the binding name to the window&apos;s table of child objects. JSC::PutPropertySlot slot; window-&gt;put(exec, JSC::Identifier(exec, (const UChar *)s, env-&gt;GetStringLength(interfaceName)), addedObject, slot); env-&gt;ReleaseStringChars(interfaceName, s); checkException(env); } }#endif // USE(JSC)#if USE(V8) if (pFrame) { const char* name = JSC::Bindings::getCharactersFromJStringInEnv(env, interfaceName); NPObject* obj = JSC::Bindings::JavaInstanceToNPObject(new JSC::Bindings::JavaInstance(javascriptObj)); pFrame-&gt;script()-&gt;bindToWindowObject(pFrame, name, obj); // JavaInstanceToNPObject calls NPN_RetainObject on the // returned one (see CreateV8ObjectForNPObject in V8NPObject.cpp). // BindToWindowObject also increases obj&apos;s ref count and decrease // the ref count when the object is not reachable from JavaScript // side. Code here must release the reference count increased by // JavaInstanceToNPObject. _NPN_ReleaseObject(obj); JSC::Bindings::releaseCharactersForJString(interfaceName, name); }#endif} 这里的代码量较大，我们主要关注下面这一行代码：12window-&gt;put(exec, JSC::Identifier(exec, (const UChar *)s, env-&gt;GetStringLength(interfaceName)), addedObject, slot); 最终数据的处理原来来自于C++端的window对象，这又是什么呢？继续看：1WebCore::JSDOMWindow *window = WebCore::toJSDOMWindow(pFrame); 这是在WebCore命名空间下面的JSDOMWindow对象，看到这里，其实大多数同学应该已经都没有兴趣看下去了。这实在是一个冗长的调用过程，而且在阅读源码过程中，我们还忽略多进程调用，忽略各种细节。对此，关于这段源码的阅读，我们暂且告一段落，等时间充裕，我再来补充。 总结这次的问题牵扯了移动端、Web前端和后台，这种跨平台的问题解决起来的确存在很大的困难。其实，我已经很长时间没有写JS了，仅仅在几个月前使用RN的时候有了解一些ES6的语法。凭借刚刚工作时仅有的2个月JS经验，加上在多方面知识的累积，总算顺利解决了问题。其实，根据我的经验来看，越是看起来无头绪的问题，往往越是一个极其简单的问题。为了避免出现这种问题，在编码过程中，必须小心翼翼。尽量多检查几次，避免出现类似这样的错误。另外，要尝试接受不一样的观点，如果你一开始就接受了其他人的观点，在解决问题上就会有很强的目的性，解决问题的速度也就更快。 最后，新的一年里，祝大家万事如意，阖家欢乐，工作顺顺利利，身体健健康康。","link":"/2018/01/02/bug fix/记一次印象深刻的Bug追踪过程/"},{"title":"Kotlin 操作符重载及中缀调用","text":"操作符重载其实很有意思！但这个概念却很少有人知道，使用操作符重载在某种程度上会给代码的阅读带来一定的麻烦。因此，慎用操作符被认为是一个好习惯。的确，操作符重载是一把双刃剑，既能削铁如泥，也能“引火烧身”，这篇文章将从实用的角度来讲解操作符重载的基本用法。 支持重载的操作符类型Kotlin语言支持重载的操作符类型比较多。以最新版本1.2.21为准，目前支持重载的操作符可以归纳为以下几类： 一元操作符一元前缀操作符 操作符 对应方法 +a a.unaryPlus() -a a.unaryMinus() !a a.not() 以上三个操作符在日常使用中频率很高，第一个操作符在基本运算中很少使用，第二个操作符就是常见的取反操作，第三个操作符是逻辑取反操作。接下来，我们使用扩展的方式重载这三个操作符：1234567891011121314151617181920212223242526272829303132333435363738394041/** * 一元操作符 * * @author Scott Smith 2018-02-03 14:11 */data class Number(var value: Int)/** * 重载一元操作符+，使其对Number中实际数据取绝对值 */operator fun Number.unaryPlus(): Number { this.value = Math.abs(value) return this}/** * 重载一元操作符-，使其对Number中实际数据取反 */operator fun Number.unaryMinus(): Number { this.value = -value return this}/** * 这个操作符通常是用于逻辑取反，这里用一个没有意义的操作，来模拟重载这个操作符 * 结果：始终返回Number中实际数据的负值 */operator fun Number.not(): Number { this.value = -Math.abs(value) return this}fun main(args: Array&lt;String&gt;) { val number = Number(-3) println(&quot;Number value = ${number.value}&quot;) println(&quot;After unaryPlus: Number value = ${(+number).value}&quot;) println(&quot;After unaryMinus: Number value = ${(-number).value}&quot;) number.value = Math.abs(number.value) println(&quot;After unaryNot: Number value = ${(!number).value}&quot;)} 运行上述代码，将得到如下结果：1234Number value = -3After unaryPlus: Number value = 3After unaryMinus: Number value = -3After unaryNot: Number value = -3 自增和自减操作符 操作符 对应方法 a++/++a a.inc() a–/–a a.dec() 重载这个操作符相对比较难理解，官方文档有一段简短的文字解释，翻译成代码可以这样表示：123456789101112// a++fun increment(a: Int): Int { val a0 = a a = a + 1 return a0}// ++afun increment(a: Int): Int { a = a + 1 return a} 看懂上面的代码后，我们换成需要重载的Number类，Kotlin最终会这样处理：1234567891011// Number++fun increment(number: Number): Number { val temp = number val result = number.inc() return result}// Number++fun increment(number: Number): Number { return number.inc()} 因此，重载Number类自加操作符，我们可以这样做：123operator fun Number.inc(): Number { return Number(this.value + 1)} 重载自减操作符同理，完整代码请参考我的Git版本库：kotlin-samples 二元操作符算术运算符 操作符 对应方法 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a..b a.rangeTo(b) 前5个操作符相对比较好理解，我们以a + b为例，举个一个简单的例子：12345678910// 重载Number类的加法运算符operator fun Number.plus(value: Int): Number { return Number(this.value + value)}fun main(args: Array&lt;String&gt;) { println((Number(1) + 2))}// 输出结果：Number value = 3 相对比较难理解的是第六个范围运算符，这个操作符主要用于生成一段数据范围。我们认为Number本身就代表一个整型数字，因此，重载Number是一件有意义的事情。直接看例子：123456789101112131415161718192021operator fun Number.rangeTo(to: Number): IntRange { return this.value..to.value}fun main(args: Array&lt;String&gt;) { val startNumber = Number(3) val endNumber = Number(9) (startNumber..endNumber).forEach { println(&quot;value = $it&quot;) }}// 运行结果：value = 3value = 4value = 5value = 6value = 7value = 8value = 9 “In”运算符 操作符 对应方法 a in b b.contains(a) a !in b !b.contains(a) 这个操作符相对比较好理解，重载这个操作符可以用于判断某个数据是否在另外一个对象中。我们用一个非常简单的自定义类来模拟集合操作：1234567891011121314151617class IntCollection { val intList = ArrayList&lt;Int&gt;()}// 重载&quot;in&quot;操作符operator fun IntCollection.contains(value: Int): Boolean { return this.intList.contains(value)}fun main(args: Array&lt;String&gt;) { val intCollection = IntCollection() intCollection.add(1, 2, 3) println(3 in intCollection)}// 输出结果：true 索引访问运算符 操作符 对应方法 a[i] a.get(i) a[i, j] a.get(i, j) a[i_1, …, i_n] a.get(i_1, …, i_n) a[i] = b a.set(i, b) a[i, j] = b a.set(i, j, b) a[i_1, …, i_n] = b a.set(i_1, …, i_n, b) 这个操作符很有意思，例如，如果你要访问Map中某个数据，通常是这样的map.get(&quot;key&quot;)，使用索引运算符你还可以这样操作：1val value = map[&quot;key&quot;] 我们继续以IntCollection类为例，尝试重写a[i]和a[i] = b两个运算符，其它运算符同理。123456789101112131415161718// 重载a[i]操作符operator fun IntCollection.get(index: Int): Int { return intList[index]}// 重载a[i] = b操作符operator fun IntCollection.set(index: Int, value: Int) { intList[index] = value}fun main(args: Array&lt;String&gt;) { val intCollection = IntCollection() intCollection.add(1, 2, 3) println(intCollection[0]) intCollection[2] = 4 print(intCollection[2])} 接下来，我们用索引运算符来做一点更有意思的事情！新建一个普通的Kotlin类User：1234class User(var name: String, var age: Int) {} 使用下面的方式重载索引运算符：1234567891011121314151617181920212223operator fun User.get(key: String): Any? { when(key) { &quot;name&quot; -&gt; { return this.name } &quot;age&quot; -&gt; { return this.age } } return null}operator fun User.set(key: String, value:Any?) { when(key) { &quot;name&quot; -&gt; { name = value as? String } &quot;age&quot; -&gt; { age = value as? Int } }} 接下来，你会神奇地发现，一个普通的Kotlin类居然也可以使用索引运算符对成员变量进行操作了，是不是很神奇？123456fun main(args: Array&lt;String&gt;) { val user = User(&quot;Scott Smith&quot;, 18) println(user[&quot;name&quot;]) user[&quot;age&quot;] = 22 println(user[&quot;age&quot;])} 因此，索引运算符不仅仅可以对集合类数据进行操作，对一个普通的Kotlin类也可以发挥同样的作用。如果你脑洞足够大，你还可以发现更多更神奇的玩法。 调用操作符 操作符 对应方法 a() a.invoke() a(i) a.invoke(i) a(i, j) a.invoke(i, j) a(i_1, ……, i_n) a.invoke(i_1, ……, i_n) 重载这个操作符并不难，理解它的应用场景却有一定的难度。为了理解它的应用场景，我们来举一个简单的例子：12345678910111213class JsonParser {}operator fun JsonParser.invoke(json: String): Map&lt;String, Any&gt; { val map = Json.parse(json) ... return map}// 可以这样调用val parser = JsonParser()val map = parser(&quot;{name: \\&quot;Scott Smith\\&quot;}&quot;) 这里的调用有点像省略了一个解析Json数据的方法，难道它仅仅就是这个作用吗？是的，调用操作符其实就这一个作用。如果一个Kotlin类仅仅只有一个方法，直接使用括号调用的确是一个不错的主意。不过，在使用的时候还是要稍微注意一下，避免出现歧义。 广义赋值操作符 操作符 对应方法 a += b a.plusAssign(b) a -= b a.minusAssign(b) a *= b a.timesAssign(b) a /= b a.divAssign(b) a %= b a.remAssign(b) 这个操作符相对比较好理解，我们以Number类为例，举一个简单的例子：12345678910111213// 广义赋值运算符operator fun Number.plusAssign(value: Int) { this.value += value}fun main(args: Array&lt;String&gt;) { val number = Number(1) number += 2 println(number)}// 输出结果：Number value = 3 相等与不等操作符 操作符 对应方法 a == b a?.equals(b) ?: (b === null) a != b !(a?.equals(b) ?: (b === null)) 重载这个操作符与Java重写equals方法是一样的。不过，这里要注意与Java的区别，在Java端==用于判断两个对象是否是同一对象（指针级别）。而在Kotlin语言中，如果我们不做任何处理，==等同于使用Java对象的equals方法判断两个对象是否相等。 另外，这里还有一种特殊情况，如果左值等于null，这个时候a?.equals(b)将返回null值。因此，这里还增加了?:运算符用于进一步判断，在这个情况下，当且仅当b === null的时候，a、b才有可能相等。因此，才有了上面的对应关系，这里以User类为例举一个简单的例子：12345678910class User(var name: String?, var age: Int?) { operator override fun equals(other: Any?): Boolean { if(other is User) { return (this.name == other.name) &amp;&amp; (this.age == other.age) } return false }} 注意：这里有一个特殊的地方，与其它操作符不一样的地方是，如果使用扩展的方式尝试重载该操作符，将会报错。因此，如果要重载该操作符，一定要在类中进行重写。 比较操作符 操作符 对应方法 a &gt; b a.compareTo(b) &gt; 0 a &lt; b a.compareTo(b) &lt; 0 a &gt;= b a.compareTo(b) &gt;= 0 a &lt;= b a.compareTo(b) &lt;= 0 比较操作符是一个在日常使用中频率非常高的操作符，重载这个操作符只需要掌握以上表格中几个规则即可。我们以Number类为例举一个简单的例子：123operator fun Number.compareTo(number: Number): Int { return this.value - number.value} 属性委托操作符属性委托操作符是一种非常特殊的操作符，其主要用在代理属性中。关于Kotlin代理的知识，如果你还不了解的话，请参考这篇文章 Delegation。这篇文章介绍的相对简略，后面会出一篇更详细的文章介绍代理相关的知识。 中缀调用看到这里，可能有一些追求更高级玩法的同学会问：Kotlin支持自定义操作符吗？ 答案当然是：不能！不过，别失望，infix也许适合你，它其实可以看做一种自定义操作符的实现。这里我们对集合List新增一个扩展方法intersection用于获取两个集合的交集：1234567891011// 获取两个集合的交集fun &lt;E&gt; List&lt;E&gt;.interSection(other: List&lt;E&gt;): List&lt;E&gt; { val result = ArrayList&lt;E&gt;() forEach { if(other.contains(it)) { result.add(it) } } return result} 接下来，我们就可以在List及其子类中使用点语法调用了。但，它看起来仍然不像一个操作符。为了让它更像一个操作符，我们继续做点事情： 添加infix关键词 将函数名修改为∩（这是数学上获取交集的标记符号）然而，万万没想到，修改完成后居然报错了。Kotlin并不允许直接使用特殊符号作为函数名开头。因此，我们取形近的字母n用于表示函数名：1234567891011// 获取两个集合的交集infix fun &lt;E&gt; List&lt;E&gt;.n(other: List&lt;E&gt;): List&lt;E&gt; { val result = ArrayList&lt;E&gt;() forEach { if(other.contains(it)) { result.add(it) } } return result} 接下来，我们就可以这样调用了val interSection = list1 n list2，怎么样？是不是很像自定义了一个获取交集的操作符n？如果你希望自定义操作符，可以尝试这么做。 其实infix的应用场景还不止这些，接下来，我们再用它完成一件更有意思的事情。 在实际项目开发中，数据库数据到对象的处理是一件繁琐的过程，最麻烦的地方莫过于思维的转换。那我们是否可以在代码中直接使用SQL语句查询对象数据呢？例如这样：1val users = Select * from User where age &gt; 18 纸上学来终觉浅，觉知此事需躬行。有了这个idea，接下来，我们就朝着这个目标努力。一、先声明一个Sql类，准备如下方法：1234567infix fun select(columnBuilder: ColumnBuilder): Sql {infix fun from(entityClass: Class&lt;*&gt;): Sql infix fun where(condition: String): Sql fun &lt;T&gt; query(): T 二、我们的目的是：最终转换到SQL语句形式。因此，增加如下实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class ColumnBuilder(var columns: Array&lt;out String&gt;) {}class Sql private constructor() { var columns = emptyList&lt;String&gt;() var entityClass: Class&lt;*&gt;? = null var condition: String? = null companion object { fun get(): Sql { return Sql() } } infix fun select(columnBuilder: ColumnBuilder): Sql { this.columns = columnBuilder.columns.asList() return this } infix fun from(entityClass: Class&lt;*&gt;): Sql { this.entityClass = entityClass return this } infix fun where(condition: String): Sql { this.condition = condition return this } fun &lt;T&gt; query(): T { // 此处省略所有条件判断 val sqlBuilder = StringBuilder(&quot;select &quot;) val columnBuilder = StringBuilder(&quot;&quot;) if(columns.size == 1 &amp;&amp; columns[0] == &quot;*&quot;) { columnBuilder.append(&quot;*&quot;) } else { columns.forEach { columnBuilder.append(it).append(&quot;,&quot;) } columnBuilder.delete(columns.size - 1, columns.size) } val sql = sqlBuilder.append(columnBuilder.toString()) .append(&quot; from ${entityClass?.simpleName} where &quot;) .append(condition) .toString() println(&quot;执行SQL查询：$sql&quot;) return execute(sql) } private fun &lt;T&gt; execute(sql: String): T { // 仅仅用于测试 return Any() as T }} 三、为了看起来更形似，再增加如下两个方法：123456789// 使其看起来像在数据库作用域中执行fun database(init: Sql.()-&gt;Unit) { init.invoke(Sql.get())}// 因为infix限制，参数不能直接使用可变参数。因此，我们增加这个方法使参数组装看起来更自然fun columns(vararg columns: String): ColumnBuilder { return ColumnBuilder(columns)} 接下来，就是见证奇迹的时刻！12345678fun main(args: Array&lt;String&gt;) { database { (select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot;).query() }}// 输出结果：执行SQL查询：select * from User where age &gt; 18 为了方便大家查看，我们提取完整执行代码段与SQL语句对比：12select * from User where age &gt; 18select (columns(&quot;*&quot;)) from User::class.java where &quot;age &gt; 18&quot; 神奇吗？至此，我们就可以直接在代码中愉快地使用类似SQL语句的方式进行方法调用了。 总结本篇文章从操作符重载实用的角度讲解了操作符重载的所有相关知识。如文章开头所说，操作符重载是一把双刃剑。用得好事半功倍，用不好事倍功半。因此，我给大家的建议是：使用的时候一定要保证能够自圆其说，简单来说，就是自然。我认为相对于古老的语言C++来说，Kotlin语言操作符重载的设计是非常棒的。如果你知道自己在做什么，我非常推荐你在生产环境中使用操作符重载来简化操作。 本篇文章例子代码点这里：kotlin-samples 我是欧阳锋，一个热爱Kotlin语言编程的学生。如果你喜欢我的文章，请在文章下方留下你爱的印记。如果你不喜欢我的文章，请先喜欢上我的文章。然后再留下爱的印记！ 下次文章再见，拜拜！","link":"/2018/02/06/kotlin/操作符重载及中缀调用/"},{"title":"10分钟看懂动态代理设计模式","text":"动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。 什么是代理从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。 是的，你没有看错，代理就是这么简单！ 理解了代理的意思，你脑海中恐怕还有两个巨大的疑问： 怎么实现代理模式 代理模式有什么实际用途 要理解这两个问题，看一个简单的例子：12345678910111213141516public interface Flyable { void fly();}public class Bird implements Flyable { @Override public void fly() { System.out.println(&quot;Bird is flying...&quot;); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } }} 很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？ 有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。123456789101112@Override public void fly() { long start = System.currentTimeMillis(); System.out.println(&quot;Bird is flying...&quot;); try { Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); } 的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？ 一定会有人说，我可以在调用的地方这样写：1234567public static void main(String[] args) { Bird bird = new Bird(); long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start));} 这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？ a）使用继承继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：123456789101112public class Bird2 extends Bird { @Override public void fly() { long start = System.currentTimeMillis(); super.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); }} 这是一种解决方案，还有一种解决方案叫做：聚合，其实也是比较容易想到的。我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：1234567891011121314151617public class Bird3 implements Flyable { private Bird bird; public Bird3(Bird bird) { this.bird = bird; } @Override public void fly() { long start = System.currentTimeMillis(); bird.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); }} 为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！ 继续深入思考，用问题推导来解答这个问题： 问题一：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。 问题二：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。 问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 聚合 是否可以避免这个问题呢？答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable 1234567891011121314151617public class Bird3 implements Flyable { private Flyable flyable; public Bird3(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { long start = System.currentTimeMillis(); flyable.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); }} 为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志： 12345678910111213141516public class BirdLogProxy implements Flyable { private Flyable flyable; public BirdLogProxy(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { System.out.println(&quot;Bird fly start...&quot;); flyable.fly(); System.out.println(&quot;Bird fly end...&quot;); }} 接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做： 1234567public static void main(String[] args) { Bird bird = new Bird(); BirdLogProxy p1 = new BirdLogProxy(bird); BirdTimeProxy p2 = new BirdTimeProxy(p1); p2.fly();} 反过来，可以这么做： 1234567public static void main(String[] args) { Bird bird = new Bird(); BirdTimeProxy p2 = new BirdTimeProxy(bird); BirdLogProxy p1 = new BirdLogProxy(p2); p1.fly();} 看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 聚合 可以做到，而继承不行呢。我们用一张图来解释一下： 静态代理接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。 从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题： 如果同时代理多个类，依然会导致类无限制扩展 如果类中有多个方法，同样的逻辑需要反复实现 那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：动态代理。 动态代理继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。 这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么： 动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 JavaPoet 这个第三方库帮我们生成TimeProxy的源码。希望 JavaPoet 不要成为你的负担，不理解 JavaPoet 没有关系，你只要把它当成一个Java源码生成工具使用即可。 PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。 第一步：生成TimeProxy源码12345678910111213141516171819202122232425262728293031323334353637383940public class Proxy { public static Object newProxyInstance() throws IOException { TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;) .addSuperinterface(Flyable.class); FieldSpec fieldSpec = FieldSpec.builder(Flyable.class, &quot;flyable&quot;, Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(Flyable.class, &quot;flyable&quot;) .addStatement(&quot;this.flyable = flyable&quot;) .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = Flyable.class.getDeclaredMethods(); for (Method method : methods) { MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addStatement(&quot;long start = $T.currentTimeMillis()&quot;, System.class) .addCode(&quot;\\n&quot;) .addStatement(&quot;this.flyable.&quot; + method.getName() + &quot;()&quot;) .addCode(&quot;\\n&quot;) .addStatement(&quot;long end = $T.currentTimeMillis()&quot;, System.class) .addStatement(&quot;$T.out.println(\\&quot;Fly Time =\\&quot; + (end - start))&quot;, System.class) .build(); typeSpecBuilder.addMethod(methodSpec); } JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 javaFile.writeTo(new File(&quot;/Users/ouyangfeng/Desktop/&quot;)); return null; }} 在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下： 12345678910111213141516171819202122package com.youngfeng.proxy;import java.lang.Override;import java.lang.System;class TimeProxy implements Flyable { private Flyable flyable; public TimeProxy(Flyable flyable) { this.flyable = flyable; } @Override public void fly() { long start = System.currentTimeMillis(); this.flyable.fly(); long end = System.currentTimeMillis(); System.out.println(&quot;Fly Time =&quot; + (end - start)); }} 第二步：编译TimeProxy源码编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作： 1234567891011public class JavaCompiler { public static void compile(File javaFile) throws IOException { javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler(); StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null); Iterable iterable = fileManager.getJavaFileObjects(javaFile); javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable); task.call(); fileManager.close(); }} 在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成： 123456// 为了看的更清楚，我将源码文件生成到桌面String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;;javaFile.writeTo(new File(sourcePath));// 编译JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;)); 第三步：加载到内存中并创建对象123456URL[] urls = new URL[] {new URL(&quot;file:/&quot; + sourcePath)};URLClassLoader classLoader = new URLClassLoader(urls);Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;);Constructor constructor = clazz.getConstructor(Flyable.class);Flyable flyable = (Flyable) constructor.newInstance(new Bird());flyable.fly(); 通过以上三个步骤，我们至少解决了下面两个问题： 不再需要手动创建TimeProxy 可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间 可是，说好的任意对象呢？ 第四步：增加InvocationHandler接口查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入： 接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！ 为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增InvocationHandler接口，用于处理自定义逻辑： 123public interface InvocationHandler { void invoke(Object proxy, Method method, Object[] args);} 想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）： proxy =&gt; 这个参数指定动态生成的代理类，这里是TimeProxy method =&gt; 这个参数表示传入接口中的所有Method对象 args =&gt; 这个参数对应当前method方法中的参数 引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样： 12345MyInvocationHandler handler = new MyInvocationHandler();Flyable proxy = Proxy.newProxyInstance(Flyable.class, handler);proxy.fly();方法执行流：proxy.fly() =&gt; handler.invoke() 为此，我们需要在Proxy.newProxyInstance()方法中做如下改动： 在newProxyInstance方法中传入InvocationHandler 在生成的代理类中增加成员变量handler 在生成的代理类方法中，调用invoke方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 public static Object newProxyInstance(Class inf, InvocationHandler handler) throws Exception { TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(&quot;TimeProxy&quot;) .addModifiers(Modifier.PUBLIC) .addSuperinterface(inf); FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, &quot;handler&quot;, Modifier.PRIVATE).build(); typeSpecBuilder.addField(fieldSpec); MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(InvocationHandler.class, &quot;handler&quot;) .addStatement(&quot;this.handler = handler&quot;) .build(); typeSpecBuilder.addMethod(constructorMethodSpec); Method[] methods = inf.getDeclaredMethods(); for (Method method : methods) { MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName()) .addModifiers(Modifier.PUBLIC) .addAnnotation(Override.class) .returns(method.getReturnType()) .addCode(&quot;try {\\n&quot;) .addStatement(&quot;\\t$T method = &quot; + inf.getName() + &quot;.class.getMethod(\\&quot;&quot; + method.getName() + &quot;\\&quot;)&quot;, Method.class) // 为了简单起见，这里参数直接写死为空 .addStatement(&quot;\\tthis.handler.invoke(this, method, null)&quot;) .addCode(&quot;} catch(Exception e) {\\n&quot;) .addCode(&quot;\\te.printStackTrace();\\n&quot;) .addCode(&quot;}\\n&quot;) .build(); typeSpecBuilder.addMethod(methodSpec); } JavaFile javaFile = JavaFile.builder(&quot;com.youngfeng.proxy&quot;, typeSpecBuilder.build()).build(); // 为了看的更清楚，我将源码文件生成到桌面 String sourcePath = &quot;/Users/ouyangfeng/Desktop/&quot;; javaFile.writeTo(new File(sourcePath)); // 编译 JavaCompiler.compile(new File(sourcePath + &quot;/com/youngfeng/proxy/TimeProxy.java&quot;)); // 使用反射load到内存 URL[] urls = new URL[] {new URL(&quot;file:&quot; + sourcePath)}; URLClassLoader classLoader = new URLClassLoader(urls); Class clazz = classLoader.loadClass(&quot;com.youngfeng.proxy.TimeProxy&quot;); Constructor constructor = clazz.getConstructor(InvocationHandler.class); Object obj = constructor.newInstance(handler); return obj;} 上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码： 测试代码 1Proxy.newProxyInstance(Flyable.class, new MyInvocationHandler(new Bird())); 生成的TimeProxy.java源码 12345678910111213141516171819202122package com.youngfeng.proxy;import java.lang.Override;import java.lang.reflect.Method;public class TimeProxy implements Flyable { private InvocationHandler handler; public TimeProxy(InvocationHandler handler) { this.handler = handler; } @Override public void fly() { try { Method method = com.youngfeng.proxy.Flyable.class.getMethod(&quot;fly&quot;); this.handler.invoke(this, method, null); } catch(Exception e) { e.printStackTrace(); } }} MyInvocationHandler.java 1234567891011121314151617181920212223public class MyInvocationHandler implements InvocationHandler { private Bird bird; public MyInvocationHandler(Bird bird) { this.bird = bird; } @Override public void invoke(Object proxy, Method method, Object[] args) { long start = System.currentTimeMillis(); try { method.invoke(bird, new Object[] {}); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } long end = System.currentTimeMillis(); System.out.println(&quot;Fly time = &quot; + (end - start)); }} 至此，整个方法栈的调用栈变成了这样： 看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。 其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。 如何使用上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳： Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象 InvocationHandler：这个接口主要用于自定义代理逻辑处理 为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。 查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。 这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？ 想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！ 只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。 事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。 JDK实现揭秘通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。 Proxy.java InvocationHandler 可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义： Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。 Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。 最后一个参数就不用说了，和我们实现的版本完全是一样的。 仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档： 核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。 遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。 答疑解惑invoke方法的第一个参数proxy到底有什么作用？这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。 动态代理到底有什么用？学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 AOP。所谓的AOP，就像刀一样，抓住时机，趁机插入。 基于这样一种动态特性，我们可以用它做很多事情，例如： 事务提交或回退（Web开发中很常见） 权限管理 自定义缓存逻辑处理 SDK Bug修复… 如果你阅读过 Android_Slide_To_Close 的源码会发现，它也在某个地方使用了动态代理设计模式。 总结到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。 为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点： 至少已经理解了面向对象语言的多态特性 了解简单的反射用法 会简单使用 JavaPoet 生成Java源码 如果你在阅读文章的过程中，有任何不理解的问题或者建议，欢迎在文章下方留言告诉我！ 本篇文章例子代码：https://github.com/yuanhoujun/java-dynamic-proxy 我是欧阳锋，设计模式是一种非常好的编程指导模型，它在所有编程语言中是通用的，并且是亘古不变的。我建议你在这个方面多下苦功，不要纠结在一些重复的劳动中，活用设计模式会让你的代码更显灵动。想要了解我吗？看这里：欧阳锋档案馆。","link":"/2018/03/02/design pattern/10分钟看懂动态代理设计模式/"},{"title":"关于Git，你真的学会了吗？","text":"“锋哥，Git有什么可说的，不就是git add添加，git commit提交嘛” 听说我要写一篇Git教程，小明不屑一顾地说。“…”。 小明是我的一个学生。目前，是一名Android开发工程师。 过了几天，我又再次见到了小明。 “锋哥，今天，我在Github新建了一个版本库，本地提交后推送远程的时候，却被拒绝了，是怎么回事？” 以下是小明的操作记录：12345git initgit add .git commit -m &quot;Init commit&quot;git remote add origin git@github.com:xiaoming/xxx.gitgit pull origin master 以上操作触发了下面的错误：1234From git@github.com:xiaoming/xxx.git * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; origin/masterfatal: refusing to merge unrelated histories “小明，注意看最后一句提示。翻译成中文的意思是 ‘拒绝合并不相关的历史’，这个问题有两个方案可以处理。” git pull命令其实是触发了拉取git fetch和合并git merge两个操作。而本地的版本库和远程版本库在第一次拉取或推送完成之前是毫不相关的，Git为了避免不必要的合并，默认不允许进行这样的操作。但你可以手动添加--allow-unrelated-histories强制进行合并，这是方案一。 1git pull origin master --allow-unrelated-histories 再来看方案二，从你上面的操作来看，你只是在本地初始化了一个版本库，并完成了基础的提交。接下来，你希望和远程版本库建立关联，将提交推送到远程。这种情况下，其实你可能并不需要远程的默认数据（通常是一个空的README文件）。所以，你可以添加-f参数，将提交强制提交并覆盖远程版本库。 1git push -f origin master 小明若有所思地点点头，这是小明第一次遇到Git问题。我想，接下来他应该会比较顺利了。 没想到，过了几天，我又收到了小明的消息。这一次，他发来的是对Git的抱怨。 “锋哥，Git好讨厌，提交日志出现了错误，也不能修改。你知道搜狗输入法有时候不够智能，输入太快不小心就输错了…😓” “🙂，你这孩子，别轻易下结论哈。其实，Git是允许修改提交记录的。使用Git最舒服的一点就是：Git永远都会给你反悔的机会。这一点，其它的版本控制工具是做不到的！” “哦，原来是这样啊！那快说说看，要怎么做？” 小明已经一副迫不及待的表情了。 “git commit命令中有一个参数叫--amend就是为解决这个问题而生的。因此，如果是最近的提交，你只需要按照下面的命令操作即可。” 1git commit --amend -m &quot;这是新的提交日志&quot; 看完我的消息，小明给我发来一个微笑的表情。小明的抱怨让我想起一句好气又好笑的农村俗语 “屙屎不出怪茅坑”，哈哈。 本以为一切可以风平浪静了。没想到，过了一个月左右，突然接到了小明的紧急电话。电话那头，小明似乎心情很急躁。 “锋哥，我不小心进行了还原操作，我写的代码全丢了。几千行的代码啊，明天晚上就要发版本了，有办法找回来吗？” 听到这个消息，我心里盘算，大约有50%的概率应该是找不回来了。这孩子比较粗心，可能根本就没提交到版本库。但如果他正好提交到了版本库，兴许还有救。因此，我安慰他说 “小明，别急！你打开TeamViewer，我远程帮你看看” 连上机器后，我使用history命令看到小明在提交之后使用了git reset --hard xxx命令进行重置。--hard是git reset命令中唯一一个不安全的操作，它会真正地销毁数据，以至于你在git log中完全看不到操作日志。可是，Git真的很聪明，它还保存了另外一份日志叫reflog，这个日志记录了你每次修改HEAD的操作。因此，你可以通过下面的命令对数据进行还原：12345678git reflog// 使用这个命令，你看到的日志大概是这样c8278f9 (HEAD -&gt; master) HEAD@{0}: reset: moving to c8278f9914a91e3aca6ab0993b48073ba1e41b2b3e59423 HEAD@{1}: commit: ac8278f9 (HEAD -&gt; master) HEAD@{2}: commit (amend): v2 update2dc167b HEAD@{3}: commit: v22e342e9 HEAD@{4}: commit (initial): Init commit 可以看到，我们在版本3e59423进行了git reset操作，最新版本是3e59423。因此，我们可以再次通过git reset命令回到这个版本：1git reset --hard 3e59423 以上操作完成后，你会惊喜地发现，丢失的数据居然神奇般地回来了。 “🌺 🌺 🌺” “下次别这样操作了哈。另外，你怎么一次性丢失这么多代码。一定要记得勤提交。” 小明出现这样的问题，与平时的不规范操作也是分不开的。因此，最后我还不忘嘱咐了他一句。 “好的，我知道了。对了，我一个还有比较疑惑的问题。git checkout和git reset到底有啥区别？我以前用SVN的时候git checkout是用来检出代码的，在Git中可以用它切换分支或者指定版本，但git reset同样可以做到。难道两者是完全一样的吗？” 小明在QQ中给我发来了回复消息。 “这是一个比较有深度的问题，解释这个问题需要一点时间。接下来，你仔细听” 理解Git工作空间理解这个问题之前，先来简单学习一些Git基础知识。Git有三种状态： 已提交（commited）：数据已完全保存到本地数据库中 已修改（modified）：修改了文件，但还没有保存到数据库中 已暂存（staged)：对一个已修改的文件做了标记，将包含在下一次提交的版本快照中 这三种状态对应Git三个工作区域：Git版本库、暂存区和工作区 Git版本库是Git用来保存项目的元数据和对象数据库的地方，使用git clone命令时拷贝的就是这里的数据。 工作目录是对某个版本独立检出的内容，这些数据可以供你使用和修改。 暂存区在Git内部对应一个名为index的文件，它保存了下次将要提交的文件列表信息。因此，暂存区有时候也被叫作 “索引”。 一个基础的Git工作流程如下：1）在工作区修改文件2）使用git add将文件添加到暂存区，也就是记录到index文件中3）使用git commit将暂存区中记录的文件列表，使用快照永久地保存到Git版本库中 理解HEAD解释这个问题，你还需要简单理解HEAD是什么。简单来说，HEAD是当前分支引用的指针，它永远指向该分支上最后一次提交。为了让你更容易理解HEAD，你可以将HEAD看作上一次提交数据的快照。 如果你感兴趣，你可以使用一个底层命令来查看当前HEAD的快照信息:1234567git ls-tree -r HEAD100644 blob aca4b576b7d4534266cb818ab1191d91887508b9 demo/src/main/java/com/youngfeng/snake/demo/Constant.java100644 blob b8691ec87867b180e6ffc8dd5a7e85747698630d demo/src/main/java/com/youngfeng/snake/demo/SnakeApplication.java100644 blob 9a70557b761171ca196196a7c94a26ebbec89bb1 demo/src/main/java/com/youngfeng/snake/demo/activities/FirstActivity.java100644 blob fab8d2f5cb65129df09185c5bd210d20484154ce demo/src/main/java/com/youngfeng/snake/demo/activities/SecondActivity.java100644 blob a7509233ecd8fe6c646f8585f756c74842ef0216 demo/src/main/java/com/youngfeng/snake/demo/activities/SplashActivity.java 这里简单解释一下每个字段的意思：100644表示文件模式，其对应一个普通文件。blob表示Git内部存储对象数据类型，另外还有一种数据类型tree，对应一个树对象，中间较长的字符串对应当前文件的SHA-1值，这部分不需要记住，简单了解即可。 所以，简单来说，HEAD对应一个树形结构，存储了当前分支所有的Git对象快照： 我们用一个表格简单来总结一下以上知识点： HEAD Index(暂存区) 工作区 上一次提交的快照，下一次提交的父节点 预期的下一次提交快照 当前正在操作的沙盒目录 理解git reset和git checkout区别主要是理解Git内部是怎么操作以上三棵树的。 接下来，我们用一个简单的例子来看一下使用git reset到底发生了什么。先创建一个Git版本库并触发三次提交：123456789101112git init repotouch file.txtgit add file.txtgit commit -m &quot;v1&quot;echo v2 &gt; file.txtgit add file.txtgit commit -m &quot;v2&quot;echo v3 &gt; file.txtgit add file.txtgit commit -m &quot;v3&quot; 以上操作完成后，版本库现在看起来是这样的： 接下来执行命令git reset 14ad152看看会发生什么。以下是命令执行完成后看到的结果：123456789101112git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ### M file.txtcat file.txt### This is output ###v3 可以看到版本库中文件版本回退到了V2，工作区文件内容同之前的版本V3一致；为了确认暂存区发生了什么变化，我们再使用一个底层命令对比一下暂存区数据和版本库数据是否一致：123456789# 查看暂存区信息git ls-files -s### This is output ###100644 8c1384d825dbbe41309b7dc18ee7991a9085c46e 0 file.txt# 查看版本库快照信息git ls-tree -r HEAD### This is output ###100644 blob 8c1384d825dbbe41309b7dc18ee7991a9085c46e file.txt 可以看到当前版本库和暂存区信息是完全一致的，HEAD指向了v2提交，用一个图形来表示整个过程，应该是这样： 看一眼上图，理解一下刚刚发生的事情：首先，HEAD指针发生了移动，指向了V2，并撤销了上一次提交。目前，版本库和暂存区都保存的是第二次提交的记录，工作区却保存了最近一次修改。稍微联想一下，你就会发现，这次的git reset命令恰好是最近一次提交的逆向操作。让数据完全回到了上一次提交前的状态。所以，如果你想撤销最近一次提交，可以这么做。 增加–soft参数测试以上是我们对git reset命令的第一次尝试，在下一轮尝试前，先执行git help reset看看reset命令的用法：123git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;...git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...]git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;] 看最后一句发现，reset命令后面还可以接5个不同的参数: --soft、--mixed、--hard 、--merge、--keep。这里我们主要关注前面三个，其中--mixed其实刚刚已经尝试过，它和不带参数的git reset命令是同样的效果。换而言之，--mixed是git reset命令的默认行为。接下来执行git reset --soft 14ad152看看会发生什么。命令执行完成后，按照惯例，我们同样使用基础命令看看发生了什么变化：123456789101112git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ###M file.txtcat file.txt### This is output ###v3 奇怪了？为什么会和上次不带任何参数的执行结果完全一致？难道Git出现了设计错误。相信你看到结果一定会有这样的疑问，其实不然！因为，这里我用文本粘贴了输出结果，忽略了命令的字体颜色，其实这里第二条命令输出结果中的M颜色与上一次执行结果是不一样的。为了让你看到不同，看下面的截图：这个颜色表示：file.txt文件已经被添加到了暂存区，使用git commit命令就可以完成提交。为了严谨，我们依然使用上面的底层命令看看版本库和暂存区信息是否一致。注意：这里的结果应该是不一致才对，因为版本库记录的文件版本是v2，而暂存区记录的文件版本其实是v3。1234567git ls-tree -r HEAD### This is output ###100644 blob 8c1384d825dbbe41309b7dc18ee7991a9085c46e file.txtgit ls-files -s### This is output ###100644 29ef827e8a45b1039d908884aae4490157bcb2b4 0 file.txt 可以看到，两个命令执行输出的SHA-1并不一致，验证了我们的猜想。 这里我们可以得出一个结论：--soft和默认行为(--mixed)不一样的地方是：--soft会将工作区的最新文件版本再做一步操作，添加到暂存区。使用这个命令可以用来合并提交。即：如果你在某一次提交中有未完成的工作，而你反悔了，你可以使用这个命令撤销提交，等工作做完后继续一次性完成提交。 增加–hard参数测试接下来我们对最后一个参数进行测试，这也是小明在使用过程出现问题的一个参数。执行命令git reset --hard 14ad152，看看发生了什么：1234567891011git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ###&gt;&gt;&gt; No output &lt;&lt;&lt;cat file.txtv2 注意看，这次使用git status -s完全看不到输出，这就证明：当前工作区，暂存区，版本库数据是完全一致的。查看文件内容，发现文件回到了v2版本。通常情况下，如果你看到这种情况，一定会吓一跳，你最近一次提交的数据居然完全丢失了。的确，这是Git命令中少有的几个真正销毁数据的命令之一。除非你非常清楚地知道自己在做什么，否则，请尽量不要使用这个命令！ 我们依然用一张图，完整地描述这个命令到底发什么了什么： 可以看到，相对于默认行为，--hard将工作区的数据也还原到了V2版本，以至于V3版本的提交已经完全丢失。 git checkout接下来看git checkout, 按照惯例，先执行git checkout 14ad152看看会发生什么：1234567891011git log --abbrev-commit --pretty=oneline### This is output ###14ad152 (HEAD -&gt; master) v2bcc49f4 v1git status -s### This is output ###&gt;&gt;&gt; No output &lt;&lt;&lt;cat file.txtv2 可以看到，又出现了神奇的一幕，这一次git checkout命令的执行结果的确和git reset --hard完全一致。这是否意味着两者就没有任何区别了呢？当然也不是。严格来说，两者有两个“本质”的区别： 相对而言，git checkout对工作目录是安全的，它不会将工作区已经修改的文件还原，git reset则不管三七二十一一股脑全部还原。 另外一个比较重要的区别是，git checkout并不移动HEAD分支的指向，它是通过直接修改HEAD引用来完成指针的指向。 第二个不同点相对比较难理解，我们用一张图来更直观地展示二者的区别： 简单来说，git reset会通过移动指针来完成HEAD的指向，而git checkout则通过直接修改HEAD本身来完成指向的移动。 命令作用于部分文件git reset和git checkout还可以作用于一个文件，或者部分文件，即带文件路径执行。这种情况下，两个命令的表现不太一样。我们来试试看，先执行git reset 14ad15 -- file.txt命令尝试将文件恢复到V2版本。命令执行完成，按照惯例用一些基础命令来看看发生了什么：123456789101112131415161718git log --abbrev-commit --pretty=oneline### This is output ###4521405 (HEAD -&gt; master) v314ad152 v2bcc49f4 v1git status -v### This is output ###diff --git a/file.txt b/file.txtindex 29ef827..8c1384d 100644--- a/file.txt+++ b/file.txt@@ -1 +1 @@-v3+v2cat file.txtv3 可以看到，版本库和工作区的数据都没有发生变化。唯一发生变化的是暂存区，暂存区记录下一次提交的改动将导致数据从V3恢复到V2版本! 这里我们可以这样理解：执行这条命令后，Git先将暂存区和工作区的文件版本恢复到V2，再将工作区的文件版本恢复到V3。与--hard不一样的地方是：这个命令并不会覆盖工作区已经修改的文件，是安全操作。 执行带路径的git checkout命令和git reset命令有一些细微的差别，相对于git reset，git checkout带路径执行会覆盖工作区已经修改的内容，导致数据丢失，是一个非安全操作。 针对上面的所有实验，我们用一个简单的表格来总结他们的区别，以及操作是否安全： 不带路径执行 命令行 HEAD 暂存区 工作区 目录安全 git reset [–mixed] YES YES NO YES git reset –soft YES YES NO YES git reset –hard YES YES YES NO git checkout Modify YES YES YES 带路径执行 命令行 HEAD 暂存区 工作区 目录安全 git reset – NO YES NO YES git checkout NO YES YES NO 注意：执行非目录安全的命令操作的时候，一定要慎重，除非你非常清楚自己在做什么！ “小明，你明白了吗？” 消息发送过去之后，等了很久却一直没有响应。“哎，这孩子！估计听睡着了… 😆” 自从这次问到Git的问题后，已经两年过去了，小明再没有问到关于Git的问题。而就在昨天，突然又收到了小明的消息。 也许你应该试试Git Flow“锋哥，我现在已经是Android Leader了。现在安卓团队一共6个人，我们现在在做一个社交类应用，在Git管理方面我还是发现了一些问题。其中一个问题就是，现在版本库有好多分支，其中开发主要在develop分支。主干分支是master主要用于版本发布。可还有一些分支却显得非常混乱，有什么办法改善这种情况吗？” “关于Git的分支设计，目前有一个公认比较好的设计叫 Git Flow模型。关于Git Flow模型，你可以查看这篇文章 http://nvie.com/posts/a-successful-git-branching-model/ 了解一下” 一个idea，一次提交“好的！还有一个困扰了我很久的问题是，大家的提交日志写的比较笼统。在查找问题的时候非常不便，而且大部分同学一次性提交好多文件，导致解决问题的时候不能准确定位到具体是哪一次提交导致的。我告诉大家，一次提交改动要尽可能小。但当别人问到具体的提交规则的时候我又不知道从何说起…” “这是一个很好的问题 。中国程序员普遍存在的一个问题是，恨不得把这辈子能提交的代码一次性搞定。甚至有人用多次提交太麻烦的借口来搪塞问责人。简单来说，可以用一句话概括提交原则：一个idea，一次提交。另外，你说的没错，提交必须尽可能小，注释必须尽可能表述准确！” 给小明讲了这么多Git，我忍不住半开玩笑地问他，“小明，你现在还觉得Git简单吗？” 小明发了一个无奈的表情！说道，“以前是我才疏学浅，略知皮毛，不知道Git原来还有这么多玩法，忍不住为Git的发明者点赞了。对了，锋哥，Git到底是谁开发的？” Git的最大功臣，其实不是Linus”关于Git的故事，互联网上其实已经烂大街了。我简单给你介绍一下吧！Git的诞生其实是一个偶然，其初始使命是为Linux内核代码管理服务的。早年的时候Linux内核源码是用Bitkeeper版本控制工具管理的。可是，后来因为某些利益关系，Bitkeeper要求Linux社区付费使用。这一举动激怒了Linus，也就是Linux的创始人，他决定自己开发一个分布式版本控制系统。几周时间下来，Git的雏形就诞生了，并且开始在Linux社区中应用开来。虽然Linus是Git的创始人，可是背后的最大功臣却是一个日本人 Junio C Hamano。Linus在Git开源版本库的提交只有258次，而Junio C Hamano却提交了4000多次。也就是说，在Linus开发后不久项目的管理权就交给了这个日本人。关于 Junio C Hamano，你感兴趣的话可以Google了解一下。他现在在Google工作，如同Linus一样非常低调。“ “这个故事也告诉我：不要用技术去挑战一个程序员 @_@ ” 这个故事讲完，小明与Git的故事就已经告一段落了。其实，还有一些比较常见的问题，小明并没有问到过。这里，我为你准备了一个附录，给你介绍一些常用的小命令帮你解决日常小问题。它很有用，一定要拿笔记下来，或者收藏这篇文章备用。 常见问题问题一：公司的Git服务器是搭建在一个内网服务器上面的，我想把代码同时提交到OsChina上面，以便在家拉取代码，远程办公，怎么办？Git本身是一个分布式的版本管理系统，实现这个需求非常简单，使用git remote add命令添加多个远程版本库关联即可。12git remote add company git@xxxgit remote add home git@xxx 问题二：在拉取远程代码的时候，如果本地有代码还没有提交，Git就会提示先提交代码到版本库。可暂时我又不想提交，怎么办？针对这个问题，Git提供了一个临时区域用于保存不想提交的记录，对应的命令是git stash。通常情况下，你可以这样操作：123456789101112# 将暂时还不想提交的数据保存到临时区域，保存成功后，工作区将和版本库完全一致git stash# 还原stash数据到工作区git stash apply# 以上操作完成后，stash数据依然保存在临时区域中，为了删除这部分数据，使用如下命令即可。git stash drop# 如果你想在还原数据的同时从临时区域删除数据，可以这样操作：git statsh pop# 以上两个命令如果不接任何参数将删除掉所有的临时区域数据，如果你只想删除其中一条记录，指定对应索引数据即可。git stash pop/drop stash@{index}# 查看临时区域所有数据，使用如下命令：git stash list 问题三：作为项目负责人，我希望迅速找出问题代码的“元凶”，有什么办法吗？针对这个问题，最好的答案是git blame，使用这个命令并指定具体文件它将显示文件每一行代码的最近修改记录，你可以清晰地看到最近代码的修改人。 问题四：部分Team Leader会要求使用git rebase合并代码，这有什么好处吗？我们用一个简单的思维来理解这个问题，最常见的合并操作是使用git merge，而这样操作会在合并分支生成一次新的提交，并且会严格记录分支提交日志，在长期开发过程中，日志就会呈现多条线路展示，给阅读带来一定的障碍。而使用git rebase会使整体代码提交记录始终像在单一分支开发一样，仅使用一条线路展示。但使用git rebase是有一定陷阱的，这个问题需要一定的时间才能说清楚，如果需要了解两个命令的详细区别，我推荐你阅读这篇文章 Rebase 代替合并。 总结Git是一个非常优秀的版本控制系统，我极力推荐你在日常开发中使用。这篇文章从小明的角度解释了几个常见问题的解决方案，毫无悬念地，你可能还会遇到其它的一些问题。遇到问题，你可以尝试使用Google搜索解决方案；也可以在文章下方给我留言，我非常乐意为你解答Git问题。 我是欧阳锋，版本控制，我使用Git。了解欧阳锋，从这里开始：欧阳锋档案馆。","link":"/2018/02/01/develop tools/关于Git，你真的学会了吗？/"},{"title":"技术相对论之软件架构","text":"有同学问我，你是怎样学习编程的呢？为了回答你的这个问题，今天，我们一起来做一件非常有意思的事情。我们以MVC架构为基，从服务端编程开始，依次类推iOS、Android，并最终完成登录、注册功能。 What is MVC ？正文开始之前，我们先来简单了解一下MVC架构。 MVC全称是Model-View-Controller，是上个世纪80年底Xerox PARC为其编程语言SmallTalk发明的一直软件设计模式。我们可以用一张图来表示MVC架构模型： MVC的核心思想是希望通过控制层管理视图呈现，从将逻辑层和视图层进行分离。 服务端编程其实就是MVC的最佳实践，理解了MVC架构之后，我们马上开始服务端编程。 服务端编程服务端编程也叫后端编程，主要用于为前端提供数据源以及完成必要的业务逻辑处理。 这个部分我们使用Java语言开发，MVC框架使用最常用的 Spring MVC，完整配置请参考下方表格： IDE 编程语言 框架 数据库 服务器 IntelliJ IDEA Java 1.8 Spring MVC MySQL Tomcat 7.0.57 为了简化数据库的访问，我们再增加一个轻量级的数据库访问框架 MyBatis。 这里假设你已经正确安装了MySQL数据库和Tomcat服务器，如果你对具体的安装步骤有疑问，请在文章下方评论告诉我。 在开始编程之前，我们需要完成以下准备工作： 第一步：创建数据库d_user以及用户表t_user用于保存用户数据123456789create database d_server;use d_server;CREATE TABLE `t_user` ( `id` int(10) NOT NULL AUTO_INCREMENT, `username` varchar(20) NOT NULL, `pwd` varchar(32) NOT NULL, PRIMARY KEY (`id`), UNIQUE KEY `username` (`username`)) 第二步：使用IntelliJ IDE创建一个Gradle依赖工程 最后一个步骤选择工作目录确定即可。 第三步：在build.gradle脚本文件中添加Spring MVC以及MyBatis依赖12compile group: &apos;org.springframework&apos;, name: &apos;spring-webmvc&apos;, version: &apos;5.0.4.RELEASE&apos;compile group: &apos;org.mybatis&apos;, name: &apos;mybatis&apos;, version: &apos;3.4.6&apos; 第四步：关联本地Tomcat服务器a）编辑运行设置，选择本地Tomcat服务器 b）选择以war包的方式部署到Tomcat c）在浏览器中输入http://localhost:8080测试工作是否正常 如果看到下面这个界面，证明一切工作正常 第五步：配置Spring MVC备注：参考官方文档 Web on Servlet Stack a）在webapp目录下面生成WEB-INF/web.xml配置文件选择菜单File-&gt;Project Structure进入如下界面：在弹出的界面中设置路径为…/webapp/WEB-INF即可。 b）在web.xml文件中添加如下配置信息 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/app-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;servlet-name&gt;/&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;/&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 上面这部分配置主要是使用Spring MVC的DispatcherServlet完成请求的拦截分发。配置文件中引用了另外一个配置文件app-context.xml，这个配置文件主要是完成Spring的依赖注入。 c）在app-context.xml配置文件中添加如下信息 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 添加扫描注解的包 --&gt; &lt;context:component-scan base-package=&quot;com.youngfeng.server&quot;/&gt; &lt;!-- 使用注解完成依赖注入 --&gt; &lt;mvc:annotation-driven /&gt;&lt;/beans&gt; d）添加jackson依赖用于Spring实现Json自动解析 12compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-databind&apos;, version: &apos;2.9.4&apos;compile group: &apos;com.fasterxml.jackson.core&apos;, name: &apos;jackson-core&apos;, version: &apos;2.2.3&apos; PS：不得不承认，Java后端开发的xml文件配置实在是一件繁琐至极的事情，尽管我们只需要配置一次。为了简化配置，Spring官方推出了一个重磅产品 Spring Boot。不过，这不是本文讨论的重点，感兴趣的同学请自行了解。 虽然我们已经完成了Spring的配置，但MyBatis的配置工作才刚刚开始。 配置MyBatis为了简化Spring中MyBatis的配置，我们再增加一个MyBatis官方的提供的 mybatis-spring 库。 1compile group: &apos;org.mybatis&apos;, name: &apos;mybatis-spring&apos;, version: &apos;1.3.2&apos; 备注：参考官方文档 mybatis-spring a）在spring配置文件app-context.xml配置文件中添加如下bean配置: 123&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;/bean&gt; b）指定数据源 b1) 添加Spring JDBC与MySQL Connector依赖 12compile group: &apos;org.springframework&apos;, name: &apos;spring-jdbc&apos;, version: &apos;5.0.4.RELEASE&apos;compile group: &apos;mysql&apos;, name: &apos;mysql-connector-java&apos;, version: &apos;6.0.6&apos; 注意：因为部分依赖包只存在于JCenter，需要在build.gradle脚本中添加jcenter maven源 1234repositories { mavenCentral() jcenter()} b2）在app-context.xml文件中添加如下配置： 1234567891011121314151617&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot;&gt; &lt;value&gt;${jdbc.driverClassName}&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;url&quot;&gt; &lt;value&gt;${jdbc.url}&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;username&quot;&gt; &lt;value&gt;${jdbc.username}&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;${jdbc.password}&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; b3）在类路径目录下创建db.properties文件指定MySQL数据库信息 1234jdbc.driverClassName = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/d_serverjdbc.username = rootjdbc.password = root 至此，所有的配置工作终于完成了，接下来进入最重要的编码阶段。 由于控制层需要依赖模型层的代码，因此，我们按照从下往上的原则进行编码。a）先完成数据库的访问部分（DAO） 12345678910public interface UserDAO { @Select(&quot;select * from t_user where username = #{username}&quot;) User findByUsername(@Param(&quot;username&quot;) String username); @Select(&quot;select * from t_user where username = #{username} and pwd = #{pwd}&quot;) User findUser(@Param(&quot;username&quot;) String username, @Param(&quot;pwd&quot;) String pwd); @Insert(&quot;insert into t_user(username, pwd) values(#{username}, #{pwd})&quot;) void insert(@Param(&quot;username&quot;) String username, @Param(&quot;pwd&quot;) String pwd);} 结合MyBatis，这个部分的工作很简单，甚至DAO的实现都不需要手动编码。 为了实现DAO的依赖注入，我们在app-context.xml配置文件中添加如下配置： 1234&lt;bean id=&quot;userDAO&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt; &lt;property name=&quot;mapperInterface&quot; value=&quot;com.youngfeng.server.dao.UserDAO&quot;/&gt; &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt; b）Service层编码（也叫Domain层）Service部分是控制层直接调用的接口，从抽象思维来说，也应该使用面向接口的方式编码。这里为了简化，Service部分我们直接使用一个类来实现了。 1234567891011121314151617@Component(&quot;userService&quot;)public class UserService { @Autowired UserDAO userDAO; public boolean isExist(String username) { return null != userDAO.findByUsername(username); } public boolean isExist(String username, String pwd) { return null != userDAO.findUser(username, pwd); } public void saveUser(String username, String pwd) { this.userDAO.insert(username, pwd); }} c）控制层编码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Controller@RequestMapping(&quot;/user&quot;)public class UserController { @Autowired UserService userService; @ResponseBody @GetMapping(&quot;/login&quot;) public Response login(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;pwd&quot;) String pwd) { Response response = new Response(); // 先判断用户名是否存在，给定不同Code用于区分不同错误 boolean isExist = userService.isExist(username); if(!isExist) { response.setCode(Response.CODE_USER_NOT_EXIST); response.setMsg(&quot;用户不存在或密码错误&quot;); } // 判断用户名和密码是否匹配 isExist = userService.isExist(username, pwd); if(!isExist) { response.setCode(Response.CODE_USER_PWD_ERR); response.setMsg(&quot;用户不存在或密码错误&quot;); } return response; } @ResponseBody @GetMapping(&quot;/register&quot;) public Response register(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;pwd&quot;) String pwd) { Response response = new Response(); // 注册之前，判断用户名是否已存在 boolean isExist = userService.isExist(username); if(isExist) { response.setCode(Response.CODE_USER_HAS_EXIST); response.setMsg(&quot;用户名已存在&quot;); } else { userService.saveUser(username, pwd); } return response; }} 想必大家应该已经注意到了，控制层部分请求类型我使用了GET，这是为了方便在浏览器上面测试。测试通过后，要修改为POST请求类型。 以上代码，我已经在浏览器上测试通过。接下来，我们马上进入iOS客户端编程。 iOS客户端编程iOS部分开发工具我们使用Xcode 9.2，其实你也可以使用AppCode，这是基于IntelliJ IDE开发的一款IDE，使用习惯完全接近IntelliJ IDE。 为了防止部分同学对Swift语言不熟悉，我们使用最常见的编程语言OC。 完整配置请参考如下表格： IDE 编程语言 网络框架 Xcode 9.2 Objective C AFNetworking 打开Xcode，依次选择Create new Xcode Project-&gt;Single View App 下一步填入如下信息，语言选择OC 第一步：完成UI部分这一部分参考苹果官方文档，按照苹果官方推荐，我们使用Storyboard进行布局。由于我们只是完成一个简单的Demo，所有的页面将在同一个Storyboard中完成。实际开发过程中，要根据功能划分Storyboard，方便进行小组开发。 使用约束布局我们很快完成了UI的构建，接下来进入最重要的编码阶段。约束布局的意思就是为一个控件添加N个约束，使其固定在某个位置。这个部分只要稍加尝试，就能掌握。具体的使用方法，请参考官方文档。 第二步：创建控制器，并关联UI从服务器编程类推，iOS编程模型中应该也有一个叫Controller的东西。果不其然，在iOS新创建的工程中就有一个叫做ViewController的类，其父类是UIViewController。没错，这就是传说中的控制器。 123456#import &lt;UIKit/UIKit.h&gt;@interface ViewController : UIViewController@end 完成登录、注册功能，我们至少需要三个控制器：LoginViewController、RegisterViewController、MainViewController，分别代表登录、注册、首页三个页面。 接下来，将控制器与UI进行关联。 UI关联控制器部分，如果你不知道，请先参考苹果官方文档。 事实上，Xcode的Interface Builder非常好用。按照下图操作即可： 最后，关联按钮点击事件以及输入框。 选中控件并按住鼠标右键拖拽到控制器源码中，松开，并选择相应类型即可： 以登录控制器为例，拖拽完成后的源码如下： 12345678910111213@interface LoginViewController ()@property (weak, nonatomic) IBOutlet UITextField *mUsernameTextField;@property (weak, nonatomic) IBOutlet UITextField *mPwdTextField;@end@implementation LoginViewController- (IBAction)login:(id)sender {}- (IBAction)goToRegister:(id)sender {} 接下来进入网络部分编程。 为了简化网络部分编程，我们引入AFNetworking框架。还记得服务端编程是怎么引入依赖的吗？没错，是Gradle。iOS端也有类似的依赖管理工具Cocoapods，这个部分如果不会依然请你参考官方文档。 使用如下步骤安装依赖（这里假设你已经正确安装了Cocoapod）：a）在根目录下面创建Podfile文件，并添加如下内容： 123456source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;8.0&apos;target &apos;IOSClient&apos; dopod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos;end b）安装依赖 1pod install PS：可能有人会问，为什么服务端编程没有安装依赖的步骤。其实，很简单，intelliJ IDE非常智能，它自动检测了build.gradle文件的修改。一旦发现修改，自动安装依赖。因此，看起来就像没有依赖安装这个步骤一样。事实上，Cocoapod并非苹果官方的产品，如果产品来自苹果官方，恐怕Xcode也会支持自动安装依赖。 依赖安装完成后，为了更好地服务我们的业务。我们对网络请求做一点简单封装，增加HttpClient类，仅提供一个POST请求接口即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//// HttpClient.m// IOSClient//// Created by 欧阳锋 on 17/03/2018.// Copyright © 2018 xbdx. All rights reserved.//#import &quot;HttpClient.h&quot;#import &lt;AFNetworking.h&gt;#import &quot;Response.h&quot;@implementation HttpClientstatic const NSString *BASE_URL = @&quot;http://192.168.31.146:8080&quot;;- (instancetype)init { self = [super init]; if (self) { self.baseUrl = BASE_URL; } return self;}+ (HttpClient *)initWithBaseUrl:(NSString *)baseUrl { HttpClient *client = [[HttpClient alloc] init]; client.baseUrl = baseUrl; return client;}+ (HttpClient *)sharedInstance { static HttpClient *client = nil; static dispatch_once_t once; dispatch_once(&amp;once, ^{ client = [[self alloc] init]; }); return client;}- (void)POST:(NSString *)url params:(NSDictionary *)params success:(void (^)(NSString *, id))success error:(void (^)(NSString *, NSInteger, NSInteger, NSString *))error { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer = [AFJSONResponseSerializer serializer]; [[AFHTTPSessionManager manager] POST: [_baseUrl stringByAppendingString:url] parameters: params progress: nil success: ^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { if(nil != success) { if(nil != responseObject) { if([responseObject isKindOfClass: [NSDictionary class]]) { NSInteger code = ((NSDictionary *)responseObject)[@&quot;code&quot;]; if(SUCCESS == code) { success(url, responseObject); } else { if(nil != error) { NSString *msg = ((NSDictionary *)responseObject)[@&quot;msg&quot;]; error(url, SC_OK, code, msg); } } } } } } failure: ^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull nsError) { if(nil != nsError) { error(url, nsError.code, nil, nsError.description); } }]; }@end 为了简化JSON解析，我们增加一个最常见的Json解析库 jsonmodel 库。等待对话框也使用最常见的第三方库 SVProgressHUD。 12pod &apos;JSONModel&apos;pod &apos;SVProgressHUD&apos; 安装依赖使用同样的命令pod install即可。 接下来，我们添加登录注册逻辑，完成最后部分编码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 登录部分逻辑- (IBAction)login:(id)sender { [SVProgressHUD show]; HttpClient *client = [HttpClient sharedInstance]; [client POST: @&quot;/user/login&quot; params: @{@&quot;username&quot; : _mUsernameTextField.text, @&quot;pwd&quot; : _mPwdTextField.text} success:^(NSString *url, id data) { [SVProgressHUD dismiss]; if([data isKindOfClass: [NSDictionary class]]) { // 例子代码，这里不做严格判断了 User *user = [[User alloc] initWithDictionary: data[@&quot;data&quot;] error: nil]; [self pushToMainViewController: user]; } } error:^(NSString *url, NSInteger httpCode, NSInteger bizCode, NSString *error) { [SVProgressHUD dismiss]; [self promptError: error]; }];}- (void)pushToMainViewController: (User *) user { UIStoryboard *storyboard = [UIStoryboard storyboardWithName: @&quot;Main&quot; bundle: [NSBundle mainBundle]]; MainViewController *mainViewController = [storyboard instantiateViewControllerWithIdentifier: @&quot;mainViewController&quot;]; mainViewController.user = user; [self.navigationController presentViewController: mainViewController animated: YES completion: nil];}// 注册部分逻辑- (IBAction)register:(id)sender { NSString *username = _mUsernameTextField.text; NSString *pwd = _mPwdTextField.text; NSString *confrimPwd = _mConfirmTextField.text; if([StringUtil isBlankString: username]) { [self promptError: @&quot;请输入用户名&quot;]; return; } if([StringUtil isBlankString: pwd]) { [self promptError: @&quot;请输入用户密码&quot;]; return; } if([StringUtil isBlankString: confrimPwd]) { [self promptError: @&quot;请输入确认密码&quot;]; return; } if(![pwd isEqualToString: confrimPwd]) { [self promptError: @&quot;两次密码输入不一致，请重新输入&quot;]; return; } HttpClient *client = [HttpClient sharedInstance]; [client POST: @&quot;/user/register&quot; params: @{@&quot;username&quot; : username, @&quot;pwd&quot; : pwd} success:^(NSString *url, id data) { [self promptError: @&quot;注册成功&quot; handler:^(UIAlertAction *action) { [self.navigationController popViewControllerAnimated: YES]; }]; } error:^(NSString *url, NSInteger httpCode, NSInteger bizCode, NSString *error) { [self promptError: error]; }];} 通过上面的步骤，我们已经完成了iOS客户端的开发。苹果官方默认支持的就是经典的MVC模式。因此，我们完全参考服务端开发模式完成了iOS客户端的开发。你唯一需要克服的是对新语言的恐惧，以及适应UI开发的节奏。事实上，大部分服务端程序员都害怕UI编程。 最后，我们进入Android客户端编程。 Android客户端编程Android部分开发工具，我们使用Android Studio，网络框架使用Retrofit，完整配置参考下方表格： IDE 编程语言 网络框架 Android Studio Java 1.8 Retrofit 打开Android Studio，选择Start a new Android Studio Project，在打开的页面中填入以下信息：剩下步骤全部选择默认。 按照iOS编码部分类推，Android端应该也有一个类似UIViewController的控制器。果不其然，在模板工程中就有一个MainActivity，其父类是AppCompatActivity，这就是Android的控制器。 12345678public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); }} PS：事实上Android早期版本的控制器就叫Activity，由于系统设计不断变更，最终诞生了兼容性子类AppCompatActivity。这都是早期设计不够严谨，导致的问题。相对而言，iOS端的设计就靠谱了许多。 同样地，在开始编码之前，我们加入所需的第三方依赖。那么，问题来了。Android端如何添加依赖呢？ 碰巧，Android端主要的开发语言就是Java。因此，我们依然可以使用Gradle进行依赖管理。碰巧，Android Studio默认支持的就是使用Gradle进行依赖管理。 首先，在app模块目录的build.gradle添加 Retrofit 依赖： 1implementation &apos;com.squareup.retrofit2:retrofit:2.4.0&apos; 添加完成后，点击文件右上方Sync now下载依赖： 相对于AFNetworking，Retrofit设计的更加精妙。参考Retrofit官方文档，我们开始加入登录注册逻辑： 12345678910public interface UserService { @FormUrlEncoded @POST(&quot;user/login&quot;) Call&lt;User&gt; login(@Field(&quot;username&quot;) String username, @Field(&quot;pwd&quot;) String pwd); @FormUrlEncoded @POST(&quot;user/register&quot;) Call&lt;User&gt; register(@Field(&quot;username&quot;) String username, @Field(&quot;pwd&quot;) String pwd);} Retrofit设计的其中一个巧妙之处在于：你只需要定义好接口，具体的实现交给Retrofit。你可以看到，上面的代码中我们仅仅定义了请求的类型，以及请求所需要的参数就已经完成了网络部分的所有工作。 不过，操作这个接口实现，需要使用Retrofit实例。接下来，我们参考官方文档生成一个我们需要的Retrofit实例。 在生成Retrofit实例之前，还需要注意一个事情。还记得iOS端我们是怎么完成JSON解析的吗？是的，我们使用了第三方库jsonmodel。 在Json解析的设计上，Retrofit也相当巧妙。Retrofit提供了一个转换适配器用于实现Json数据的自动转换。使用它，你可以自定义自己的Json转换适配器；也可以使用官方已经实现好的适配器。一旦添加了这个适配器，所有的Json解析工作Retrofit就会自动帮忙完成。不再需要像AFNetworking一样在回调里面反复进行Json解析操作。 因此，我们增加一个官方版本的Json转换适配器依赖 converter-json： 1implementation &apos;com.squareup.retrofit2:converter-gson:2.4.0&apos; 加入Json适配器之后，我们使用一个新的Retrofit管理类RetrofitManager用于生成项目所需要的Retrofit实例。完整代码如下： 1234567891011121314public class RetrofitManager { private static final String BASE_URL = &quot;http://192.168.31.146:8080&quot;; public static Retrofit create(String baseUrl) { return new Retrofit.Builder() .baseUrl(baseUrl) .addConverterFactory(GsonConverterFactory.create()) .build(); } public static Retrofit createDefault() { return create(BASE_URL); }} 接下来，我们尝试在MainActivity中测试登录接口，确定是否编写正确。我们在MainActivity的onCreate方法中加入如下代码： 12345678910111213141516Retrofit retrofit = RetrofitManager.createDefault();UserService userService = retrofit.create(UserService.class);Call &lt; User &gt; call = userService.login(&quot;1&quot;, &quot;1&quot;);call.enqueue(new Callback &lt; User &gt; () { @Override public void onResponse(Call &lt; User &gt; call, Response &lt; User &gt; response) { Log.e(&quot;MainActivity&quot;, call + &quot;&quot; + response); } @Override public void onFailure(Call &lt; User &gt; call, Throwable t) { Log.e(&quot;MainActivity&quot;, call + &quot;&quot; + t); }}); 打开模拟器，运行，你将看到以下错误： 1234567891003-18 04:03:24.546 7277-7277/com.youngfeng.androidclient D/NetworkSecurityConfig: No Network Security Config specified, using platform default03-18 04:03:24.574 7277-7277/com.youngfeng.androidclient W/System.err: java.net.SocketException: Permission denied03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at java.net.Socket.createImpl(Socket.java:454)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at java.net.Socket.getImpl(Socket.java:517)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at java.net.Socket.setSoTimeout(Socket.java:1108)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at okhttp3.internal.connection.RealConnection.connectSocket(RealConnection.java:238)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at okhttp3.internal.connection.RealConnection.connect(RealConnection.java:160)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at okhttp3.internal.connection.StreamAllocation.findConnection(StreamAllocation.java:257)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at okhttp3.internal.connection.StreamAllocation.findHealthyConnection(StreamAllocation.java:135)03-18 04:03:24.578 7277-7277/com.youngfeng.androidclient W/System.err: at okhttp3.internal.connection.StreamAllocation.newStream(StreamAllocation.java:114) 提示我们权限被拒绝，这是和iOS平台不一样的地方。如果你的应用需要使用网络，你需要在清单文件中手动指定使用网络权限。为此，我们在AndroidManifest.xml文件中添加如下配置： 1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 再次运行，一切正常。 注意：这里的service部分和服务端的service不一样，它只是Retrofit用于将网络接口分模块处理的一种手段，不要混淆。 上面说到，Android里面的AppCompatActivity就是MVC中的控制器，接下来我们就完成最重要的控制器以及UI部分编码。 a）创建LoginActivity以及布局文件activity_login.xml，在其onCreate方法中使用setContentView接口进行关联。 b）UI编程你相信吗？一旦你学会了一门新的技术，你的技能就会Double。 iOS UI部分我们使用了约束布局的方式完成了整体布局，Android是否也可以使用约束布局呢？答案是：当然可以。 事实上，Android官方也推荐使用这种布局方式进行页面布局。 切换到可视化布局模式，我们依然使用拖拽UI的方式完成整个布局，完整代码请参考文章最后的附录部分： PS：目前，Android端的约束布局相对iOS逊色不少，希望后面官方能够提供更多功能支持。 按照同样的方式完成注册页面和首页布局，UI部分开发完成后，尝试跳转到指定控制器。你会发现，出错了。这也是和iOS不一样的地方，Android端四大组件必须在清单文件中注册。具体是什么原因，请自行思考，这不是本文研究的重点。 因此，我们首先在清单文件中对所有控制器进行注册： 1234567891011121314&lt;activity android:name=&quot;.login.LoginActivity&quot; android:screenOrientation=&quot;portrait&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.MainActivity&quot; android:screenOrientation=&quot;portrait&quot;/&gt; &lt;activity android:name=&quot;.register.RegisterActivity&quot; android:screenOrientation=&quot;portrait&quot;/&gt; 然后，以登录为例，我们在控制器中完善登录逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class LoginActivity extends BaseActivity { private EditText mUsernameEdit; private EditText mPwdEdit; private Button mLoginBtn; private Button mRegisterBtn; @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); mUsernameEdit = findViewById(R.id.edit_username); mPwdEdit = findViewById(R.id.edit_pwd); mLoginBtn = findViewById(R.id.btn_login); mRegisterBtn = findViewById(R.id.btn_register); mLoginBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { login(mUsernameEdit.getText().toString(), mPwdEdit.getText().toString()); } }); mRegisterBtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(LoginActivity.this, RegisterActivity.class); startActivity(intent); } }); } private void login(String username, String pwd) { Retrofit retrofit = RetrofitManager.createDefault(); UserService userService = retrofit.create(UserService.class); Call&lt;HttpResponse&lt;User&gt;&gt; call = userService.login(username, pwd); showLoading(true); call.enqueue(new Callback&lt;HttpResponse&lt;User&gt;&gt;() { @Override public void onResponse(Call&lt;HttpResponse&lt;User&gt;&gt; call, Response&lt;HttpResponse&lt;User&gt;&gt; response) { showLoading(false); // 例子代码，暂时忽略空值判断 if(HttpResponse.CODE_SUCCESS != response.body().getCode()) { promptError(response.body().getMsg() + &quot;&quot;); } else { Intent intent = new Intent(LoginActivity.this, MainActivity.class); intent.putExtra(MainActivity.KEY_USER, response.body().getData()); startActivity(intent); finish(); } } @Override public void onFailure(Call&lt;HttpResponse&lt;User&gt;&gt; call, Throwable t) { showLoading(false); promptError(t.getMessage() + &quot;&quot;); } }); }} 至此，按照iOS的开发模式，我们完成了Android客户端的开发。与iOS不同的地方是，Android端控制器必须在清单文件中注册。程序员不能主动创建Activity，只能间接使用intent进行通信。而对于布局，两者都可以使用约束管理的方式完成。从这个角度来说，Android端和iOS端开发切换的难度还是比较低的。 距离全栈还差最后一步至此，我们已经完成了文章开头定下的目标。以MVC架构为基础，完成了服务端、iOS客户端、Android客户端编码。 然而，很多同学希望成为一个全栈工程师。按照现在的主流开发分支来说，成为一个全栈工程师，你还需要掌握Web前端开发。那么，问题来了，Web前端开发是否也是使用MVC架构呢？ 事实上，如果你使用 Angular，你应该早就习惯了MVC。而如果你偏爱React，你恐怕会搭配Redux，使用这种响应式的数据流框架编码。如果你使用Vue，你恐怕也会选择MVC或者MVVM架构。 如果你选择使用MVC，你依然可以按照类推的方式来学习。由于文章篇幅的原因，这部分就不予展示了。 编后说这篇文章我们以MVC为架构，从服务端编程开始，使用类推的方式依次完成了iOS客户端、Android客户端的开发。 有人可能会说，文章中的例子太简单，没有实际意义。事实上，在学习一门新技术的时候，就要从最基础的部分出发，建立对这门技术的最初印象。很多同学容易一开始就陷入细节当中无法自拔，产生的最直观的结果就是对新技术产生恐惧。因此，你常常可以看到一个程序员面对新东西骂娘，无怪乎。 其实，如果你慢慢进入到细节编程中，你会发现技术之间越来越多的相似性。这个时候你的积极性就会越来越高，编码也会更加得心应手。 我在学习一门新技术的时候，都是先从相似性开始。然后，再去攻克不同的部分。从不同的部分中去提炼相同的思想，这样在面对不同问题的时候，我始终可以使用同样的思想去解决。 当然，我想，你应该会说。虽然克服了框架问题，可是不同的编程语言千差万别。我们无法从一门语言快速过渡到另外一门语言，这在学习新技术的时候才是最大的拦路虎。 你说的很对，这恰好是下一个我想和你分享的问题。 扫描下方二维码，关注欧阳锋工作室，回复“相对论”抢先阅读相对论系列下一篇文章《技术相对论之编程语言》。 附录本篇例子完整代码：https://github.com/yuanhoujun/it-theory-of-relativityIntelliJ IDEA下载地址：https://www.jetbrains.com/idea/Tomcat下载地址：http://tomcat.apache.org/iOS开发者官网：https://developer.apple.com/Android开发者官网：https://developer.android.com/index.html","link":"/2018/03/19/comprehensive article/技术相对论之软件架构/"}],"tags":[{"name":"创业","slug":"创业","link":"/tags/创业/"},{"name":"深圳一行代码科技有限公司","slug":"深圳一行代码科技有限公司","link":"/tags/深圳一行代码科技有限公司/"},{"name":"十分简历","slug":"十分简历","link":"/tags/十分简历/"},{"name":"2017","slug":"2017","link":"/tags/2017/"},{"name":"总结","slug":"总结","link":"/tags/总结/"},{"name":"欧阳锋","slug":"欧阳锋","link":"/tags/欧阳锋/"},{"name":"关注","slug":"关注","link":"/tags/关注/"},{"name":"工作室","slug":"工作室","link":"/tags/工作室/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"Kotlin基础","slug":"Kotlin基础","link":"/tags/Kotlin基础/"},{"name":"视频教程","slug":"视频教程","link":"/tags/视频教程/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"扩展","slug":"扩展","link":"/tags/扩展/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"编程语言","slug":"编程语言","link":"/tags/编程语言/"},{"name":"滑动返回","slug":"滑动返回","link":"/tags/滑动返回/"},{"name":"开源","slug":"开源","link":"/tags/开源/"},{"name":"泛型","slug":"泛型","link":"/tags/泛型/"},{"name":"代理模式","slug":"代理模式","link":"/tags/代理模式/"},{"name":"代理属性","slug":"代理属性","link":"/tags/代理属性/"},{"name":"延迟加载","slug":"延迟加载","link":"/tags/延迟加载/"},{"name":"Groovy","slug":"Groovy","link":"/tags/Groovy/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"脚本","slug":"脚本","link":"/tags/脚本/"},{"name":"Bug","slug":"Bug","link":"/tags/Bug/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"操作符","slug":"操作符","link":"/tags/操作符/"},{"name":"重载","slug":"重载","link":"/tags/重载/"},{"name":"infix","slug":"infix","link":"/tags/infix/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"设计模式","slug":"设计模式","link":"/tags/设计模式/"},{"name":"动态代理","slug":"动态代理","link":"/tags/动态代理/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"版本控制工具","slug":"版本控制工具","link":"/tags/版本控制工具/"},{"name":"开发工具","slug":"开发工具","link":"/tags/开发工具/"},{"name":"命令行","slug":"命令行","link":"/tags/命令行/"},{"name":"相对论","slug":"相对论","link":"/tags/相对论/"},{"name":"编程","slug":"编程","link":"/tags/编程/"}],"categories":[{"name":"创业札记","slug":"创业札记","link":"/categories/创业札记/"},{"name":"关于欧阳锋","slug":"关于欧阳锋","link":"/categories/关于欧阳锋/"},{"name":"随文杂记","slug":"随文杂记","link":"/categories/随文杂记/"},{"name":"IT小知识","slug":"IT小知识","link":"/categories/IT小知识/"},{"name":"Kotlin","slug":"Kotlin","link":"/categories/Kotlin/"},{"name":"开源","slug":"开源","link":"/categories/开源/"},{"name":"基础知识","slug":"Kotlin/基础知识","link":"/categories/Kotlin/基础知识/"},{"name":"杂谈","slug":"Kotlin/杂谈","link":"/categories/Kotlin/杂谈/"},{"name":"Bug Fix","slug":"Bug-Fix","link":"/categories/Bug-Fix/"},{"name":"设计模式","slug":"设计模式","link":"/categories/设计模式/"},{"name":"开发工具","slug":"开发工具","link":"/categories/开发工具/"},{"name":"Git","slug":"开发工具/Git","link":"/categories/开发工具/Git/"}]}