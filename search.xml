<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>巧解约瑟夫环问题</title>
    <url>/2019/11/17/%E5%B7%A7%E8%A7%A3%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>100个小孩手拉手围成一圈，从第1个小孩开始报数，数到3出列，下一个小孩继续从1开始报数，循环报数，求最后留在队列中的小孩的位置。</p>
</blockquote>
<p>这是一道非常经典的算法题，我在面试的时候经常提到这道题。这道题是完全可以通过正向思维解答的，但遗憾的是，在所有面试的人中，几乎没有一个人可以正确地解答这道题。</p>
<a id="more"></a>
<p>那么，到底要如何解答这道题呢，我们一起来试试看！</p>
<h3 id="解法一：生死看淡，不服就干"><a href="#解法一：生死看淡，不服就干" class="headerlink" title="解法一：生死看淡，不服就干"></a>解法一：生死看淡，不服就干</h3><p>首先，我们尝试用正向思维解答，我们用一个集合模拟100个人，集合中的值记录的是原来队列中人物的索引（从0开始）。为了保证函数的通用性，我们用n表示队列中的人数，m表示出列的位置：</p>
<p><strong>本篇文章我们使用Java语言进行讲解，如果你想看其它语言的实现，请在微信公众号”欧阳锋工作室“给我留言</strong></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> f(<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    <span class="comment">// 这里用一个集合模拟队列</span></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计数器，记录报数序号</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前循环的队列位置索引</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">count</span> ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里还要注意一个问题，如果报数来到了队列尾部，我们需要从第一个人继续往下报数</span></span><br><span class="line">        <span class="comment">// 因此这里的索引计数器需要归0</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= list.size()) &#123;</span><br><span class="line">            <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 接下来开始循环报数，将序号为m的人移出队列</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> &gt;= m) &#123;</span><br><span class="line">            <span class="comment">// 移出队列，同时计数器归0</span></span><br><span class="line">            list.remove(<span class="keyword">index</span>);</span><br><span class="line">            <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">index</span> ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上这种解法是最容易被想到的方法，问题是：这样做正确吗？</p>
<p>很显然不对！这里忽略了一个问题，一旦队列中有人被移出队列，队列的索引就会发生变化。举个例子，假设第3个人被移除，正常来说，下一个人的索引应该是4。而实际上，这个人的索引依然是3，因为索引计数是连续的。被移除的人索引也会消失，后面所有人的索引都会往前移动一位。</p>
<p>这是上述解法最容易出现的问题，知道了问题的根源，我们将代码继续改进。</p>
<p>我们在上述代码的第28行后面增加一行代码，人物出列后主动将索引值减一：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接下来开始循环报数，将序号为m的人移出队列</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">count</span> &gt;= m) &#123;</span><br><span class="line">    <span class="comment">// 移出队列，同时计数器归0</span></span><br><span class="line">    list.remove(<span class="keyword">index</span>);</span><br><span class="line">    <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里的索引要减1</span></span><br><span class="line">    <span class="keyword">index</span> --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后，我们尝试运行以上代码，将100与3的值传入到函数中，运行得到结果90，答案是正确的。</p>
<h3 id="解法二：死生不惧，一往直前"><a href="#解法二：死生不惧，一往直前" class="headerlink" title="解法二：死生不惧，一往直前"></a>解法二：死生不惧，一往直前</h3><p>直给的解题方式，除了上述解法之外，还有一种常见的解法，就是不管三七二十一，一路循环，直至输出结果。</p>
<p>这种解法同样需要构建用户队列，只是队列的形式发生了变化，我们使用一个长度为n的Boolean数组构建用户队列。</p>
<p>这种解法的完整代码如下：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> f(<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    Boolean[] arr = <span class="keyword">new</span> Boolean[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        arr[i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中还剩余的人数</span></span><br><span class="line">    <span class="keyword">int</span> leftCount = arr.length;</span><br><span class="line">    <span class="comment">// 计数器，记录报数序号</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前循环的队列位置索引</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (leftCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[<span class="keyword">index</span>]) &#123;</span><br><span class="line">            <span class="keyword">count</span>++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> == m) &#123;</span><br><span class="line">            arr[<span class="keyword">index</span>] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">            leftCount --;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">index</span> ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里同样需要处理计数到达队列尾部的情况</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">index</span> &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">index</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i]) &#123;</span><br><span class="line">            result = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解法相对于第一种解法来说，时间复杂度更高，循环次数更多，循环次数差不多是第一种解法的3到5倍，甚至更多。但相对第一种解法，这种解法更容易被人接受，也无需考虑索引的变化。在面试中，如果你想不到任何一种解法，我推荐你使用这种解法。</p>
<h3 id="解法三：巧用链表，场景还原"><a href="#解法三：巧用链表，场景还原" class="headerlink" title="解法三：巧用链表，场景还原"></a>解法三：巧用链表，场景还原</h3><p>分析考题，我们不难发现，这似乎是我们非常熟悉的链表结构。在第三种解法中，我们尝试使用链表模拟这个用户队列，看看能否带给我们一些惊喜。</p>
<p>由于始终使用单向报数，我们就用一个单向链表来模拟这个数据结构：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里用Child类来模拟每一个参与的小孩，其中的value值保存的是当前用户的索引</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Child</span> &#123;</span><br><span class="line">    <span class="comment">// 简单起见，这里我们全部使用public</span></span><br><span class="line">    <span class="keyword">public</span> Child next;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span>(<span class="params"><span class="keyword">int</span> <span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> f(<span class="keyword">int</span> n, <span class="keyword">int</span> m) &#123;</span><br><span class="line">    Child head = <span class="keyword">new</span> Child(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Child current = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        Child child = <span class="keyword">new</span> Child(i);</span><br><span class="line">        current.<span class="keyword">next</span> = child;</span><br><span class="line">        current = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了构建首尾相接的链表，这里我们主动将尾节点与头结点连接起来</span></span><br><span class="line">    <span class="comment">// 当前节点恰好指向尾节点</span></span><br><span class="line">    current.<span class="keyword">next</span> = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来再移动一次指针，让current指向头节点</span></span><br><span class="line">    <span class="comment">// 为了方便获取前一个节点，这里我们用一个变量表示前一个节点</span></span><br><span class="line">    Child prev = current;</span><br><span class="line">    current = current.<span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义计数器</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一旦收尾相接，当前节点指向了自身，证明队列中只有一个用户了，跳出循环，游戏结束</span></span><br><span class="line">    <span class="keyword">while</span> (current.<span class="keyword">next</span> != current) &#123;</span><br><span class="line">        <span class="keyword">count</span> ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">count</span> == m) &#123;</span><br><span class="line">            prev.<span class="keyword">next</span> = current.<span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">count</span> = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev = current;</span><br><span class="line">        current = current.<span class="keyword">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> current.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是这种解法的完整代码，代码中包含了每一行代码的详细解释。在这个解法中，我们利用链表模拟了人物队列，通过控制当前用户的指针移动来模拟报数。最终，当用户的下一个用户指针指向自己的时候跳出循环，游戏结束，当前用户就是队列中剩余的最后一个用户。</p>
<p>这种解法相对于上面两种解法来说更容易理解，并且这种解法的时间复杂度不高，循环次数与第一个解法的循环次数一致。目前来说，他是在所有的解法中是最优的。</p>
<p>那么，是否还有更好的解法呢？</p>
<h3 id="解法四：数学大法，九九归一"><a href="#解法四：数学大法，九九归一" class="headerlink" title="解法四：数学大法，九九归一"></a>解法四：数学大法，九九归一</h3><p>计算机科学离不开数学！最后，我们一起来试试看，尝试利用数学的武器更加巧妙地解决这个问题。由于这是一个规律性的动作，我们可以肯定，这应该有一个固定的数学规律。</p>
<p>但现在的问题是，如何找到这个规律呢？这似乎不太容易。</p>
<p>这里我们先假设总人数为<code>n</code>，报数为<code>m</code>的人出列，用<code>f(n, m)</code>表示最终留在队列中的人的位置。</p>
<p>为了便于大家理解，我们先来看一个实际的例子，假设n=5, m=3, 即队列中只有5个人，报数为3的人出列。</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">第一轮报数，位置为<span class="number">3</span>的人出列</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, x, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">出列后，从<span class="number">4</span>开始报数，我们将开始报数的人挪到第一位，剩下的人按照报数的顺序往后排，得到一个新的队列：</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">从这里，我们开始第二轮报数，这一轮报数位置为<span class="number">1</span>的人出列</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, x, <span class="number">2</span>]</span><br><span class="line">我们继续按照上面的方式，转换队列，重新第三轮报数：</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>] =&gt; [<span class="number">2</span>, <span class="number">4</span>, x]</span><br><span class="line">第四轮：</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>] =&gt; [x, <span class="number">4</span>]</span><br><span class="line">第五轮：</span><br><span class="line">[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>以上就是<code>n = 5, m = 3</code>的情况下完整的报数情况，接下来我们仅关注第一次报数发生的变化。</p>
<p>第一轮报数完成后，队列由[1, 2, 3, 4, 5]转换成了[4, 5, 2, 1]。</p>
<ul>
<li>队列一：[1, 2, 3, 4, 5]</li>
<li>队列二：[4, 5, 1, 2]</li>
</ul>
<p>注意看，如果我们不去关注队列中人物的位置，仅关注队列本身。这两个队列有什么关系？</p>
<ul>
<li>两个队列都是从1开始报数</li>
<li>两个队列人数仅仅相差1</li>
</ul>
<p>这里很微妙，这其实可以看做数量为5的人物队列，与数量为4的人物队列。如果我们用<code>Q</code>表示队列的话，第一个队列可以用<code>Q(5)</code>表示，第二个队列可以用<code>Q(4)</code>来表示，<code>Q(4)</code>实际上是<code>Q(5)</code>的子队列。</p>
<p>在这两个队列中，还有两个干扰项 [1, 2], 为了排除干扰，我们将他们改成 [6, 7], 即：</p>
<ul>
<li>队列一：[1, 2, 3, 4, 5]</li>
<li>队列二：[4, 5, 6, 7]</li>
</ul>
<p>这个时候队列<code>Q(5)</code>与<code>Q(4)</code>产生了一定的关系，同等位置处的索引值恰好相差3（其实就是m的值，为什么是m呢？大家可以自行思考一下）。</p>
<p>接下来，我们关注第二个队列的第一轮报数，报数为3的人出列，也就是队列二中的6。那么，TA在原来队列中的位置到底是什么呢？答案是1，实际就是将<code>6 % 5</code>进行取模得到的值。</p>
<p>这里似乎有一个固定的规律，即：假设队列2第一轮报数出列的人在队列2中的位置是x2, 在队列1中的位置是x1, x2与x1应该存在下面这个关系：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">x<span class="number">1</span> = <span class="comment">(x2 + 3)</span> <span class="meta">%</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>第一轮报数等式成立，那么第二轮报数是否成立呢？一直到剩余最后一个人是否成立呢？答案是：当然成立。</p>
<p>由此，我们可以猜测<code>f(n, m)</code>与<code>f(n, m - 1)</code>存在下面这样的关系：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">f(<span class="built_in">n</span>, m) = (f(<span class="built_in">n</span> - <span class="number">1</span>, m) + m) % <span class="built_in">n</span></span><br></pre></td></tr></table></figure>
<p>为了加深大家的理解，我们将转换过程用图片再一次展示给大家看：</p>
<p><img src="/2019/11/17/巧解约瑟夫环问题/transform.png" alt=""></p>
<p>以上就是队列长度为n，第一次报数为m的用户出列后将n-1的其他人转换到n-1的子队列的过程。</p>
<p>由此可以得出结论，这里的转换是普适的，以上的公式适用于所有情况。</p>
<p>上述公式中，我们没有考虑当前队列中只有一个人的情况，这里我们将其补全，得到下面的递推公式：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">f(<span class="built_in">n</span>, m) = <span class="number">0</span> (<span class="built_in">n</span> = <span class="number">1</span>)</span><br><span class="line">f(<span class="built_in">n</span>, m) = (f(<span class="built_in">n</span> - <span class="number">1</span>, m) + m) % <span class="built_in">n</span> (<span class="built_in">n</span> &gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>得到上述递推公式之后，问题就变得简单了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (f(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>换成三目运算符，我们甚至可以使用一行代码解答这个问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> ? <span class="number">0</span> : (f3(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>以上就是”约瑟夫环问题“的常见几种解法，算法效率最高的解法是第四种，其次是第一种与第三种，第二种解法效率最差，但最容易想到。尽管通过数学归纳法可以最高效地解答这个问题，但我仍然推荐第三种解法，这种解法最符合计算机思维。同时，算法复杂度也不高。但如果在高度要求性能的程序中，当然毫无疑问，解法四是你的最优选择。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个问题解答的过程中，我们用到了链表，链表是一种非常常见的数据结构。可能你经常在用，但并不了解。链表问题经常出现在算法中，如果你希望对链表进一步深入了解，请关注公众号”欧阳锋工作室“，下一篇文章我们讲一讲与链表相关的那些算法题。</p>
<p><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>约瑟夫环</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年年终总结</title>
    <url>/2023/01/22/2022%E5%B9%B4%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2022年对我来说，是很重要的一年！</p>
<p>2月13号，我发布了我的第一款使用Flutter开发开源的跨平台手机助手软件AirController。目前，已获得397 stars。</p>
<p>10月6号，我发布了我的第一款用于象棋学习的跨平台商业软件象棋助手。目前，已实现全平台覆盖，在Windows、macOS、Linux、Android、iOS、网页端均可以运行。</p>
<p>这些对我来说，都不容易，从最初对Flutter的不熟悉，到现在的轻车熟路，鬼知道我付出了多少。</p>
<p>在此之前，我不敢想象，我可以坚持独立完成如此复杂的程序。可我做到了，我相信，我想要的东西，已经离我越来越近了。</p>
<p>在这一年里，我完全放弃了社交，把自己关在了屋子里，专心做自己的事情。</p>
<p>我第一次想明白了一件事情，你的大部分朋友对你是没有用的。为什么这些人会成为你的朋友，是因为他们与你是一样的高度，甚至大多数还不及你的高度。在这种情况下，他们无法给予你支持，也无法看懂你的决定。</p>
<p>甚至，很多情况下，因为看不懂还要反驳你的决定，这种情况下，反而不利于你的发展。因此，我毅然决然地断开了所有朋友的联系。</p>
<p>我知道，这是一个完全正确地决定。事实上也是如此，在奋斗的路上，我并没有听到一句，哪怕是简单的一句鼓励“哥们，加油！”。</p>
<p>没有，真的没有！</p>
<p>过去的9年工作经历，我也期待着能够看懂我的计划，跟我一样积极向上、追求梦想的人，遗憾的是，真的没有碰到。几乎100%沉浸在打工的快乐当中，他们认为人生下来就是给人打工的。只不过是进好厂与差厂的区别 ，他们的梦想就是进入BAT这样的企业，期待着早日月入百万。</p>
<p>实际上，这样思考完全没有问题，有问题的是，他们不能接受与他们想法迥异的人。对待新事物、新的想法，抱有批判态度，这就有点问题了。我想，如果我身边有一个像我一样一直在努力追求梦想的人，我打心里会替他高兴吧。</p>
<p>能够完成这两个项目的独立研发，很大程度上取决于我上面的决定，这让我可以静下心思考如何去做一款产品，如何做一款真正让用户喜欢的产品。</p>
<p>收获之余，当然也有一些做的不好的地方，应该批评改进。</p>
<p>第一个问题，在遇到问题的时候，如果问题很难啃，我常常会停下来下下棋、看看视频再继续，这导致当天可用时间大大缩小。实际上，不妨放开，等简单问题处理完再来啃或许更好。</p>
<p>另外，运动还是太少，由于长期集中精力进行产品研发，导致运动时间几乎为0，身体退步明显。</p>
<p>还有一个遗憾，英语口语未能达成既定目标。</p>
<p>的确，口语和听力水平均有不同程度提升，但提升的幅度仍然不够。目前，还不能流畅地与老外进行沟通。这与我平时没有认真对待有很大的关系，期望2023年能够弥补这个遗憾。</p>
<p>2023年，我的年度关键词“Making money”，如果能够结束单身，就更好了。</p>
<p>2023年，我祝自己好运！</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>深入链表数据结构，助你搞定链表算法题</title>
    <url>/2019/11/18/%E6%B7%B1%E5%85%A5%E9%93%BE%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%8C%E5%8A%A9%E4%BD%A0%E6%90%9E%E5%AE%9A%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>在上一篇文章<a href="http://youngfeng.com/2019/11/17/%E5%B7%A7%E8%A7%A3%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98/">《巧解约瑟夫环问题》</a>中，我们提到了<strong>链表</strong>。部分同学可能对链表的数据结构还不太熟悉。今天，我们就一起来尝试手写一个链表类实现。然后，再一起来看一看与链表相关的那些算法题。</p>
</blockquote>
<a id="more"></a>
<p><strong>本篇文章我们依然使用Java语言实现，如果你对其它语言的实现感兴趣，请在微信公众号”欧阳锋工作室“中给我留言</strong></p>
<p>常见的线性链表分为两种：<strong>单向链表</strong>与<strong>双向链表</strong>。所谓单向链表，即链表只能通过单向访问，从上一个节点可以访问到下一个节点，而下一个节点不能逆向访问到上一个节点。双向链表则没有这个限制，它既可以从上一个节点访问到下一个节点，也可以从下一个节点访问到上一个节点。</p>
<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>我们先来尝试实现一个单向链表，一个完整的单向链表数据结构如下图所示：</p>
<p><img src="/2019/11/18/深入链表数据结构，助你搞定链表算法题/unidirectionLink.png" alt=""></p>
<p>链表中的每一个元素称之为链表的<strong>节点</strong>，开始的<strong>节点</strong>叫做<strong>头节点</strong>，结束的<strong>节点</strong>叫做<strong>尾节点</strong>。</p>
<p>在单向链表中，节点中应该至少包含两个元素：数据（value）以及指向下一个节点的指针（next）。</p>
<p>参照上图，我们先构建节点数据结构：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">// 为了保证通用性，这里我们使用</span><br><span class="line">// 泛型参数表示节点数据的数据类型</span><br><span class="line">public class <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; &#123;</span><br><span class="line">    public E value;</span><br><span class="line">    public <span class="keyword">Node</span><span class="title">&lt;E</span>&gt; next;</span><br><span class="line">    </span><br><span class="line">    public <span class="keyword">Node</span><span class="title">(E</span> value) &#123;</span><br><span class="line">        this.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们创建链表集合类，新增主要的增删改查等相关方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;E&gt; &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E e)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于是单向链表，这里我们只保存头节点的引用：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> LinkedList&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="comment">// 始终指向最新添加的节点</span></span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; current;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add(E e) &#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">        <span class="comment">// 第一次添加，将头节点指向该元素</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            current = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current.<span class="keyword">next</span> = node;</span><br><span class="line">            current = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size</span> ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> remove(E e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前元素恰好是头节点，直接将头节点置空</span></span><br><span class="line">        <span class="keyword">if</span> (e == head.value) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">size</span> --;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		  </span><br><span class="line">		 <span class="comment">// 由于我们已知的信息只有头节点，我们必须通过</span></span><br><span class="line">		 <span class="comment">// 遍历找到对应的节点，这就是为什么说List的查询</span></span><br><span class="line">		 <span class="comment">// 效率比LinkedList效率高的原因</span></span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        Node&lt;E&gt; <span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">next</span>.value == e) &#123;</span><br><span class="line">                prev.<span class="keyword">next</span> = <span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">size</span> --;</span><br><span class="line">                <span class="comment">// 这里要注意，如果当前节点恰好是被移除的节点</span></span><br><span class="line">                <span class="comment">// 需要将当前节点的值指向上一个节点</span></span><br><span class="line">                <span class="keyword">if</span> (current == <span class="keyword">next</span>) &#123;</span><br><span class="line">                    current = prev;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">next</span> = <span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> set(<span class="keyword">int</span> index, E e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Valid index 0 ~ "</span> + (<span class="keyword">size</span> - <span class="number">1</span>) + <span class="string">", current: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; current = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == i) &#123;</span><br><span class="line">                current.value = e;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = current.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E get(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Valid index 0 ~ "</span> + (<span class="keyword">size</span> - <span class="number">1</span>) + <span class="string">", current: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; current = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == i) &#123;</span><br><span class="line">                <span class="keyword">return</span> current.value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = current.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是单向链表的完整代码了，解题的关键在于你需要在脑海里构建链表的数据结构模型，需要弄清楚节点之间是如何连接在一起的，只要搞清楚了这些关系，问题也就引刃而解了。</p>
<p>按照同样的思路，接下来我们开始尝试实现双向链表。</p>
<p>双向链表与单向链表不一样的地方在于，节点还需要持有上一个节点的引用。对应的数据模型可以用下面的图形来表示:</p>
<p><img src="/2019/11/18/深入链表数据结构，助你搞定链表算法题/bidirectionLink.png" alt=""></p>
<p>可以看到，在上面的图形中，我们使用<code>last</code>引用指向上一个节点。同时，增加了一个尾节点引用<code>tail</code>，方便逆向遍历。</p>
<p>按照上面的数据模型，完整代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 双向链表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> LinkedList&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; head;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;E&gt; tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> add(E e) &#123;</span><br><span class="line">        Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) &#123;</span><br><span class="line">            head = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tail.<span class="keyword">next</span> = node;</span><br><span class="line">            tail = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size</span> ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> remove(E e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == head) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前元素恰好是头节点，直接将头节点置空</span></span><br><span class="line">        <span class="keyword">if</span> (e == head.value) &#123;</span><br><span class="line">            head = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">size</span> --;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; prev = head;</span><br><span class="line">        Node&lt;E&gt; <span class="keyword">next</span> = head.<span class="keyword">next</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">next</span>.value == e) &#123;</span><br><span class="line">                prev.<span class="keyword">next</span> = <span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">                <span class="keyword">size</span> --;</span><br><span class="line">                <span class="comment">// 如果当前节点恰好是尾节点，需要将尾节点上移一位</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">next</span> == tail) &#123;</span><br><span class="line">                    tail = prev;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            prev = <span class="keyword">next</span>;</span><br><span class="line">            <span class="keyword">next</span> = <span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> set(<span class="keyword">int</span> index, E e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Valid index 0 ~ "</span> + (<span class="keyword">size</span> - <span class="number">1</span>) + <span class="string">", current: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; current = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == i) &#123;</span><br><span class="line">                current.value = e;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = current.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E get(<span class="keyword">int</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">size</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Valid index 0 ~ "</span> + (<span class="keyword">size</span> - <span class="number">1</span>) + <span class="string">", current: "</span> + index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; current = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index == i) &#123;</span><br><span class="line">                <span class="keyword">return</span> current.value;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = current.<span class="keyword">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> <span class="keyword">size</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的文章中，我们动手编写了单向链表与双向链表的代码实现。接下来，我们一起来看一下与链接相关的那些算法题吧。</p>
<h3 id="问题一：有一个单向链表，如何快速获取链表中倒数第5个元素"><a href="#问题一：有一个单向链表，如何快速获取链表中倒数第5个元素" class="headerlink" title="问题一：有一个单向链表，如何快速获取链表中倒数第5个元素"></a>问题一：有一个单向链表，如何快速获取链表中倒数第5个元素</h3><p>这个问题可以使用两个指针p1、p2，p2先走5步，指向第6个节点。然后两个指针开始同步出发，一直到p2指向尾节点，p1恰好指向倒数第5个元素。</p>
<p>这个方法可以通过一次循环就获取到倒数第5个元素，时间复杂度最低，完整代码如下：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">public</span> void f(Node head) &#123;</span><br><span class="line">	Node <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">	Node <span class="built_in">p2</span> = head<span class="comment">;</span></span><br><span class="line">	</span><br><span class="line">	int i = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">	<span class="meta">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">		i ++<span class="comment">;</span></span><br><span class="line">		<span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">while</span> (<span class="built_in">p2</span> != null) &#123;</span><br><span class="line">		<span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">		<span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="built_in">p1</span>.value)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题二：判断一个链表中有环，请给出判断方法"><a href="#问题二：判断一个链表中有环，请给出判断方法" class="headerlink" title="问题二：判断一个链表中有环，请给出判断方法"></a>问题二：判断一个链表中有环，请给出判断方法</h3><p>这个问题可以使用一个经典的解法“快慢指针”的方式解决。</p>
<p>所谓的“快慢指针”，即同时使用两个指针p1、p2同步前进，p2的速度比p1快。这样就形成了“一快一慢”的效果，因此，我们将其称之为“快慢指针”。“快慢指针”在链表的算法题中起着关键性的作用，常常能够让很多看似复杂的问题简单化。例如，这个问题我们就可以通过“快慢指针”的方式解决。</p>
<p>具体要怎么做呢？我们一起来看一下。</p>
<p><img src="/2019/11/18/深入链表数据结构，助你搞定链表算法题/ringLink.png" alt=""></p>
<p>假设有一个如上图所示的单向链表，链表中仅有5个元素，3、4、5形成了一个环。</p>
<p>想象一下，如果我们使用两个指针p1、p2，我们让p1、p2同时出发，但p1每次只向前移动一个节点，而p2每次向前移动两个节点，两者有可能相遇吗？</p>
<p>在没有环的情况下，很显然一定不会相遇，但在有环的情况下，一定会相遇。因为当两者同时进入链表环中时，如果有一个指针快，一个指针慢，当两者的步数差恰好是一个环的大小时二者就相遇了，这跟时钟的时针和分针一定会相遇是一样的道理。</p>
<p>按照这个思路，判断链表是否有环的完整代码如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public boolean hasRing(<span class="keyword">Node</span> <span class="title">head</span>) &#123;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">p1</span> = head;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">p2</span> = head;</span><br><span class="line">	</span><br><span class="line">	while (p2 != null &amp;&amp; p2.next != null) &#123;</span><br><span class="line">		p1 = p1.next;</span><br><span class="line">		p2 = p2.next.next;</span><br><span class="line">		</span><br><span class="line">		if (p1 == p2) &#123;</span><br><span class="line">			return <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此可见，“快慢指针”的确是一个非常有效的解决方案，在上述两个问题的解答中就起到了决定性的作用。大家一定要牢记这个解决方案，以便面试官问到相关的问题的时候能够迅速脱口而出。</p>
<h3 id="问题三：假设一个链表中存在环，请求出环的大小"><a href="#问题三：假设一个链表中存在环，请求出环的大小" class="headerlink" title="问题三：假设一个链表中存在环，请求出环的大小"></a>问题三：假设一个链表中存在环，请求出环的大小</h3><p>问题二中我们可以知道一个链表中是否存在环，但如何知道这个环的大小呢。</p>
<p>我们继续回想时针与分针相遇的原理，分针比时针快，从第一次相遇开始，分针走的快，继续往前走，为了再次追上时针，分针应该至少多走一圈。因此，第二次相遇时分针和时针所在的距离差恰好就是环的大小。</p>
<p>按照这个原理，获取链表环大小的完整代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> getRingSize(Node head) &#123;</span><br><span class="line">	Node p1 = head;</span><br><span class="line">	Node p2 = head;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">size</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 标记是否已经出现第一次相遇</span></span><br><span class="line">	<span class="keyword">int</span> hasMeeted = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (p2 != <span class="keyword">null</span> &amp;&amp; p2.<span class="keyword">next</span> != <span class="keyword">null</span>) &#123;</span><br><span class="line">		p1 = p1.<span class="keyword">next</span>;</span><br><span class="line">		p2 = p2.<span class="keyword">next</span>.<span class="keyword">next</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (hasMeeted) &#123;</span><br><span class="line">			<span class="keyword">size</span> += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (p1 == p2) &#123;</span><br><span class="line">			<span class="comment">// 再次相遇发现hasMeeted为true</span></span><br><span class="line">			<span class="comment">// 表示已经是第二次相遇了，直接跳出循环</span></span><br><span class="line">			<span class="keyword">if</span> (hasMeeted) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			hasMeeted = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">size</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题四：有一个单向链表，请从尾到头打印该链表数据"><a href="#问题四：有一个单向链表，请从尾到头打印该链表数据" class="headerlink" title="问题四：有一个单向链表，请从尾到头打印该链表数据"></a>问题四：有一个单向链表，请从尾到头打印该链表数据</h3><p>从尾到头打印链表有点像栈的数据结构模型。因此，这里我们可以使用一个栈去保存链表中的所有节点，然后pop栈顶元素，打印即可。但这不仅增加了一定的空间复杂度，也增加了一定的时间复杂度。</p>
<p>这个问题无非就是打印链表中的值而已，如果我们能够按照栈调用的方式对其进行调用，问题不就迎刃而解了吗。</p>
<p>递归恰好就是一个栈调用的方式，因此，我们完全可以使用递归巧妙地解决这个问题。</p>
<p>以下是使用递归调用反向打印链表数据的完整代码：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public void printReverse(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">	if (<span class="keyword">node</span> <span class="title">!= null</span>) &#123;</span><br><span class="line">		printReverse(<span class="keyword">node</span>.<span class="title">next</span>);</span><br><span class="line">		System.out.println(<span class="keyword">node</span>.<span class="title">value</span>);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题五：有一个单向链表，求链表的中间节点"><a href="#问题五：有一个单向链表，求链表的中间节点" class="headerlink" title="问题五：有一个单向链表，求链表的中间节点"></a>问题五：有一个单向链表，求链表的中间节点</h3><p>这个问题初看起来似乎有点眼熟，是的，没错！它跟问题一比较像。在问题一中我们需要找到倒数第5个节点，而在这个问题中，我们需要找到链表的中间节点。</p>
<p>但这个问题的难点在于如何保证其中较慢的指针恰好停留在中间节点的位置。</p>
<p>其实，这很简单，我们依然可以使用“快慢指针”的方式进行处理。只要设置快指针每次走两步，而慢指针每次走一步即可。完整代码如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public void findMidNode(<span class="keyword">Node</span> <span class="title">head</span>) &#123;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">p1</span> = head;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">p2</span> = head;</span><br><span class="line">	</span><br><span class="line">	while (p2 != null &amp;&amp; p2.next != null) &#123;</span><br><span class="line">		p1 = p1.next;</span><br><span class="line">		p2 = p2.next.next;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 这里的p1节点恰好就是中间节点</span><br><span class="line">	System.out.println(p1.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题六：反转链表"><a href="#问题六：反转链表" class="headerlink" title="问题六：反转链表"></a>问题六：反转链表</h3><p>示例：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line"><span class="number">5</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>按照正常思维，反转链表，我们需要将链表的值先保存起来，然后再构建新的链表，再逐一连接起来。</p>
<p>但实际上，上面的动作其实我们可以同步进行，具体思路如下：</p>
<p>1）声明变量prev、curr分别指向前一个节点、当前遍历节点。</p>
<p>2）如果当前节点不为空，则先设置临时变量next指向curr的下一个节点。</p>
<p>3）让curr的下一个节点指向pre，然后再让pre指向当前节点curr, 最后让当前节点curr指向next。</p>
<p>4）重复以上过程，判断条件是当前节点curr不为空。</p>
<p>完整代码如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">public void reverseLink(<span class="keyword">Node</span> <span class="title">head</span>) &#123;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">prev</span> = null;</span><br><span class="line">	<span class="keyword">Node</span> <span class="title">curr</span> = head;</span><br><span class="line">	</span><br><span class="line">	while (null != curr) &#123;</span><br><span class="line">		<span class="keyword">Node</span> <span class="title">next</span> = curr.next;</span><br><span class="line">		curr.next = prev;</span><br><span class="line">		</span><br><span class="line">		prev = curr;</span><br><span class="line">		curr = next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题七：如果链表中存在环，求环的入口节点"><a href="#问题七：如果链表中存在环，求环的入口节点" class="headerlink" title="问题七：如果链表中存在环，求环的入口节点"></a>问题七：如果链表中存在环，求环的入口节点</h3><p>这道题似乎依然可以用“快慢指针”的方式解决，但问题是：如何让指针相遇的点恰好落在环的入口处呢，这似乎是一个难题。</p>
<p>我们继续沿用问题二中的图：</p>
<p><img src="/2019/11/18/深入链表数据结构，助你搞定链表算法题/ringLink2.png" alt=""></p>
<p>在问题二中我们使用了两个指针p1、p2，p1每次前进一步，p2每次前进两步，如果两者相遇，则说明链表中有环。</p>
<p>上图中整个链表只有5个元素，链表的入口节点是3，p1、p2指针第一次相遇的节点位置是4。在这个位置，p2所走的距离恰好比p1多出一个环的距离。</p>
<p>这是按照问题二中的设计思路推算出来的相遇节点，接下来我们的难点是尝试找到一种方法让指针恰好在入口位置处相遇。</p>
<p><img src="/2019/11/18/深入链表数据结构，助你搞定链表算法题/ringLink3.png" alt=""></p>
<p>这里我们假设：</p>
<p>1）头节点距离入口节点的节点数是<code>a</code></p>
<p>2）指针第一次相遇的位置距离入口节点的节点数是<code>b</code></p>
<p>3）相遇位置节点走到入口节点的节点数是<code>x</code></p>
<p>4）环的节点数是<code>r</code></p>
<p>如果p1指针走过的距离是<code>s</code>，那么p2指针走过的距离应该是<code>2s</code>（p2指针的速度是p1的两倍）。观察上图，我们得到如下的等式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">s = <span class="selector-tag">a</span> + b</span><br><span class="line"><span class="number">2s</span> = <span class="selector-tag">a</span> + <span class="selector-tag">b</span> + r</span><br></pre></td></tr></table></figure>
<p>等式二减去等式一得到<code>s = r</code>。</p>
<p>由此我们可以知道，第一次相遇的时候，指针p1恰好走过了一个环的距离。</p>
<p>继续观察上图，可以得到<code>r = b + x</code>。</p>
<p>由此我们得到几种非常重要的公式：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">s</span> = a + b</span><br><span class="line"><span class="attr">s</span> = r</span><br><span class="line"><span class="attr">r</span> = b + x</span><br></pre></td></tr></table></figure>
<p>结合上述三个等式，去掉b、s，最终得到：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">x</span> = a</span><br></pre></td></tr></table></figure>
<p>这说明一个问题：<strong>从相遇节点到入口节点的距离与开始节点到入口节点的距离是相等的。</strong></p>
<p>所以，如果我们在指针相遇后，让p2指针重新回到头节点，并且每次只前进一步。那么，当两个指针再次相遇的时候，其节点恰好就是入口节点。</p>
<p>以上的推导可能有点绕，如果你还不能理解，请在微信公众号“欧阳锋工作室”给我留言。</p>
<p>知道了原理之后，代码就简单了。以下是上述思路的完整代码实现：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">public</span> Node getRingEntryNode(Node head) &#123;</span><br><span class="line">	Node <span class="built_in">p1</span> = head<span class="comment">;</span></span><br><span class="line">	Node <span class="built_in">p2</span> = head<span class="comment">;</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">while</span> (<span class="built_in">p2</span> != null &amp;&amp; <span class="built_in">p2</span>.next != null) &#123;</span><br><span class="line">		<span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">		<span class="built_in">p2</span> = <span class="built_in">p2</span>.next.next<span class="comment">;</span></span><br><span class="line">		</span><br><span class="line">		<span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">			<span class="keyword">break;</span></span><br><span class="line"><span class="keyword">	</span>	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 第一相遇后，我们让<span class="built_in">p2</span>节点重新指向头节点</span><br><span class="line">	<span class="built_in">p2</span> = head<span class="comment">;</span></span><br><span class="line">	// 再次进入循环，直到二者再次相遇</span><br><span class="line">	<span class="meta">while</span> (<span class="built_in">p1</span> != null) &#123;</span><br><span class="line">		<span class="built_in">p1</span> = <span class="built_in">p1</span>.next<span class="comment">;</span></span><br><span class="line">		<span class="built_in">p2</span> = <span class="built_in">p2</span>.next<span class="comment">;</span></span><br><span class="line">		</span><br><span class="line">		// 两者再次相遇，相遇节点即是环</span><br><span class="line">		// 的入口节点</span><br><span class="line">		<span class="meta">if</span> (<span class="built_in">p1</span> == <span class="built_in">p2</span>) &#123;</span><br><span class="line">			return <span class="built_in">p1</span><span class="comment">;</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	return null<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题八：有两个有序链表，请将他们合并为一个链表，同时保证链表有序"><a href="#问题八：有两个有序链表，请将他们合并为一个链表，同时保证链表有序" class="headerlink" title="问题八：有两个有序链表，请将他们合并为一个链表，同时保证链表有序"></a>问题八：有两个有序链表，请将他们合并为一个链表，同时保证链表有序</h3><p>示例：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line"><span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">6</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>这道题完全可以使用循环的方式处理，先取出两个链表中的第一个元素，取第一个元素较小的值放在表头，并且将该链表作为目标链表。逐一对比，拼接到链表指定位置，直到某个链表为空。如果被对比链表更长，则将剩余部分的元素直接连接到目标链表即可。</p>
<p>这是一种常规的解法，事实上，这道题还可以使用递归的方式进行处理。实现的思路与循环类似，只是代码层面更容易理解，且代码量更少，其完整实现如下：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Node mergeOrderedLink(Node head1, Node head2) &#123;</span><br><span class="line">	<span class="comment">// 先判断存在空链表的情况</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">null</span> == head1) &#123;</span><br><span class="line">		<span class="keyword">return</span> head2</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">null</span> == head2) &#123;</span><br><span class="line">		<span class="keyword">return</span> head1</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		Node <span class="keyword">new</span><span class="type">Head</span> = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (head1.data &lt; head2.data) &#123;</span><br><span class="line">			<span class="keyword">new</span><span class="type">Head</span> = head1;</span><br><span class="line">			<span class="keyword">new</span><span class="type">Head</span>.next = mergeOrderedLink(head1.next, head2);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">new</span><span class="type">Head</span> = head2;</span><br><span class="line">			<span class="keyword">new</span><span class="type">Head</span>.next = 			<span class="keyword">new</span><span class="type">Head</span>.next = mergeOrderedLink(head1, head2.next);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span><span class="type">Head</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="压轴题"><a href="#压轴题" class="headerlink" title="压轴题"></a>压轴题</h3><p>以上就是我们在面试中可能会遇到的常见的八道链表算法面试题。最后，我给大家准备了一道压轴题，大家尝试做一下。获取答案，可以在微信公众号“欧阳锋工作室”中回复“链表”获得。</p>
<h3 id="问题九：有一个单向链表，你无法获取到这个链表的头节点，在链表中存在四个连续节点A、B、C、D四个节点，已知B节点，如何将其从链表中删除掉"><a href="#问题九：有一个单向链表，你无法获取到这个链表的头节点，在链表中存在四个连续节点A、B、C、D四个节点，已知B节点，如何将其从链表中删除掉" class="headerlink" title="问题九：有一个单向链表，你无法获取到这个链表的头节点，在链表中存在四个连续节点A、B、C、D四个节点，已知B节点，如何将其从链表中删除掉"></a>问题九：有一个单向链表，你无法获取到这个链表的头节点，在链表中存在四个连续节点A、B、C、D四个节点，已知B节点，如何将其从链表中删除掉</h3><p>阅读更多文章，请关注公众号“欧阳锋工作室”</p>
<p><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>正确使用Kotlin注解，兼容Java代码</title>
    <url>/2019/11/12/%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Kotlin%E6%B3%A8%E8%A7%A3%EF%BC%8C%E5%85%BC%E5%AE%B9Java%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。</p>
</blockquote>
<a id="more"></a>
<p>产生这个问题的根本原因在于：Kotlin语言与Java语言的设计思路不同，部分特性属于Java语言独有，例如静态变量。部分特性属于Kotlin语言独有，例如逆变和协变。</p>
<blockquote>
<p>为了抹平这些差异，Kotlin语言提供了一个绝佳的思路，通过添加注解可以改变Kotlin编译器生成的Java字节码，使之按照Java语言可以理解的方向进行，从而实现兼容。</p>
</blockquote>
<p><strong>问题答疑：Kotlin语言与Java字节码有什么关系？为什么Kotlin编译器会生成Java字节码？</strong></p>
<p>不管是Kotlin语言还是Java语言都是建立在JVM平台上面的编程语言，其最终都需要编译成JVM可以识别的Java字节码才能被正确执行。这也是为什么Kotlin语言与Java可以完全互通的原因之一，不要将Java与Java平台混为一谈。</p>
<p>接下来我们看第一个注解，也是最常见的注解</p>
<h3 id="JvmField"><a href="#JvmField" class="headerlink" title="@JvmField"></a>@JvmField</h3><p>Kotlin编译器默认会将类中声明的成员变量编译成私有变量，Java语言要访问该变量必须通过其生成的getter方法。而使用上面的注解可以向Java暴露该变量，即使其访问变为公开（修饰符变为public)。</p>
<p>我们来做一个实验：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmField</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 在添加@JvmField注解之前，这样访问会报错</span></span><br><span class="line">        <span class="comment">// 只能通过p.getName()的方式进行访问</span></span><br><span class="line">        String name = p.name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>在Person类中我们定义了一个成员变量<code>name</code>，在添加<code>@JvmField</code>属性前我们试图通过<code>p.name</code>的方式进行访问，编译器会报错。因为，默认生成的成员变量<code>name</code>是私有的。而添加该注解之后我们却可以正常访问了。</p>
<p>由此可见，<code>@JvmField</code>注解的确使生成的字节码发生了变化，我们将字节码用Java语言的形式表示，具体发生的变化类似下面的代码展示：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">添加@JvmField注解的变化</a><ul class="tabs"><li class="tab active">before</li><li class="tab">after</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">public final class Person {</span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">   public final String getName() {</span><br><span class="line">      return this.name;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   public final void setName(@Nullable String var1) {</span><br><span class="line">      this.name = var1;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line">public final class Person {</span><br><span class="line">   public String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p><strong>注：before与after分别为添加注解前与添加之后</strong></p>
<p>以上场景是将<code>@JvmField</code>注解添加到普通变量上方，如果添加到伴随对象的成员变量上方，会发生什么呢？我们来试试看：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">添加到伴随对象</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">val</span> GENDER_MALE = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">  <span class="comment">// 未添加之前</span></span><br><span class="line">  <span class="comment">// int gender = Person.Companion.getGENDER_MALE();</span></span><br><span class="line">  <span class="comment">// 添加之后，可直接访问</span></span><br><span class="line">   <span class="keyword">int</span> gender = Person.GENDER_MALE;</span><br><span class="line">   System.out.println(gender);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>同样地，添加注解之后我们可以通过点语法直接对其进行访问。</p>
<p>由此可见，<code>@JvmField</code>注解会使伴随对象在伴生类中生成静态成员变量，通过伴生类类名可直接对其进行访问。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>@JvmField</code>注解可改变字节码的生成，其作用的目标是类成员变量或伴随对象成员变量。作用在类成员中可使该变量对外暴露，通过点语法直接访问。即将私有成员变量公有化（public），并去掉setter/getter方法。作用在伴随对象成员变量中，可以使该伴随对象中的变量生成在伴生对象中，成为伴生对象的公有静态成员变量，通过伴生类可直接访问。</p>
<p>那么问题来了，如果该注解作用在私有成员变量上方会发生什么呢？请大家自行做实验验证。</p>
<h3 id="JvmStatic"><a href="#JvmStatic" class="headerlink" title="@JvmStatic"></a>@JvmStatic</h3><p>这个注解与<code>@JvmField</code>非常容易出现混淆，两者都可以作用在伴随对象成员变量上方，我们来试试看，如果同样作用在伴随对象成员变量中，会出现什么情况。</p>
<p>添加<code>@JvmField</code>注解的效果，上面我们已经看到了，我们直接将注解修改为<code>@JvmStatic</code>试试看：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">添加到伴随对象</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">val</span> GENDER_MALE = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{   </span><br><span class="line">    <span class="comment">// 1) 这样访问报错</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.GENDER_MALE;</span><br><span class="line">    <span class="comment">// 2) 这样访问正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.Companion.getGENDER_MALE();</span><br><span class="line">    <span class="comment">// 3) 这样访问也正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.getGENDER_MALE();</span><br><span class="line"></span><br><span class="line">    System.out.println(gender);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>切换到Java代码，你可以看到，我一共提供了三种访问方式。第一种访问方式是通过点语法直接访问，编译器报错，由此可见，<code>@JvmStatic</code>注解并没有在伴生类中生成静态的公有成员变量。第三种方式可以正常访问，证明该注解在伴生类中生成了静态的公有getter方法。第二种方式可以正常访问，证明该注解不会破坏伴随对象中原有成员的访问方式。</p>
<p>由此，我们可以大胆猜测，<code>@JvmStatic</code>注解的作用应该是生成静态的setter/getter方法，而不会改变属性（成员变量）的访问权限。</p>
<p>为了进一步验证我们的猜想，我们将<code>val</code>修改为<code>var</code>试试看。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 1) 这样访问报错</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.GENDER_MALE;</span><br><span class="line">    <span class="comment">// 2) 这样访问正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.Companion.getGENDER_MALE();</span><br><span class="line">    <span class="comment">// 3) 这样访问也正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.getGENDER_MALE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 以下访问正常</span></span><br><span class="line">    Person.setGENDER_MALE(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(gender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种方式调用正常，证明我们的猜测没有错，<code>@JvmStatic</code>仅会改变伴随对象或对象（object）中setter/getter方法的生成方式，而不会改变属性访问权限，这是与注解<code>@JvmField</code>的本质区别。</p>
<p><strong>注意：由于<code>@JvmField</code>不仅会改变属性的访问权限，同时也会改变setter/getter方法的生成，细心的同学应该已经注意到了。一旦添加了<code>@JvmField</code>注解，setter/getter方法也消失了（变量可以通过点语法直接访问，setter/getter方法也就没必要存在了）。而<code>@JvmStatic</code>仅仅是使setter/getter方法变为静态方法，同时生成位置放置到伴生类中。这与<code>@JvmField</code>的处理方式有些冲突（<code>@JvmField</code>会直接删除掉setter/getter方法）。为了避免冲突，Kotlin语言禁止将这两个注解混淆使用。</strong></p>
<p>以上是将<code>@JvmStatic</code>与<code>@JvmField</code>作用在伴随对象成员变量上的区别。实际上，<code>@JvmStatic</code>不仅可以修饰属性（成员变量），还可以修饰方法，修饰方法的作用与修饰属性的作用一致，都是将方法变成静态类型。</p>
<p>为了更直观地表示两种的区别，我们用一个表格完整展示两个注解的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">作用位置</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@JvmField</code></td>
<td style="text-align:center">类属性或对象属性</td>
<td style="text-align:center">使属性修饰符成为public</td>
</tr>
<tr>
<td style="text-align:center"><code>@JvmStatic</code></td>
<td style="text-align:center">对象方法（包括伴生对象）</td>
<td style="text-align:center">使用方法成为静态类型，如果作用在伴生对象方法中，其方法会成为伴生类的静态方法</td>
</tr>
</tbody>
</table>
<h3 id="JvmName"><a href="#JvmName" class="headerlink" title="@JvmName"></a>@JvmName</h3><p>这个注解可以改变字节码中生成的类名或方法名称，如果作用在顶级作用域（文件中），则会改变生成对应Java类的名称。如果作用在方法上，则会改变生成对应Java方法的名称。</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmName</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">"FooKt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmName(<span class="meta-string">"foo1"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"Hello, Jvm..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于下面的Java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FooKt</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span> </span>{</span><br><span class="line">      String var0 = <span class="string">"Hello, Jvm..."</span>;</span><br><span class="line">      System.out.println(var0);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>可以看到第一个注解<code>@file:JvmName(&quot;FooKt&quot;)</code>的作用是使生成的类名变为<code>FooKt</code>，第二个注解的作用是使生成的方法名称变为<code>foo1</code>。</p>
<p><strong>注意：该注解不能改变类中生成的属性（成员变量）的名称。</strong></p>
<p>这里的注解中，我们看到了一个特殊的前缀<code>@file:</code>，这个注解前缀是Kotlin语言特有的一种标识，其作用是标记该注解最终会作用在生成的字节码的具体位置（属性、setter、getter等），关于这个部分，大家可以先跳过，下一篇文章将给大家详细讲解。</p>
<h3 id="JvmMultifileClass"><a href="#JvmMultifileClass" class="headerlink" title="@JvmMultifileClass"></a>@JvmMultifileClass</h3><p>说完了上面这个注解，就不得不提到<code>@JvmMultifileClass</code>这个注解，这个注解通常是与<code>@JvmName</code>结合使用的。其使用场景比较单一，看下面的例子：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmMultifileClass</a><ul class="tabs"><li class="tab active">Util1</li><li class="tab">Util2</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line"></span><br><span class="line">fun isEmpty(str: String?): Boolean {</span><br><span class="line">    return null == str || str.length &lt;= 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line"></span><br><span class="line">fun isPhoneNumber(str: String): Boolean {</span><br><span class="line">    return str.startsWith("1") &amp;&amp; str.length == 11</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>编译以上代码，Kotlin编译器会提示错误<code>Error:(1, 1) Kotlin: Duplicate JVM class name &#39;Utils&#39; generated from: package-fragment, package-fragment</code>，即生成的类名出现了重复。可是，如果我们就是希望声明使用多个文件，但方法生成到同一个类中呢？<code>@JvmMultifileClass</code>就是为解决这个问题而生的。</p>
<p>我们在上面代码的基础上分别添加注解<code>@JvmMultifileClass</code>试试看:</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmMultifileClass</a><ul class="tabs"><li class="tab active">Util1</li><li class="tab">Util2</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line">@file:JvmMultifileClas</span><br><span class="line"></span><br><span class="line">fun isEmpty(str: String?): Boolean {</span><br><span class="line">    return null == str || str.length &lt;= 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line">@file:JvmMultifileClass</span><br><span class="line"></span><br><span class="line">fun isPhoneNumber(str: String): Boolean {</span><br><span class="line">    return str.startsWith("1") &amp;&amp; str.length == 11</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="meta">@Nullable</span> String str)</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> Utils__A1Kt.isEmpty(str);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isPhoneNumber</span><span class="params">(<span class="meta">@NotNull</span> String str)</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> Utils__A2Kt.isPhoneNumber(str);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>这个注解在处理多个文件声明，合并到一个类的场景中发挥着举足轻重的作用。如果你有这样的需求，一定要谨记这个注解。</p>
<h3 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a>@JvmOverloads</h3><p>由于Kotlin语言支持方法参数默认值，而实现类似功能Java需要使用方法重载来实现，这个注解就是为解决这个问题而生的，添加这个注解会自动生成重载方法。我们来试一下：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmOverloads</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span> = <span class="number">0</span>, z: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">}</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> foo(x, y, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> foo(x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>由此可见，通过这个注解可以影响带有参数默认值方法的生成，添加该注解将自动生成带有默认值参数数量的重载方法。这是一个非常有用的特性，方便Java端可以更高效地调用Kotlin端代码。</p>
<h3 id="Throws"><a href="#Throws" class="headerlink" title="@Throws"></a>@Throws</h3><p>由于Kotlin语言不支持CE（Checked Exception），所谓CE，即方法可能抛出的异常是已知的。Java语言通过<code>throws</code>关键字在方法上声明CE。为了兼容这种写法，Kotlin语言新增了<code>@Throws</code>注解，该注解的接收一个可变参数，参数类型是多个异常的KClass实例。Kotlin编译器通过读取注解参数，在生成的字节码中自动添加CE声明。</p>
<p>为了便于理解，看一个简单的例子：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmOverloads</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Throws(IllegalArgumentException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Float</span> {</span><br><span class="line">    <span class="keyword">return</span> x.toFloat() / y</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> IllegalArgumentException </span>{</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">float</span>)x / (<span class="keyword">float</span>)y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>可以看到，添加了<code>@Throws(IllegalArgumentException::class)</code>注解后，在生成的方法签名上自动添加了可能抛出的异常声明（throws IllegalArgumentException），即CE。</p>
<p>这个注解在保证逻辑的严谨性方面非常有用，但如果你的工程中仅使用Kotlin代码，可以不用理会该注解。在Kotlin语言的设计哲学里面，CE被认为是一个错误的设计。</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h3><p>这个注解很容易理解，顾名思义，主要用于产生同步方法。Kotlin语言不支持<code>synchronized</code>关键字，处理类似Java语言的并发问题，Kotlin语言建议使用同步方法进行处理。</p>
<p>Kotlin团队认为同步的逻辑应该交给代码处理，而不应该在语言层面处理：</p>
<p><img src="http://youngfeng.com/assets/images/kotlin/jvmanno/syn.png" alt=""></p>
<p>但为了兼容Java，Kotlin语言支持使用该注解让编译器自动生成同步方法：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@Synchronized</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"Start do something..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">  String var0 = <span class="string">"Start do something..."</span>;</span><br><span class="line">  System.out.println(var0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<h3 id="JvmWildcard"><a href="#JvmWildcard" class="headerlink" title="@JvmWildcard"></a>@JvmWildcard</h3><p>这个注解主要用于处理泛型参数，这涉及到两个新的知识点：<strong>逆变</strong>与<strong>协变</strong>。由于Java语言不支持协变，为了保证安全地相互调用，可以通过在泛型参数声明的位置添加该注解使用Kotlin编译器生成通配符形式的泛型参数（<code>？extends ...</code>)。</p>
<p>看下面这段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> value: T)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">boxDerived</span><span class="params">(value: <span class="type">Derived</span>)</span></span>: Box&lt;Derived&gt; = Box(value)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;<span class="type">Base</span>&gt;)</span></span>: Base = box.value</span><br></pre></td></tr></table></figure>
<p>按照正常思维，下面的两个方法转换到Java代码应该是这样：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Box&lt;Derived&gt; </span><span class="keyword">boxDerived(Derived </span>value) &#123; …… &#125;</span><br><span class="line"><span class="keyword">Base </span>unboxBase(<span class="keyword">Box&lt;Base&gt; </span><span class="keyword">box) </span>&#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>但问题是，Kotlin泛型支持型变，在Kotlin中，我们可以这样写<code>unboxBase(Box(Derived()))</code>，而在Java语言中，泛型参数类型是不可变的，按照上面的写法显然已经做不到了。</p>
<p>正确转换到Java代码应该是这样：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Base </span>unboxBase(<span class="keyword">Box&lt;? </span><span class="keyword">extends </span><span class="keyword">Base&gt; </span><span class="keyword">box) </span>&#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>为了使这样的转换正确生成，我们需要在泛型参数的位置添加上面的注解:</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;@<span class="type">JvmWildcard</span> <span class="type">Base</span>&gt;)</span></span>: Base = box.value</span><br></pre></td></tr></table></figure>
<h3 id="JvmSuppressWildcards"><a href="#JvmSuppressWildcards" class="headerlink" title="@JvmSuppressWildcards"></a>@JvmSuppressWildcards</h3><p>这个注解的作用与<code>@JvmWildcard</code>恰恰相反，它是用来抑制通配符泛型参数的生成，即在不需要型变泛型参数的情况下，我们可以通过添加这个注解来避免生成型变泛型参数。</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmSuppressWildcards</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;@<span class="type">JvmSuppressWildcards</span> <span class="type">Base</span>&gt;)</span></span>: Base = box.value</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function">Base <span class="title">unboxBase</span><span class="params">(Box&lt;Base&gt; box)</span> </span>{ …… }</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>正确使用上述注解，可以抹平Kotlin与Java泛型处理的差异，避免出现安全转换问题。</p>
<h3 id="Volatile-Transient"><a href="#Volatile-Transient" class="headerlink" title="@Volatile @Transient"></a>@Volatile @Transient</h3><p>这两个注解恰好对应Java端的两个关键字<code>volatile</code>与<code>transient</code>，前者主要用于解决多线程脏数据问题，后者用于标记序列化对象中不参与序列化的属性。</p>
<p>这两个注解比较简单，就不举例说明了。在遇到类似需要与Java互通的场景时，只需要将其关键字替换为该注解即可。</p>
<p>以上就是我们日常开发过程中能够遇到的所有注解了，在Kotlin 1.3版本中，还增加了一个新的注解<code>@JvmDefault</code>用于在接口中处理默认实现的方法。接口中允许有默认实现是从JDK 1.8版本开始的，为了兼容低版本JDK，Kotlin语言新增了该注解用于生成兼容性字节码，但该注解目前仍处于实验阶段，名称或行为均可能发生改变，建议大家先不要使用，推荐大家始终使用JDK 1.8及其以上版本。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>如果在工程中必须存在部分Java代码，为了实现完美调用，一定要谨慎并正确地使用上述注解。要充分理解Kotlin编译器与Java编译器生成的字节码差异。</p>
<p>如果是由于现存Java库仅兼容Java字节码，导致部分框架在遇到Kotlin语言生成的字节码时会出现解析错误，不能正常使用。这个时候要尝试检查是否需要通过上述注解矫正字节码的生成，使Java库能够正常使用。</p>
<p>如果是新工程，建议大家全部使用Kotlin代码，避免出现上述注解，减少阅读上的困难。目前，Kotlin版本已经非常稳定了，请大家放心使用。</p>
<p>阅读更多技术文章，请关注微信公众号”欧阳锋工作室“<br><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>
<p>参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Jvm</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>10分钟看懂动态代理设计模式（升级篇）</title>
    <url>/2019/11/29/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%87%E7%BA%A7%E7%AF%87%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>关于动态代理，我之前写过一篇文章<a href="http://youngfeng.com/2018/03/02/design%20pattern/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《10分钟看懂动态代理设计模式》</a>。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？</p>
</blockquote>
<a id="more"></a>
<p>这篇文章的思路还是同之前的文章一样，由浅入深，如果你已经看过上一篇文章，部分章节可以跳过。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>那么，到底什么是代理呢？</p>
<p>所谓的代理，其实就是中间人的意思。例如：让朋友代替你去取快递，你的朋友就充当了代理的作用。再比如，让你的朋友帮你去借款，你的朋友实际上也充当了代理的作用，最终这笔钱的受益人还是你自己。</p>
<p>理解了代理的意思，接下来我们一起来看一下，在面向对象编程语言中，到底应该如何体现代理呢。</p>
<p>这里我们就以上面提到的代取快递为例，来写一个简单的代理实现。</p>
<p>我们用<code>Friend</code>类表示你的朋友，用<code>Self</code>表示你自己，上面的例子用代码实现应该是这样：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Friend</span>(<span class="params">String name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.name + <span class="string">"去取快递..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Self</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Friend <span class="keyword">friend</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Self</span><span class="params">(Friend <span class="keyword">friend</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">friend</span> = <span class="keyword">friend</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于实际动作的执行者是你的朋友</span></span><br><span class="line">    <span class="comment">// 因此，这里直接调用Friend的collectPack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">friend</span>.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend <span class="keyword">friend</span> = <span class="keyword">new</span> Friend(<span class="string">"张三"</span>);</span><br><span class="line">        Self self = <span class="keyword">new</span> Self(<span class="keyword">friend</span>);</span><br><span class="line">        <span class="comment">// 这里将打印”张三去取快递...“</span></span><br><span class="line">        self.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们实现了一个简单的代理。这里的代理类是<code>Friend</code>，被代理类是<code>Self</code>，通过这段代码，我们知道了一个基本事实：<strong>代理对象</strong>是真正去执行动作的对象，<strong>被代理对象</strong>是被动执行动作的对象（并不真正执行动作）。</p>
<p>上面的实现看似没有问题，实际上却不够友好，由于代理对象能够替被代理对象执行动作。所以，他们应该具有同样的一些方法。换句话说，应该实现他们应该实现同样的接口，这个接口中的方法表示双方都可以执行的一些动作，或者说可能要被代理的一些动作。</p>
<p>因此，上面的代码可以改写成下面这样：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个接口表示代理类与被代理类可以共同执行的动作</span></span><br><span class="line"><span class="comment">//  或者说，具体想要被代理的动作方法集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Collectable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">collectPack</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend</span> <span class="keyword">implements</span> <span class="title">Collectable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Friend</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"去取快递..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Self</span> <span class="title">implements</span> <span class="title">Collectable</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Friend <span class="keyword">friend</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Self</span><span class="params">(Friend <span class="keyword">friend</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">friend</span> = <span class="keyword">friend</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于实际动作的执行者是你的朋友</span></span><br><span class="line">    <span class="comment">// 因此，这里直接调用Friend的collectPack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">friend</span>.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend <span class="keyword">friend</span> = <span class="keyword">new</span> Friend(<span class="string">"张三"</span>);</span><br><span class="line">        Self self = <span class="keyword">new</span> Self(<span class="keyword">friend</span>);</span><br><span class="line">        self.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恭喜你！通过上面的改造，我们已经完成了一个标准的静态代理实现。之所以称之为静态代理，是因为这里的逻辑是写死的，并不具备动态特性。与之相对的，就是今天这篇文章的主角：动态代理。</p>
<h3 id="代理的作用是什么"><a href="#代理的作用是什么" class="headerlink" title="代理的作用是什么"></a>代理的作用是什么</h3><p>看到这里，应该有人会问了，说了这么多，代理到底有什么用呢。这个问题并不容易回答，为了回答你的这个问题，我们先来看一个场景。</p>
<p>假设有一个类<code>Driver</code>，类中只有一个方法<code>drive</code>，我们不能改动这个类的源码，如何获取这个方法的执行时间呢？</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Driver</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"I'm driving..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Drive completed..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的同学可能会说，这还不简单，在main方法中，方法执行前记录一个时间，方法执行后记录一个时间，两个时间相减就得到了方法最终的执行时间。</p>
<p><strong>位置p1</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    driver.drive();</span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法到底对不对呢，先说结论：不对！这里的时间会大于方法实际执行的时间，因为这里包含了准备方法的那些时间。</p>
<p>除了这个方法之外，还有一个比较容易想到的方法就是<strong>继承</strong>。通过继承Driver类，在drive方法前后打印时间，计算时间差，这种方式似乎可行！</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver1</span> <span class="keyword">extends</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        long start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        long end = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="type">System</span>.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>位置p2</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Driver1 driver1 = <span class="keyword">new</span> Driver1();</span><br><span class="line">    driver1.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个疑点，有些同学在问，到底方法的准备时间是什么，为什么会有准备方法的这些时间。这两种方式不是都需要准备方法吗？</p>
<p>上面我们说到，直接打印的方式包含了准备方法的那些时间，准备一个方法通常需要先压栈，调用后自动出栈，这些都需要时间，尤其在一些性能比较低的机器上会体现的特别明显。不信，大家可以执行位置p1处的代码与位置p2处的代码，你会发现，位置p2处的执行时间几乎总是比位置p1处的执行时间少3~5毫秒（在我的Macbook Pro 15.4 2017上执行是这样的结果，其它机型时间可能略有差异）。在继承中不需要这些时间的原因是：我们是方法内部执行的，这个时候方法已经准备好，就不存在这个准备时间了。</p>
<p>Ok，说完了上面这个问题，我们继续回到上面的代码。在上面的代码中，我们通过继承的方式获得了方法的执行时间。接下来，新需求来了，我要你在<code>drive</code>方法前后各打印一条日志。</p>
<p>你会怎么做呢，当然毫无疑问，我们继续沿用上面的解决方案，继承Driver类创建新类Driver2。然后，在super调用前后各打印一条日志。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> <span class="keyword">extends</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题似乎很简单，可是，新的需求又来了。我要你先打印日志再获取方法的执行时间。其实，这也很简单。我们只要继承上面的<code>Driver2</code>类，重写<code>drive</code>方法获取方法执行的时间即可：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver3</span> <span class="keyword">extends</span> <span class="title">Driver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        long start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        long end = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="type">System</span>.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，麻烦来了。需求又变了，我要你先获取方法的执行时间再打印日志，怎么办。</p>
<p>有人说，这也没毛病啊。我们只要继承<code>Driver1</code>创建新类<code>Driver4</code>，然后在<code>drive</code>方法中打印日志即可：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver4</span> <span class="keyword">extends</span> <span class="title">Driver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你已经发现了，这个解决方案存在着明显的问题，如果一个类有100个方法，实现上述这些逻辑大概需要创建400个类，这显然不是一个可取的方法。那么，是否有更好的解决方案呢？</p>
<p>在上面的解决方案中，我们通过继承的方式获取到了父类方法的执行时间。但是，如果Driver类被final修饰呢，大家知道final类是无法被继承的，继承这条路显然走不通了。</p>
<p>但这似乎恰好为我们打开了一扇窗，我们尝试使用文章开头静态代理的方式传入不同功能的Driver类实例，看看能否发生一些特殊的化学反应。</p>
<p>同样，我们以获取方法的执行时间为例，如果要通过静态代理的方式获取方法的执行时间，我们应该这样做：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Driver5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver5</span>(<span class="params">Driver driver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        driver.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.<span class="keyword">out</span>.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说到，我们应该将统一的动作抽象化。因此，这里我们新增统一的接口<code>Drivable</code>，我们让所有的Driver类都实现<code>Drivable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver5</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver5</span><span class="params">(Driver driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        driver.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，为了在方法的执行前后打印日志，我们创建<code>Driver6</code>通过代理的方式实现日志的打印：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver6</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver6</span><span class="params">(Driver driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        driver.drive();</span><br><span class="line">        System.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了与前面的方式区分开来，我们将<code>Driver5</code>重命名为<code>DriverTimeProxy</code>，<code>Driver6</code>重命名为<code>DriverLogProxy</code>，接下来我们尝试先打印日志再获取方法的执行时间。</p>
<p>咋一看，似乎毫无头绪。别急，我们先尝试将聚合对象<code>Driver</code>抽象化。参数类型修改为<code>Drivable</code>（由于Driver类也实现了Drivable接口），修改完成后代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverLogProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverLogProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        drivable.drive();</span><br><span class="line">        System.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        drivable.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，神奇的化学反应出现了。由于<code>DriverLogProxy</code>与<code>DriveTimeProxy</code>都实现了<code>Drivable</code>接口，我们可以将这两个对象相互聚合到对方的类中。</p>
<p>例如，如果我们要先打印方法的执行时间再打印日志，可以这样做：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> <span class="type">Driver</span>();</span><br><span class="line">    </span><br><span class="line">    DriverTimeProxy driverTimeProxy = <span class="keyword">new</span> <span class="type">DriverTimeProxy</span>(driver);</span><br><span class="line">    DriverLogProxy driverLogProxy = <span class="keyword">new</span> <span class="type">DriverLogProxy</span>(driverTimeProxy);</span><br><span class="line">    </span><br><span class="line">    driverLogProxy.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果我们要先打印日志再打印方法的执行时间，可以这样做：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> <span class="type">Driver</span>();</span><br><span class="line"></span><br><span class="line">    DriverLogProxy driverLogProxy = <span class="keyword">new</span> <span class="type">DriverLogProxy</span>(driver);</span><br><span class="line">    DriverTimeProxy driverTimeProxy = <span class="keyword">new</span> <span class="type">DriverTimeProxy</span>(driverLogProxy);</span><br><span class="line"></span><br><span class="line">    driverTimeProxy.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，为了实现相同的功能，我们至少需要创建四个类，而这里似乎只需要两个类就搞定了。显然，这种通过代理处理的方式更优。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在上面的例子中，我们通过静态代理仅使用两个类就完成了四种不同顺序调用的组合，这种在一个类中持有另一个类的实例引用的方式也被称之为<strong>聚合</strong>。在这种场景中，我们可以说，聚合优于继承。</p>
<p>接下来，我们继续加大问题的难度，我们是否可以在任意对象的任意方法前后添加任意的操作呢？并且不需要增加额外的类。</p>
<p>这个问题的难度一下提高了不少，为了简化问题的难度，我们将问题分解一下。</p>
<p>首先，第一个要点是，必须在任意对象的任意方法前后执行任意的操作，这就要求我们必须拿到对象中的任意方法。要拿到对象的任意方法怎么做呢，反射恰好可以解决你的问题。</p>
<p>第二个要点，不能增加额外的类，换句话说，DriverLogProxy与DriverTimeProxy都不需要增加，怎么办！这个地方不太容易想到，其实我们可以帮助用户生成这样的类，使用Java代码编译并通过ClassLoader将字节码加载到内存中，再通过反射的方式进行调用。这样看起来虽然生成了额外的类，但用户是无法感知的，也就做到了不增加额外类的要求。</p>
<p>接下来，我们先来尝试动态生成针对时间的代理类DriverTimeProxy，这个类的完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        drivable.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成这样的代码，我们需要分两步处理：</p>
<p>第一步：将上面的代码当成字符串拼接到变量str中</p>
<p>第二步：使用File类将文件输出到硬盘</p>
<p>以上是我们生成<code>DriverTimeProxy</code>类源码的基本思路，为了简化第一步的处理，这里我们使用<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a>来处理。</p>
<p>JavaPoet是什么呢，JavaPoet其实就是一个Java源码生成工具，为了让大家对JavaPoet有一个更直观的了解，我们先来看一段使用JavaPoet编写的代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .<span class="keyword">addModifiers(Modifier.PUBLIC, </span>Modifier.STATIC)</span><br><span class="line">    .returns(void.class)</span><br><span class="line">    .<span class="keyword">addParameter(String[].class, </span><span class="string">"args"</span>)</span><br><span class="line">    .<span class="keyword">addStatement("$T.out.println($S)", </span>System.class, <span class="string">"Hello, JavaPoet!"</span>)</span><br><span class="line">    .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">TypeSpec </span>helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .<span class="keyword">addModifiers(Modifier.PUBLIC, </span>Modifier.FINAL)</span><br><span class="line">    .<span class="keyword">addMethod(main)</span></span><br><span class="line"><span class="keyword"> </span>   .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">JavaFile </span><span class="keyword">javaFile </span>= <span class="keyword">JavaFile.builder("com.example.helloworld", </span>helloWorld)</span><br><span class="line">    .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">javaFile.writeTo(System.out);</span></span><br></pre></td></tr></table></figure>
<p>将以上代码复制到main方法中执行，你将得到下面这样的输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, JavaPoet!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样，明白了吧。通过使用上面的一段API对Java代码进行描述，JavaPoet就自动帮我们生成了一段非常漂亮的Java代码，连排版都省了，这就是JavaPoet的作用。</p>
<p>Ok，接下来我们增加下面这段代码帮助我们生成DriverTimeProxy：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">MethodSpec drive = MethodSpec.methodBuilder(<span class="string">"drive"</span>)</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PUBLIC)</span><br><span class="line"><span class="meta">        .addAnnotation</span>(Override.class)</span><br><span class="line"><span class="meta">        .addException</span>(InterruptedException.class)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"long start = $T.currentTimeMillis()"</span>, System.class)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"drivable.drive()"</span>)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"long end = $T.currentTimeMillis()"</span>, System.class)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"$T.out.println(end - start)"</span>, System.class)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">FieldSpec fieldSpec = FieldSpec.builder(Drivable.class, <span class="string">"drivable"</span>)</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PRIVATE)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PUBLIC)</span><br><span class="line"><span class="meta">        .addParameter</span>(Drivable.class, <span class="string">"drivable"</span>)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"this.$N = $N"</span>, <span class="string">"drivable"</span>, <span class="string">"drivable"</span>)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">TypeSpec driverTimeProxy = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PUBLIC)</span><br><span class="line"><span class="meta">        .addSuperinterface</span>(Drivable.class)</span><br><span class="line"><span class="meta">        .addMethod</span>(drive)</span><br><span class="line"><span class="meta">        .addMethod</span>(constructor)</span><br><span class="line"><span class="meta">        .addField</span>(fieldSpec)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build()<span class="comment">;</span></span><br><span class="line">javaFile.writeTo(System.out)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在main运行以上代码，你将得到下面这样的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youngfeng.designmode.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.youngfeng.designmode.proxy.juhe.Drivable;</span><br><span class="line"><span class="keyword">import</span> java.lang.InterruptedException;</span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    drivable.drive();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这恰好就是<code>DriverTimeProxy</code>类的完整代码。接下来，我们继续尝试第二步，将生成的DriverTimeProxy类动态编译并加载到内存中，同时通过反射的方式创建该对象。为了让大家看的更清晰，我们创建一个新类<code>Proxy</code>并增加一个静态方法<code>newProxyInstance</code>专门用来处理这个问题。</p>
<p>为了实现动态编译，我们需要将文件输出到硬盘中，简单起见，这里我直接将其输出到我的电脑桌面。为了将其编译为Java字节码，我们需要使用JDK自带的工具类<code>JavaCompiler</code>进行处理，这是第一步处理。</p>
<p>第二步处理，通过JavaCompiler编译完成后需要通过ClassLoader将生成的字节码加载到内存中，再通过反射获取<code>DriverTimeProxy</code>实例，其完整的处理流程如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译生成的Java源码</span></span><br><span class="line">javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"/com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line"><span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">fileManager.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line"><span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">Constructor constr = cls.getConstructor(Drivable.<span class="keyword">class</span>);</span><br><span class="line">Object obj = constr.newInstance(drivable);</span><br></pre></td></tr></table></figure>
<p>结合上面的分析，Proxy类的完整代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Proxy &#123;</span><br><span class="line">    <span class="comment">// 这里需要修改为你自己期望的源码生成路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PATH = <span class="string">"/Users/ouyangfeng/Desktop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(Drivable drivable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MethodSpec drive = MethodSpec.methodBuilder(<span class="string">"drive"</span>)</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>)</span><br><span class="line">                    .addException(InterruptedException.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"long start = $T.currentTimeMillis()"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"drivable.drive()"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"long end = $T.currentTimeMillis()"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"$T.out.println(end - start)"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            FieldSpec fieldSpec = FieldSpec.builder(Drivable.<span class="keyword">class</span>, <span class="string">"drivable"</span>)</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addParameter(Drivable.<span class="keyword">class</span>, <span class="string">"drivable"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"drivable"</span>, <span class="string">"drivable"</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            TypeSpec driverTimeProxy = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addSuperinterface(Drivable.<span class="keyword">class</span>)</span><br><span class="line">                    .addMethod(drive)</span><br><span class="line">                    .addMethod(constructor)</span><br><span class="line">                    .addField(fieldSpec)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">            javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">            javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">            StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"/com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">            javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">            <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">            fileManager.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">            URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">            URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">            <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">            Constructor constr = cls.getConstructor(Drivable.<span class="keyword">class</span>);</span><br><span class="line">            Object obj = constr.newInstance(drivable);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的整个过程相对比较复杂，为了让大家更直观地看到整个过程，我用一张图来描述一下整个过程到底发生了什么。</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy0.png" alt=""></p>
<p>在上图中，大家可以看到，有三个小助手在帮助我们完成整个过程。他们分别是JavaPoet，帮助生成Java源码文件；JavaCompiler，帮助编译Java源码文件；Reflect（反射)，帮助动态创建DriverTimeProxy实例。</p>
<p>至此，我们终于完成了DriverTimeProxy动态实例的创建，从现在开始，DriverTimeProxy.java的源码文件可以从我们的工程中删除掉了。换句话说，我们完成了前面需求中的其中一个，不需要新增额外的类这个部分。</p>
<p>等等，是否任意实现了<code>Drivable</code>接口的类都可以通过<code>Proxy.newProxyInstance()</code>方法创建代理实例增加日志打印功能呢？</p>
<p>是的，没错，你已经做到了。因为newProxyInstance的参数是Drivable接口类型，任意实现了该接口的对象都可以作为参数传入进来。</p>
<p>万里长征我们似乎已经走了一大半了。但，还不够！说好的实现任意自定义操作呢，这里只不过是打印日志而已。别急，我们继续往下看。</p>
<p>为了实现任意的自定义操作，我们需要增加进一步抽象。既然操作是任意的，那么这个操作部分就不能由我们做主，应该交给用户。可问题是，到底应该如何只交出自定义操作权限，其它交给Proxy类实现呢。</p>
<p>这里比较容易想到的一个思路是，增加一个统一的接口，接口中只需要包含一个方法，每次调用代理类接口方法的时候都去调用该方法。至于在该方法中到底要做什么，交给用户去处理。</p>
<p>这个思路是完全可行的，我们还是用一张图来描述整个过程。</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy1.png" alt=""></p>
<p>上图中的<code>InvocatinHandler</code>是计划用来拦截代理类的<code>drive</code>方法调用的。当调用drive方法的时候实际上是调用InvocationHandler的invoke方法。</p>
<p>这样做的好处是什么呢，很明显，我们已经交出了自定义逻辑的主动权，用户可以在invoke方法中实现任意的自定义操作。为了能够实现自定义操作，这里的<code>InvocationHandler</code>也必须是一个接口。</p>
<p>按照这个设计，InvocationHandler实例必须作为参数传入到newInstanceProxy方法中。为了让大家看的更清晰，我们先手动实现新版本的<code>DriverTimeProxy</code>类。</p>
<p>我想，大家首先能够想到的第一个版本应该是这样：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>InvocationHandler &#123;</span><br><span class="line">    void invoke(Object proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler invocationHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invocationHandler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       invocationHandler.invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的设计确实存在一些问题，我们先不管，先按照这个设计，使用<code>JavaPoet</code>帮助我们生成这样的代码。这个时候，<code>newProxyInstance</code>应该修改为下面这样：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(InvocationHandler handler, <span class="keyword">Class</span> ints) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodSpec drive = MethodSpec.methodBuilder(<span class="string">"drive"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addAnnotation(Override.<span class="keyword">class</span>)</span><br><span class="line">                .addException(InterruptedException.<span class="keyword">class</span>)</span><br><span class="line">                .addStatement(<span class="string">"invocationHandler.invoke(this)"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"invocationHandler"</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec driverTimeProxy = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addSuperinterface(ints)</span><br><span class="line">                .addMethod(drive)</span><br><span class="line">                .addMethod(constructor)</span><br><span class="line">                .addField(fieldSpec)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">        javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">        Constructor constr = cls.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">        Object obj = constr.newInstance(handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的DriverTimeProxy构造函数的参数换成了InvocationHandler实例，Drivable实例参数也就不再需要了，但必须传入代理类需要实现的接口类型。因此，newProxyInstance方法的参数变成了两个：InvocationHandler实例与接口的Class类型。</p>
<p>这个版本的newProxyInstance与上一个版本到底有什么不同呢。这里，我们先来做一个简单的总结。</p>
<p>在这个版本的实现中，我们不再需要传入真正的被代理类实例了。我们也去掉了获取方法执行时间的逻辑，这就意味着我们可以在方法的执行前后添加任意的操作了。</p>
<p>这样说起来可能有点抽象，我们继续回到打印方法时间的问题，在这个版本的实现中，如果要打印方法的执行时间，需要怎么做呢。看下面，我们可以这样做：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增加自己的InvocationHandler实现类，在类中包含目标代理类Driver实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Driver <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Driver <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">target</span>.drive();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(<span class="keyword">new</span> MyInvocationHandler(driver), Drivable.class);</span><br><span class="line">    ((Drivable)proxy).drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很神奇，是吗？我们最终将自定义逻辑的实现转移到了接口InvocationHandler的实现类中，至于要对方法做日志打印还是统计时间，只需要自己实现即可，例如，如果要打印日志，在invoke方法中，增加日志打印语句即可：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> invoke(Object proxy) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Drive start..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">try</span> &#123;</span><br><span class="line">        target.drive();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Drive complete..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人说，如果调换日志打印与时间打印的顺序呢，很简单，直接修改invoke方法中的打印顺序即可，逻辑的设计已经完全掌握在了你自己手中，想怎么操作就怎么操作。</p>
<p>至此，经过艰难的长途跋涉，我们终于完全地抛弃掉了<code>DriverTimeProxy</code>与<code>DriverLogProxy</code>两个类，仅需要实现InvocationHandler接口就可以完成各种逻辑的排列组合了。而且，真正的代理类实现对用户来说是完全不可见的，这就是所谓的<strong>动态代理</strong>。</p>
<p>但，还不够！如果这里我们需要实现另外一个类型的类代理，而这个类中的方法存在参数和返回值的话，这里的设计又出现问题了。为什么呢，看下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ICreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICreator</span> &#123;</span><br><span class="line">    Person.<span class="function">Builder <span class="title">create</span>(<span class="params">String name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BuilderCreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderCreator</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">ICreator</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Person.Builder create(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Person</span>.Builder(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们增加了三个类，一个接口，这里需要被代理的类是<code>BuilderCreator</code>。</p>
<p>与之前的<code>Drivable</code>接口不同的是，这里的<code>ICreator</code>接口中的方法不仅存在参数，而且还有返回值。那么，问题来了！</p>
<p>这里暴露出了我们之前设计存在的两个问题：</p>
<p>第一个问题：参数无法传入到InvocationHandler中。</p>
<p>第二个问题：无法获取到目标代理实例方法调用的返回值。</p>
<p>先来看第一个问题，假设我们自己实现了InvocationHandler，代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BuilderCreator <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(BuilderCreator <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create方法的参数无法获取到，这里将无法被调用</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span>.create(xxx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们发现，当我们对目标代理对象调用create方法的时候，发现create方法的参数无法传入进来了。</p>
<p>怎么办呢！为了保证方法参数可以被传入进来，这里的invoke方法必须再增加一个参数表示外部传入的参数值。由于方法参数可能有多个，这里的参数类型我们用一个对象数组来表示。</p>
<p>这是第一个问题，再来看第二个问题。</p>
<p>由于我们的create方法实际会返回<code>BuilderCreator</code>实例，而在我们的设计中invoke方法是无返回值的。因此，当我们调用代理类的接口方法时，将无法获取到create方法的返回值，也就无法实现后面的调用。因此，为了可以获取到方法的返回值，这里的invoke方法还需要增加一个返回值，类型未知，我们就用Object类型。</p>
<p>按照上面的修正，我们的InvocationHandler接口应该这样设计：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>InvocationHandler &#123;</span><br><span class="line">   Object invoke(Object proxy, Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照这样的设计，newProxyInstance方法应该这样修改：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(InvocationHandler handler, <span class="keyword">Class</span> ints) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"invocationHandler"</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addSuperinterface(ints)</span><br><span class="line">                .addMethod(constructor)</span><br><span class="line">                .addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证灵活性，这里需要遍历接口中的方法，逐一实现</span></span><br><span class="line">        Method[] methods = ints.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method: methods) &#123;</span><br><span class="line">            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] params = method.getParameterTypes();</span><br><span class="line">            String args = params.length &lt;= <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">"new Object[] &#123;"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                <span class="keyword">Class</span> param = params[i];</span><br><span class="line">                methodSpecBuilder.addParameter(ParameterSpec.builder(param, <span class="string">"p"</span> + i).build());</span><br><span class="line">                args += <span class="string">"p"</span> + i + <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            args = args == <span class="keyword">null</span> ? args : args.substring(<span class="number">0</span>, args.length() - <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] exceptions = method.getExceptionTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exceptions.length; i++) &#123;</span><br><span class="line">                methodSpecBuilder.addException(exceptions[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span> returnType = method.getReturnType();</span><br><span class="line">            methodSpecBuilder.returns(returnType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法没有返回值的情况下，这里需要额外处理</span></span><br><span class="line">            <span class="keyword">if</span> (returnType.getName().equals(<span class="string">"void"</span>)) &#123;</span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"this.invocationHandler.invoke(this, "</span> + args + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型</span></span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"Object result = this.invocationHandler.invoke(this, "</span> + args + <span class="string">")"</span>)</span><br><span class="line">                        .addCode(<span class="string">"if (result instanceof $T) &#123;\n"</span>, TypeName.get(method.getReturnType()).box())</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) result"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125; else &#123;\n"</span>)</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) null"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            typeSpecBuilder.addMethod(methodSpecBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, typeSpecBuilder.build()).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">        javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">        Constructor constr = cls.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">        Object obj = constr.newInstance(handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newProxyInstance方法似乎又复杂了许多，为了可以获取到用户传入的参数，我们必须严格匹配参数的命名。因此，这里将参数统一命名为<strong>pN</strong>。由于每个接口可能有多个方法，这里我们修改为通过遍历的方式获取传入接口的所有方法。同时，为了保证返回值类型与所需类型一致，在代码中，我们增加了类型判断，自动转换到预期的数据类型。</p>
<p>接下来，我们简单测试一下方法是否按照我们预期的情况运行。实现<code>InvocationHandler</code>接口，在main方法中添加如下测试代码，尝试运行，查看结果：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BuilderCreator <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(BuilderCreator <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">target</span>.create((String) args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BuilderCreator builderCreator = <span class="keyword">new</span> BuilderCreator();</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler <span class="keyword">handler</span> = <span class="keyword">new</span> MyInvocationHandler(builderCreator);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(<span class="keyword">handler</span>, ICreator.class);</span><br><span class="line"></span><br><span class="line">    Person person = ((ICreator)proxy).create(<span class="string">"Scott"</span>).age(<span class="number">18</span>).build();</span><br><span class="line">    System.out.println(person.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果18，很显然，代码按照预期的结果输出了。</p>
<p>但是，我们还是忽略了一个问题，是什么问题呢，这里先卖个关子，我们先来回顾一下每一次的方法调用过程。</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy2.png" alt=""></p>
<p>在上面这张流程图中，在第一步调用中，我增加了几个方法，因为一个接口可能存在多个方法。通过newProxyInstance的处理，这些方法的调用最终都会通过调用InvocationHandler的invoke方法来实现间接调用。</p>
<p>所以，这里的invoke方法的调用次数与接口的方法数是一致的。如果某个接口有5个方法，这里就会调用5次。而这个时候，我们之前设计的问题也就出现了。</p>
<p>什么问题呢，通常来说，我们需要针对不同的方法进行不同的处理。而用户在invoke方法中无法知道当前究竟调用的是哪个方法，也就无法在invoke方法中针对不同的方法调用进行不同的处理。</p>
<p>这样说起来还是有点抽象，为了让大家看的更直观，我们在ICreator接口中再增加一个方法foo, 运行，查看生成的代码是什么。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ICreator &#123;</span><br><span class="line">    Person.Builder create(String name);</span><br><span class="line"></span><br><span class="line">    int foo(int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终动态生成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youngfeng.designmode.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.youngfeng.designmode.proxy.juhe.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;</span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.String;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">ICreator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> InvocationHandler invocationHandler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.invocationHandler = invocationHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Person.<span class="function">Builder <span class="title">create</span><span class="params">(String p0)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">this</span>.invocationHandler.invoke(<span class="keyword">this</span>, <span class="keyword">new</span> Object[] &#123;p0&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Person.Builder) &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Person.Builder) result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Person.Builder) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> p1)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">this</span>.invocationHandler.invoke(<span class="keyword">this</span>, <span class="keyword">new</span> Object[] &#123;p0,p1&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Integer) result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Integer) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到每次调用实际调用的都是InvocationHandler的invoke方法。这个地方会让用户产生疑惑，究竟调用这个方法是发生在调用create还是foo的时候呢。</p>
<p>为了让大家看的更清晰，我们还是看一眼用户端需要实现的InvocationHandler接口类，已经明白的同学可以跳过这个部分继续往下看：</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BuilderCreator <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(BuilderCreator <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Object[] args)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 这里会让用户产生疑惑，target实际有两个方法，而无论是</span></span><br><span class="line">	 <span class="comment">// 调用create方法还是foo方法最终都会走这里。</span></span><br><span class="line">	 <span class="comment">// 如果用户需要对不同的方法进行不同的处理就没法办到了。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">target</span>.create((String) args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让用户知道这一次的调用究竟是调用哪个方法产生的，invoke方法还需要再增加一个参数，这个参数必须代表当前调用的方法。这里需要用到反射了，我们可以通过反射拿到当前调用方法的Method实例并传入到invoke方法中。</p>
<p>我们摘取其中一个方法create来描述我们大概需要怎么做，看下面这段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person.Builder create(String p0) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 这里是计划新增的代码</span></span><br><span class="line">        Method method = Drivable.<span class="keyword">class</span>.getMethod(<span class="string">"create"</span>, String.<span class="keyword">class</span>);</span><br><span class="line">        Object result = <span class="keyword">this</span>.invocationHandler.invoke(<span class="keyword">this</span>, method, new Object[]&#123;p0&#125;);</span><br><span class="line">        <span class="keyword">if</span> (result instanceof Person.Builder) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person.Builder) result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person.Builder) <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成上面这样的代码，我们继续改进newProxyInstance方法，改进后的方法如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(InvocationHandler handler, <span class="keyword">Class</span> ints) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"invocationHandler"</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addSuperinterface(ints)</span><br><span class="line">                .addMethod(constructor)</span><br><span class="line">                .addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证灵活性，这里需要遍历接口中的方法，逐一实现</span></span><br><span class="line">        Method[] methods = ints.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method: methods) &#123;</span><br><span class="line">            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] params = method.getParameterTypes();</span><br><span class="line">            String args = params.length &lt;= <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">"new Object[] &#123;"</span>;</span><br><span class="line">            String argTypes = params.length &lt;= <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">"new Class[] &#123;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                <span class="keyword">Class</span> param = params[i];</span><br><span class="line">                methodSpecBuilder.addParameter(ParameterSpec.builder(param, <span class="string">"p"</span> + i).build());</span><br><span class="line">                args += <span class="string">"p"</span> + i + <span class="string">","</span>;</span><br><span class="line">                argTypes += TypeName.get(param).box().toString() + <span class="string">".class,"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            args = args == <span class="keyword">null</span> ? args : args.substring(<span class="number">0</span>, args.length() - <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line">            argTypes = argTypes == <span class="keyword">null</span> ? argTypes : argTypes.substring(<span class="number">0</span>, argTypes.length() - <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] exceptions = method.getExceptionTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exceptions.length; i++) &#123;</span><br><span class="line">                methodSpecBuilder.addException(exceptions[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span> returnType = method.getReturnType();</span><br><span class="line">            methodSpecBuilder.returns(returnType);</span><br><span class="line"></span><br><span class="line">            methodSpecBuilder.beginControlFlow(<span class="string">"try"</span>);</span><br><span class="line">            methodSpecBuilder.addStatement(<span class="string">"$T method = getClass().getMethod($S, $N)"</span>, Method.<span class="keyword">class</span>, method.getName(), argTypes);</span><br><span class="line">            <span class="comment">// 方法没有返回值的情况下，这里需要额外处理</span></span><br><span class="line">            <span class="keyword">if</span> (returnType.getName().equals(<span class="string">"void"</span>)) &#123;</span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"this.invocationHandler.invoke(this, "</span> + args + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型</span></span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"Object result = this.invocationHandler.invoke(this, method, "</span> + args + <span class="string">")"</span>)</span><br><span class="line">                        .addCode(<span class="string">"if (result instanceof $T) &#123;\n"</span>, TypeName.get(method.getReturnType()).box())</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) result"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125; else &#123;\n"</span>)</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) null"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            methodSpecBuilder.nextControlFlow(<span class="string">"catch ($T e)"</span>, Exception.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"e.printStackTrace()"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"return ($T) null"</span>, TypeName.get(returnType).box())</span><br><span class="line">                    .endControlFlow();</span><br><span class="line"></span><br><span class="line">            typeSpecBuilder.addMethod(methodSpecBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, typeSpecBuilder.build()).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">        javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">        Constructor constr = cls.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">        Object obj = constr.newInstance(handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，如果我们需要对不同的方法进行不同的处理，这里就可以通过method参数进行判断了。</p>
<p>我们继续以代理BuilderCreator类为例，如果我们要在create与foo方法前后分别打印当前方法被调用的日志，可以这样做：</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> BuilderCreator target;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> MyInvocationHandler(BuilderCreator target) &#123;</span><br><span class="line">	    this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) &#123;</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	    	// 通过<span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>)可以获取到方法名</span><br><span class="line">	        System.out.println(<span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>) + <span class="string">" invoke start..."</span>);</span><br><span class="line">	        Object result = <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span>(</span>target, args);</span><br><span class="line">	        System.out.println(<span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>) + <span class="string">" invoke end..."</span>);</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">return</span> result;</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在为止，我们的动态代理实现基本完整了，我们的旅程也快要结束了。终于，如果我们要在某个类的某个方法前后插入任意的逻辑，不再需要新增额外的类了（InvocationHandler实现类除外），而且添加的逻辑也可以完全自定义了，我们的目标达到了！</p>
<p>回顾一下我们的整个探索过程，在文章的开篇部分我们从为Driver类的drive方法增加时间打印需求开始，最终选择通过代理的方式进行处理，这样做的灵活性明显高于继承。而为了去掉额外新增的类，我们使用了动态编译的方式在运行期间帮助用户生成相应的代理类。但我们并未满足于此，为了让插入的逻辑也实现自定义，我们又对插入进行了抽象，新增了插入逻辑抽象类InvocationHandler，最终将对Driver类的代理转换到对InvocationHandler实现类的代理中。将方法调用的主动权交给用户（InvocationHandler的实现类处理）。这样，无论是多么复杂的需求，对用户来说，只需要实现InvocationHandler接口增加自定义处理即可，即使某个类有100个方法，他需要的也只是一个InvocationHandler的实现类而已。</p>
<p>等等，我们似乎还忘记了一件事情。一直以来我们生成的动态代理类名称都叫做<code>DriverTimeProxy</code>，而此刻它的功能已经不再仅仅是为<code>Driver</code>类增加时间打印而已了。因此，这里我们将最终生成的代理类名称修改为<code>Proxy$0</code>。最终版本的实现大家可以查看文章的附录部分，点击下方链接前去查看。</p>
<h3 id="动态代理到底有什么用"><a href="#动态代理到底有什么用" class="headerlink" title="动态代理到底有什么用"></a>动态代理到底有什么用</h3><p>在上面的整个过程中，我们可谓是经历了千难万险，终于完成了一个简易版本的动态代理。那么动态代理到底有什么作用呢。为了让大家直观地感受到，动态代理到底可以做什么，我们先一起来看一个简单的例子。</p>
<p>这里我们创建两个类来简单模拟数据库事务的提交过程（以下代码仅作为演示使用，不具有实际使用价值）：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>TransactionConstr &#123;</span><br><span class="line">    void commit(int x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> <span class="keyword">implements</span> <span class="title">TransactionConstr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Database <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Database();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        System.out.println(<span class="string">"Transaction commit success..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Transaction rollback..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止出现脏数据，我们需要在事务提交失败的时候将数据回滚。在没有动态代理之前，我们会这样处理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Database db = Database.getInstance();</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 通过try catch的方式手动回滚数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.commit(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        db.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用动态代理，我们这样做：实现InvocationHandler，代理Database类，在invoke方法中捕获方法可能抛出的异常，一旦发现异常就调用rollback方法自动回滚。</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoRollbackInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Database <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoRollbackInvocationHandler</span><span class="params">(Database <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">target</span>.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一定还是会有人说，这两种调用方式貌似没有什么区别啊。第二种写法在每次调用的时候不也需要先使用newProxyInstance生成代理类，然后再调用吗，这样反而麻烦了许多。</p>
<p>其实，这两种方式有一个本质上的区别，前者免不了每次都添加<code>try-catch</code>语句。而后者由于是使用模板化的实现，我们可以在框架层帮助用户自动生成动态代理类，自动添加<code>try-catch</code>语句，这样用户就可以使用非常简单的方式实现事务的自动回滚了。例如，在方法上面添加一个自动回滚的注解，框架层识别注解自动生成代理类实例。这样，你需要的仅仅是一个注解而已了。如果你了解Java后端开发，你应该就知道我在说什么了。</p>
<p>以上是动态代理设计模式的一个经典应用场景，但实际上，动态代理的使用场景还有很多。仔细观察动态代理的执行过程，它似乎为我们开辟了一个新的编程方式。相对于传统的流线型编程方式，动态代理可以在任意已经实现的类中的任意方法中插入自定义的逻辑，就像一把刀一样，将代码的执行过程切成片段，再往里插入自定义的逻辑。至此，计算机的编程方式就变成了<strong>cut-insert</strong>（切开-插入）的方式进行。这种编程方式，在计算机科学中，被称之为<strong>面向切面编程（AOP）</strong>。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>动态代理是面向切面编程的一种经典实现。在大部分框架中，实现AOP都会使用JDK自带的动态代理处理。当然，JDK的实现其实也有一定的局限性，这就是为什么CGLIB这样的动态代理库大行其道的原因。不过，这不是本文讨论的重点，大家如果对CGLIB感兴趣的话，可以在文章下方给留言。</p>
<p>说回AOP，到底什么是面向切面编程呢？前面其实已经有了一个简单的解释了，为了让大家看的更直观，我们先来看一张图：</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy3.jpg" alt=""></p>
<p>以上是面向切面编程框架<a href="https://www.eclipse.org/aspectj/" target="_blank" rel="noopener">AspectJ</a>的示例图，AspectJ是一个非常流行面向切面编程Java库。我们就用这张图来给大家讲一下相对于传统编程，面向切面编程到底有什么不同。</p>
<p>图中绿色箭头表示正常代码的执行过程，<strong>PointCut</strong>表示切入点，即在哪个类的哪些位置插入自定义逻辑。<strong>Join Points</strong>表示连接点，即具体的插入位置，例如方法调用前，调用后，异常抛出等等。</p>
<p>由此可见，相当于传统的编程模型，AOP的思考点是：找到匹配的切入点，插入自定义逻辑，而且这种插入对原有框架代码是无侵入性的。相对于面向对象编程模型使用继承的方式进行扩展这种侵入性的处理方式，显然是一个巨大的进步。</p>
<p>正是因为AOP具备高度自由、无侵入性的这些特点，才使得它在Spring等知名开源框架中有着大量的应用，而这一切的核心都依赖于AOP最经典的实现方式：<strong>动态代理</strong>。我想，这应该是动态代理到底有什么用这个问题最好的回答。</p>
<h3 id="JDK实现揭秘"><a href="#JDK实现揭秘" class="headerlink" title="JDK实现揭秘"></a>JDK实现揭秘</h3><p>实际上，在上面的整个探索过程中，我们都是参照JDK实现来进行讲解的。但还有哪些地方是我们考虑不周的呢，一起来看看JDK实现吧。</p>
<p>打开JavaSE官方文档，找到Proxy与InvocationHandler类。</p>
<p><strong>Proxy.java</strong></p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy4.jpg" alt=""></p>
<p><strong>InvocationHandler</strong></p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy5.jpg" alt=""></p>
<p>可以看到，JDK版本的newProxyInstance方法中一个有三个参数，第一个参数是ClassLoader，这就意味着我们可以指定自己的类加载器。第二个参数是接口数组，这是因为需要被代理的接口可能不止一个，或者说代理类实现的接口可能不止一个。这是在我们的版本中没有考虑到的一点，实际使用场景中这种情况其实是很常见的。</p>
<p>JDK版本中，<strong>InvocationHandler</strong>接口的定义与我们的版本是完全一致的。在前一篇文章中，关于这个接口中方法里面几个参数的意思，有不少同学问到，甚至有同学在微信公众号“欧阳锋工作室”给我私信，问到了这个问题。这里统一给大家解答一下：</p>
<p><strong>proxy</strong>：这个参数表示动态生成的代理类实例，在某些场景中你可能需要对代理实例做一些特殊的处理，这个时候，这个参数的作用就出来了，大多数情况下你不需要用到这个参数。</p>
<p><strong>method</strong>：这个参数在前面的文章中其实已经讲过了，它表示实际调用的代理类的接口方法的Method实例，用户可以使用它调用目标代理类的方法。</p>
<p><strong>args</strong>：这个参数表示method对应方法传入的参数值，这里可以提供给method方法反射调用，也可以通过直接调用的方式逐一传入参数值到目标代理类方法中。</p>
<p><strong>返回值</strong>：invoke方法的返回值，这里也有一些同学问到，这个也是上一篇文章中解释不够到位的地方。这一次我们在前面的例子中详细解释了invoke方法的返回值到底有什么作用。它实际上对应的是被代理类对应method方法的返回值。这是与接口方法一一对应的，方便调用者轻松获取到实际代理类方法调用的返回值。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>最后，感谢大家陪伴我走过了这一段艰难的探索旅程，这的确不太容易。如果你完整地看完了整篇文章，并且根据文章的推进过程同步完成了代码开发，应该给自己鼓个掌。因为，这的确不太容易。Java动态代理设计模式是所有设计模式中最难理解的一个。如果你已经看懂了这个设计模式，其它的设计模式就已经是“除却巫山不是云”了。</p>
<p>希望这篇文章说清楚了前一篇文章大家提的每一个问题，也说清楚了动态代理的每一处细节。如果你还有疑问，欢迎在文章下方给我留言，或者来我的微信公众号“欧阳锋工作室”给我发私信。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>例子源码：<a href="https://github.com/yuanhoujun/java-dynamic-proxy" target="_blank" rel="noopener">https://github.com/yuanhoujun/java-dynamic-proxy</a></p>
<p>上一篇：<a href="http://youngfeng.com/2018/03/02/design%20pattern/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">点这里前往</a></p>
<p>关注微信公众号”欧阳锋工作室“，阅读更多文章。</p>
<p><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>理解Kotlin语言独有的位置注解，让注解控制更精准</title>
    <url>/2019/11/15/%E7%90%86%E8%A7%A3Kotlin%E8%AF%AD%E8%A8%80%E7%8B%AC%E6%9C%89%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%B3%A8%E8%A7%A3%EF%BC%8C%E8%AE%A9%E6%B3%A8%E8%A7%A3%E6%8E%A7%E5%88%B6%E6%9B%B4%E7%B2%BE%E5%87%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>在Kotlin语言编写的代码中，你应该看到过类似这样的注解<code>@file:JvmName(...)</code>，这有点难以理解，正常的注解不会存在类似<code>@file:</code>这样的前缀，在Java语言中也没有类似的语法。那么，这到底有什么作用呢？<a id="more"></a> 由于其特殊的作用，我把它称之为”位置注解“。</p>
</blockquote>
<p>Kotlin语言是一门将语法简化到极致的编程语言，我们一起来看一段简单的代码：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="built_in">String</span>? = <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段极其简单的代码，经过Kotlin编译器的处理，等价于下面这段Java代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setName(<span class="meta">@Nullable</span> String var1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = var1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然在Kotlin语言中，看起来只是声明了一个成员变量，实际上编译后不仅声明了一个成员变量<code>name</code>，还生成了与之对应的<code>setter/getter</code>方法。</p>
<p>这个时候，问题来了，如果我们在<code>Person</code>类的<code>name</code>属性上方添加一个注解，会出现什么问题呢？</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="keyword">var</span> name: <span class="built_in">String</span>? = <span class="keyword">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们刚才说到，实际生成的字节码中包含了<code>setter/getter</code>方法，那么这个注解可能出现的位置就有4个地方：</p>
<ul>
<li>属性（成员变量name）</li>
<li>setter方法</li>
<li>setter方法参数name</li>
<li>getter方法</li>
</ul>
<p>用代码来表示，具体可能出现的位置如下图所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 位置一：属性</span></span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 位置二：setter方法</span></span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setName(<span class="comment">/*位置三：setter方法参数*/</span> <span class="meta">@Nullable</span> String var1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = var1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 位置四：getter方法</span></span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时候编译器晕菜了，它无法确定你到底想要让注解出现在什么位置。那么，这种情况下，Kotlin编译器究竟会怎么做呢？感兴趣的同学不妨自己做做实验。</p>
<p>那么，是否有办法使注解准确地出现在指定位置呢？答案是：当然有！位置注解恰好就是用来解决这个问题的。</p>
<p>我们将上面的代码添加位置注解，修改为下面这样：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span> &#123;</span><br><span class="line">    <span class="variable">@field:</span>Callable</span><br><span class="line">    var <span class="attribute">name</span>: String? = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过添加位置注解<code>@field</code>，    <code>@Callable</code>注解将准确出现在属性定义的位置，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注解将出现在这里</span></span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setName(<span class="meta">@Nullable</span> String var1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = var1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应上述其它三个位置的位置注解分别是：</p>
<ul>
<li>set: 对应setter方法位置</li>
<li>get：对应getter方法位置</li>
<li>setparam：对应setter方法参数位置</li>
</ul>
<p>除此之外，Kotlin还提供了以下几个位置注解，对应其它不同使用场景：</p>
<h3 id="file"><a href="#file" class="headerlink" title="@file:"></a>@file:</h3><p>这个注解用在文件级别，每一个Kotlin文件对应一个或多个Java类，当对应一个类的时候，可通过添加该位置注解，结合上一节课讲到的注解<code>@JvmName</code>一起使用，可改变生成的Java类名。</p>
<p>你可以理解为这个注解实际作用的位置就是最终编译生成的Java类。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@file:</span>JvmName(<span class="string">"FooKt"</span>)</span><br><span class="line">fun foo() &#123;</span><br><span class="line">    <span class="selector-tag">println</span>(<span class="string">"Hello, world..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终生成的代码类似下面这样，生成的类名恰好是注解上方所填写的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@JvmName</span>(<span class="string">"FooKt"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FooKt</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="param"><a href="#param" class="headerlink" title="@param:"></a>@param:</h3><p>这个注解的作用是使注解出现的位置定位到构造函数的参数上面。</p>
<p>大家知道，在Kotlin语言中，如果在构造函数参数前面添加<code>var</code>或<code>val</code>关键词，在对应类中会生成相应的属性、setter、getter方法。</p>
<p>为了让注解准确地出现在其构造函数参数的位置，这个注解就应运而生了！</p>
<p>我们继续来看一个例子：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span>(<span class="variable">@param</span>:Callable var <span class="attribute">name</span>: String)</span><br></pre></td></tr></table></figure>
<p>添加上述位置注解后，最终生成的注解就会出现在构造函数参数的位置，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> void setName(<span class="meta">@NotNull</span> String var1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = var1;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 注解最终出现在了这里</span></span><br><span class="line">   <span class="keyword">public</span> Person(<span class="meta">@Callable</span> <span class="meta">@NotNull</span> String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="property"><a href="#property" class="headerlink" title="@property:"></a>@property:</h3><p>这是一个特殊的位置注解，这个注解对于Java端是不可见的，其代表的位置是对应属性的Property对象。这样说起来有点抽象，我们来看一个例子，先来了解一下<code>Property</code>到底是什么东西。</p>
<p>我们继续以<code>Person</code>类为例，通过下面一段代码去访问它：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">"Scott"</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> propertyName = person::name</span><br><span class="line">    <span class="comment">// 这里将打印 name: falsee</span></span><br><span class="line">    println(<span class="string">"<span class="subst">$&#123;propertyName.name&#125;</span>: <span class="subst">$&#123;propertyName.isConst&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，propertyName对应的就是<code>Person</code>类中<code>name</code>属性的Property实例，简单来说就是，Property保存了对应属性的相关信息，代表了当前属性。通过Property可以获取到当前属性的相关信息（包括变量的名称，是否常量，是否延迟初始化等等）。</p>
<p>如果在构造函数的<code>name</code>前面添加位置注解<code>@property:</code>，注解生成的位置会稍微有点难以理解。访问这个注解的唯一方法就是通过其Property实例，我们一起来试一下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">class</span> <span class="selector-tag">Person</span>(<span class="variable">@property</span>:Callable var <span class="attribute">name</span>: String)</span><br></pre></td></tr></table></figure>
<p>访问该注解的唯一方式是通过其Property实例，并且Java端无法访问到：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">"Scott"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> propertyName = person::name</span><br><span class="line">    <span class="comment">// 访问该注解的唯一方式</span></span><br><span class="line">    println(propertyName.annotations.find &#123; it.annotationClass == Callable::<span class="class"><span class="keyword">class</span> &#125;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，具体到字节码，该注解到底出现在了哪里呢？我们不妨来反编译看一看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 注解出现在了这里，非常特殊的一个位置</span></span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> name$annotations() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(@NotNull String var1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = var1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(@NotNull String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到注解出现在了Kotlin编译器生成的一个以属性名称加<strong>$</strong>与<strong>annotations</strong>后缀作为方法命名的静态方法上。这是Kotlin编译器约定的一个特殊方法，通过Property实例可以准确访问到这里。</p>
<p>而知道了这个约定命名方式之后，事实上Java端也可以通过特殊的方式来访问到该注解，严格来讲，Java无法访问并不准确。</p>
<h3 id="receiver："><a href="#receiver：" class="headerlink" title="@receiver："></a>@receiver：</h3><p>这也是一个非常特殊的位置注解，Kotlin支持扩展函数，即在不通过继承的情况下对原有类扩展函数或属性。扩展中有一个很重要的概念就是<strong>receiver</strong>，所谓的receiver，就是指被扩展类的实例本身。</p>
<p>但问题来了，扩展并不会改变原有类的代码，如何将注解放到<strong>receiver</strong>位置呢，这似乎是一个不可能完成的事情。</p>
<p>这就要说到扩展的实现原理了，扩展实际上对应Kotlin中的一个全局函数，当转换到字节码的时候，函数的第一个参数就是receiver本身。这样说起来可能比较抽象，我们直接来看一个例子：</p>
<p>我们先对<code>Person</code>类增加扩展函数<code>sayHi</code>: </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Person.<span class="title">sayHi</span><span class="params">(greet: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    println(<span class="string">"<span class="variable">$greet</span>, <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后反编译查看最终得到的Java代码：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> final void sayHi(<span class="symbol">@NotNull</span> Person $receiver, <span class="symbol">@NotNull</span> <span class="built_in">String</span> greet) &#123;</span><br><span class="line">  <span class="built_in">String</span> var2 = greet + <span class="string">", "</span> + $receiver.getName()<span class="comment">;</span></span><br><span class="line">  System.out.println(var2)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Kotlin编译器生成了一个静态方法，静态方法的第一个参数就是<code>receiver</code>，对应扩展类实例本身，第二个参数是扩展函数实际的参数。</p>
<p>这就是Kotlin扩展的实现原理，其最终是通过增加静态函数来实现的，扩展函数的第一个参数永远指向被扩展类的实例，即receiver。而我们添加了位置注解<code>@receiver</code>之后，注解生成的位置就会出现在扩展函数第一个参数的位置，类似下面这样：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">static</span> final void sayHi(<span class="symbol">@Callable</span> <span class="symbol">@NotNull</span> Person $receiver, <span class="symbol">@NotNull</span> <span class="built_in">String</span> greet) &#123;</span><br><span class="line">  <span class="built_in">String</span> var2 = greet + <span class="string">", "</span> + $receiver.getName()<span class="comment">;</span></span><br><span class="line">  System.out.println(var2)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就是<code>@receiver</code>位置注解的作用，理解了扩展函数的原理，这个注解的作用就不难理解了。</p>
<h3 id="delegate"><a href="#delegate" class="headerlink" title="@delegate"></a>@delegate</h3><p>这是今天我们要说的最后一个位置注解，这又是一个相对比较难理解的位置注解，因为在Java语言中并不存在类似的概念。在Kotlin语言中代理模式大行其道，Kotlin语言使用<code>by</code>关键字就可以轻松实现代理模式。</p>
<p>这里存在一个同样的问题，前面我们说过，在Kotlin类中声明一个属性实际会同时生成<code>setter/getter</code>方法，这样注解可能出现的位置除属性之外就是三处（setter/getter/setter参数)。而如果属性本身使用代理的方式生成，这里就多了一个位置：<strong>代理类属性</strong>的位置。</p>
<p>这样说，可能还不太直观，我们用官方的<code>lazy</code>实现来举一个例子。</p>
<p>我们在<code>Person</code>类中增加一个代理属性<code>gender</code>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String) &#123;</span><br><span class="line">    <span class="meta">@delegate:Callable</span></span><br><span class="line">    <span class="keyword">val</span> gender <span class="keyword">by</span> lazy &#123; <span class="string">"male"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>老规矩，我们还是直接反编译得到Java代码再来分析：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 注解出现在了这个位置</span></span><br><span class="line">   <span class="comment">// 也就是真正的代理类实例的位置</span></span><br><span class="line">   <span class="meta">@Callable</span></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Lazy gender$delegate;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@NotNull</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">final</span> String getGender() &#123;</span><br><span class="line">      Lazy var1 = <span class="keyword">this</span>.gender$delegate;</span><br><span class="line">      <span class="keyword">return</span> (String)var1.getValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Person(<span class="meta">@NotNull</span> String name) &#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.gender$delegate = LazyKt.lazy((Function0)<span class="literal">null</span>.INSTANCE);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码，我们可以清晰地看到Kotlin编译器在类中生成真正的代理类实例属性，<code>gender</code>的值实际是从代理对象中获取的。这个位置注解的作用就是将注解精确地放置到代理类的实例属性上方。</p>
<h3 id="默认位置注解优先级"><a href="#默认位置注解优先级" class="headerlink" title="默认位置注解优先级"></a>默认位置注解优先级</h3><p>位置注解在Kotlin语言中并不是强制要求的，我们可以不添加位置注解，在未添加位置注解的情况下，Kotlin语言会按照下面的优先级将注解放置到指定的位置（如果注解可以同时出现在多个位置的话）：</p>
<p><code>param</code> &gt; <code>property</code> &gt; <code>field</code></p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>以上就是Kotlin语言中我们可以用到的所有位置注解，这是因为Kotlin语言将语法简化到了极致，我们才需要这些注解精确地告诉编译器需要将注解放置到哪里。如果你需要在代码中添加注解，应该始终记得增加位置注解，以便注解可以精确地放置到你想要放置的位置，避免出现一些不必要的麻烦。</p>
<p>阅读更多技术文章，请关注微信公众号”欧阳锋工作室“</p>
<p><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>
<p>参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958</p>
]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>10分钟看懂动态代理设计模式</title>
    <url>/2018/03/02/design%20pattern/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。本文将通过一个简单的例子模拟JDK动态代理实现，让你彻底明白动态代理设计模式的本质<a id="more"></a>，文章中可能会涉及到一些你没有学习过的知识点或概念。如果恰好遇到了这些知识盲点，请先去学习这部分知识，再来阅读这篇文章。</p>
</blockquote>
<h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h3><p>从字面意思来看，代理比较好理解，无非就是代为处理的意思。举个例子，你在上大学的时候，总是喜欢逃课。因此，你拜托你的同学帮你答到，而自己却窝在宿舍玩游戏… 你的这个同学恰好就充当了代理的作用，代替你去上课。</p>
<p>是的，你没有看错，代理就是这么简单！</p>
<p>理解了代理的意思，你脑海中恐怕还有两个巨大的疑问：</p>
<ul>
<li>怎么实现代理模式</li>
<li>代理模式有什么实际用途</li>
</ul>
<p>要理解这两个问题，看一个简单的例子：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bird is flying..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很简单的一个例子，用一个随机睡眠时间模拟小鸟在空中的飞行时间。接下来问题来了，如果我要知道小鸟在天空中飞行了多久，怎么办？</p>
<p>有人说，很简单，在Bird-&gt;fly()方法的开头记录起始时间，在方法结束记录完成时间，两个时间相减就得到了飞行时间。<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> fly() &#123;</span><br><span class="line">     <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">     System.out.<span class="built_in">println</span>(<span class="string">"Bird is flying..."</span>);</span><br><span class="line">     <span class="built_in">try</span> &#123;</span><br><span class="line">         Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">     &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">     System.out.<span class="built_in">println</span>(<span class="string">"Fly time = "</span> + (<span class="built_in">end</span> - start));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>的确，这个方法没有任何问题，接下来加大问题的难度。如果Bird这个类来自于某个SDK（或者说Jar包）提供，你无法改动源码，怎么办？</p>
<p>一定会有人说，我可以在调用的地方这样写：<br><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        Bird bird = <span class="keyword">new</span> Bird();</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        bird.fly();</span><br><span class="line">        <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="string">"Fly time = "</span> + (<span class="built_in">end</span> - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方案看起来似乎没有问题，但其实你忽略了准备这些方法所需要的时间，执行一个方法，需要开辟栈内存、压栈、出栈等操作，这部分时间也是不可以忽略的。因此，这个解决方案不可行。那么，还有什么方法可以做到呢？</p>
<h5 id="a）使用继承"><a href="#a）使用继承" class="headerlink" title="a）使用继承"></a>a）使用继承</h5><p>继承是最直观的解决方案，相信你已经想到了，至少我最开始想到的解决方案就是继承。<br>为此，我们重新创建一个类Bird2，在Bird2中我们只做一件事情，就是调用父类的fly方法，在前后记录时间，并打印时间差：<br><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Bird2</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        long start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        </span><br><span class="line">        long end = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Fly time = "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一种解决方案，还有一种解决方案叫做：<strong>聚合</strong>，其实也是比较容易想到的。<br>我们再次创建新类Bird3，在Bird3的构造方法中传入Bird实例。同时，让Bird3也实现Flyable接口，并在fly方法中调用传入的Bird实例的fly方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird3</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bird bird;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird3</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bird = bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        bird.fly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fly time = "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了记录Bird-&gt;fly()方法的执行时间，我们在前后添加了记录时间的代码。同样地，通过这种方法我们也可以获得小鸟的飞行时间。那么，这两种方法孰优孰劣呢？咋一看，不好评判！</p>
<p>继续深入思考，用问题推导来解答这个问题：</p>
<p><strong>问题一</strong>：如果我还需要在fly方法前后打印日志，记录飞行开始和飞行结束，怎么办？<br>有人说，很简单！继承Bird2并在在前后添加打印语句即可。那么，问题来了，请看问题二。</p>
<p><strong>问题二</strong>：如果我需要调换执行顺序，先打印日志，再获取飞行时间，怎么办？<br>有人说，再新建一个类Bird4继承Bird，打印日志。再新建一个类Bird5继承Bird4，获取方法执行时间。</p>
<p>问题显而易见：使用继承将导致类无限制扩展，同时灵活性也无法获得保障。那么，使用 <a href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" target="_blank" rel="noopener">聚合</a> 是否可以避免这个问题呢？<br>答案是：可以！但我们的类需要稍微改造一下。修改Bird3类，将聚合对象Bird类型修改为Flyable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird3</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird3</span><span class="params">(Flyable flyable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyable = flyable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        flyable.fly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fly time = "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让你看的更清楚，我将Bird3更名为BirdTimeProxy，即用于获取方法执行时间的代理的意思。同时我们新建BirdLogProxy代理类用于打印日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BirdLogProxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BirdLogProxy</span><span class="params">(Flyable flyable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flyable = flyable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bird fly start..."</span>);</span><br><span class="line"></span><br><span class="line">        flyable.fly();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Bird fly end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来神奇的事情发生了，如果我们需要先记录日志，再获取飞行时间，可以在调用的地方这么做：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">public</span> static void main(<span class="keyword">String[] </span>args) &#123;</span><br><span class="line">    <span class="keyword">Bird </span><span class="keyword">bird </span>= new <span class="keyword">Bird();</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">BirdLogProxy </span><span class="built_in">p1</span> = new <span class="keyword">BirdLogProxy(bird);</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">BirdTimeProxy </span><span class="built_in">p2</span> = new <span class="keyword">BirdTimeProxy(p1);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   <span class="built_in">p2</span>.fly()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反过来，可以这么做：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">public</span> static void main(<span class="keyword">String[] </span>args) &#123;</span><br><span class="line">       <span class="keyword">Bird </span><span class="keyword">bird </span>= new <span class="keyword">Bird();</span></span><br><span class="line"><span class="keyword"> </span>      <span class="keyword">BirdTimeProxy </span><span class="built_in">p2</span> = new <span class="keyword">BirdTimeProxy(bird);</span></span><br><span class="line"><span class="keyword"> </span>      <span class="keyword">BirdLogProxy </span><span class="built_in">p1</span> = new <span class="keyword">BirdLogProxy(p2);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>      <span class="built_in">p1</span>.fly()<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，有同学可能会有疑问了。虽然现象看起来，聚合可以灵活调换执行顺序。可是，为什么 <a href="https://stackoverflow.com/questions/885937/what-is-the-difference-between-association-aggregation-and-composition" target="_blank" rel="noopener">聚合</a> 可以做到，而继承不行呢。我们用一张图来解释一下：<br><img src="http://upload-images.jianshu.io/upload_images/703764-2d04ad5bbcb2d25e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>接下来，观察上面的类BirdTimeProxy，在它的fly方法中我们直接调用了flyable-&gt;fly()方法。换而言之，BirdTimeProxy其实代理了传入的Flyable对象，这就是典型的静态代理实现。</p>
<p>从表面上看，静态代理已经完美解决了我们的问题。可是，试想一下，如果我们需要计算SDK中100个方法的运行时间，同样的代码至少需要重复100次，并且创建至少100个代理类。往小了说，如果Bird类有多个方法，我们需要知道其他方法的运行时间，同样的代码也至少需要重复多次。因此，静态代理至少有以下两个局限性问题：</p>
<ul>
<li>如果同时代理多个类，依然会导致类无限制扩展</li>
<li>如果类中有多个方法，同样的逻辑需要反复实现</li>
</ul>
<p>那么，我们是否可以使用同一个代理类来代理任意对象呢？我们以获取方法运行时间为例，是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢？甚至再大胆一点，代理的逻辑也可以自己指定。比如，获取方法的执行时间，打印日志，这类逻辑都可以自己指定。这就是本文重点探讨的问题，也是最难理解的部分：<strong>动态代理</strong>。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>继续回到上面这个问题：是否可以使用同一个类（例如：TimeProxy）来计算任意对象的任一方法的执行时间呢。</p>
<p>这个部分需要一定的抽象思维，我想，你脑海中的第一个解决方案应该是使用反射。反射是用于获取已创建实例的方法或者属性，并对其进行调用或者赋值。很明显，在这里，反射解决不了问题。但是，再大胆一点，如果我们可以动态生成TimeProxy这个类，并且动态编译。然后，再通过反射创建对象并加载到内存中，不就实现了对任意对象进行代理了吗？为了防止你依然一头雾水，我们用一张图来描述接下来要做什么：<br><img src="http://upload-images.jianshu.io/upload_images/703764-0e22137ce1f0291b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>动态生成Java源文件并且排版是一个非常繁琐的工作，为了简化操作，我们使用 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 这个第三方库帮我们生成TimeProxy的源码。希望 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a>  不要成为你的负担，不理解 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 没有关系，你只要把它当成一个Java源码生成工具使用即可。</p>
<p>PS：你记住，任何工具库的使用都不会太难，它是为了简化某些操作而出现的，目标是简化而不是繁琐。因此，只要你适应它的规则就轻车熟路了。</p>
<h5 id="第一步：生成TimeProxy源码"><a href="#第一步：生成TimeProxy源码" class="headerlink" title="第一步：生成TimeProxy源码"></a>第一步：生成TimeProxy源码</h5><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Proxy &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(<span class="string">"TimeProxy"</span>)</span><br><span class="line">                .addSuperinterface(Flyable.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(Flyable.<span class="keyword">class</span>, <span class="string">"flyable"</span>, Modifier.<span class="keyword">PRIVATE</span>).build();</span><br><span class="line">        typeSpecBuilder.addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">        MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(Flyable.<span class="keyword">class</span>, <span class="string">"flyable"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.flyable = flyable"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        typeSpecBuilder.addMethod(constructorMethodSpec);</span><br><span class="line"></span><br><span class="line">        Method[] methods = Flyable.<span class="keyword">class</span>.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>)</span><br><span class="line">                    .returns(method.getReturnType())</span><br><span class="line">                    .addStatement(<span class="string">"long start = $T.currentTimeMillis()"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .addCode(<span class="string">"\n"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"this.flyable."</span> + method.getName() + <span class="string">"()"</span>)</span><br><span class="line">                    .addCode(<span class="string">"\n"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"long end = $T.currentTimeMillis()"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"$T.out.println(\"Fly Time =\" + (end - start))"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .build();</span><br><span class="line">            typeSpecBuilder.addMethod(methodSpec);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.proxy"</span>, typeSpecBuilder.build()).build();</span><br><span class="line">        <span class="comment">// 为了看的更清楚，我将源码文件生成到桌面</span></span><br><span class="line">        javaFile.writeTo(<span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">"/Users/ouyangfeng/Desktop/"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在main方法中调用Proxy.newProxyInstance()，你将看到桌面已经生成了TimeProxy.java文件，生成的内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youngfeng.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.System;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Flyable flyable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimeProxy</span><span class="params">(Flyable flyable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flyable = flyable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.flyable.fly();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"Fly Time ="</span> + (end - start));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="第二步：编译TimeProxy源码"><a href="#第二步：编译TimeProxy源码" class="headerlink" title="第二步：编译TimeProxy源码"></a>第二步：编译TimeProxy源码</h5><p>编译TimeProxy源码我们直接使用JDK提供的编译工具即可，为了使你看起来更清晰，我使用一个新的辅助类来完成编译操作：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> JavaCompiler &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="keyword">compile</span>(<span class="keyword">File</span> javaFile) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(javaFile);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Proxy-&gt;newProxyInstance()方法中调用该方法，编译顺利完成：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了看的更清楚，我将源码文件生成到桌面</span></span><br><span class="line"><span class="keyword">String</span> sourcePath = <span class="string">"/Users/ouyangfeng/Desktop/"</span>;</span><br><span class="line">javaFile.writeTo(<span class="keyword">new</span> <span class="built_in">File</span>(sourcePath));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译</span></span><br><span class="line">JavaCompiler.compile(<span class="keyword">new</span> <span class="built_in">File</span>(sourcePath + <span class="string">"/com/youngfeng/proxy/TimeProxy.java"</span>));</span><br></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/703764-0e82c03cdd902aaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="第三步：加载到内存中并创建对象"><a href="#第三步：加载到内存中并创建对象" class="headerlink" title="第三步：加载到内存中并创建对象"></a>第三步：加载到内存中并创建对象</h5><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">URL[] urls = <span class="keyword">new</span> <span class="type">URL</span>[] &#123;<span class="keyword">new</span> <span class="type">URL</span>(<span class="string">"file:/"</span> + sourcePath)&#125;;</span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> <span class="type">URLClassLoader</span>(urls);</span><br><span class="line">Class clazz = classLoader.loadClass(<span class="string">"com.youngfeng.proxy.TimeProxy"</span>);</span><br><span class="line">Constructor constructor = clazz.getConstructor(Flyable.class);</span><br><span class="line">Flyable flyable = (Flyable) constructor.<span class="keyword">new</span><span class="type">Instance</span>(<span class="keyword">new</span> <span class="type">Bird</span>());</span><br><span class="line">flyable.fly();</span><br></pre></td></tr></table></figure>
<p>通过以上三个步骤，我们至少解决了下面两个问题：</p>
<ul>
<li>不再需要手动创建TimeProxy</li>
<li>可以代理任意实现了Flyable接口的类对象，并获取接口方法的执行时间</li>
</ul>
<p>可是，说好的任意对象呢？</p>
<h5 id="第四步：增加InvocationHandler接口"><a href="#第四步：增加InvocationHandler接口" class="headerlink" title="第四步：增加InvocationHandler接口"></a>第四步：增加InvocationHandler接口</h5><p>查看Proxy-&gt;newProxyInstance()的源码，代理类继承的接口我们是写死的，为了增加灵活性，我们将接口类型作为参数传入：<br><img src="http://upload-images.jianshu.io/upload_images/703764-cd110b5720d14823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接口的灵活性问题解决了，TimeProxy的局限性依然存在，它只能用于获取方法的执行时间，而如果要在方法执行前后打印日志则需要重新创建一个代理类，显然这是不妥的！</p>
<p>为了增加控制的灵活性，我们考虑针将代理的处理逻辑也抽离出来（这里的处理就是打印方法的执行时间）。新增<code>InvocationHandler</code>接口，用于处理自定义逻辑：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>InvocationHandler &#123;</span><br><span class="line">    void invoke(Object proxy, Method method, Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>想象一下，如果客户程序员需要对代理类进行自定义的处理，只要实现该接口，并在invoke方法中进行相应的处理即可。这里我们在接口中设置了三个参数（其实也是为了和JDK源码保持一致）：</p>
<ul>
<li>proxy =&gt; 这个参数指定动态生成的代理类，这里是<code>TimeProxy</code></li>
<li>method =&gt; 这个参数表示传入接口中的所有Method对象</li>
<li>args =&gt; 这个参数对应当前method方法中的参数</li>
</ul>
<p>引入了InvocationHandler接口之后，我们的调用顺序应该变成了这样：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MyInvocationHandler handler = new MyInvocationHandler();</span><br><span class="line">Flyable<span class="built_in"> proxy </span>= Proxy.newProxyInstance(Flyable.class, handler);</span><br><span class="line">proxy.fly();</span><br><span class="line"></span><br><span class="line">方法执行流：proxy.fly() =&gt; handler.invoke()</span><br></pre></td></tr></table></figure>
<p>为此，我们需要在Proxy.newProxyInstance()方法中做如下改动：</p>
<ul>
<li>在newProxyInstance方法中传入InvocationHandler</li>
<li>在生成的代理类中增加成员变量handler</li>
<li>在生成的代理类方法中，调用invoke方法</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(<span class="keyword">Class</span> inf, InvocationHandler handler) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(<span class="string">"TimeProxy"</span>)</span><br><span class="line">               .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">               .addSuperinterface(inf);</span><br><span class="line"></span><br><span class="line">       FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"handler"</span>, Modifier.<span class="keyword">PRIVATE</span>).build();</span><br><span class="line">       typeSpecBuilder.addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">       MethodSpec constructorMethodSpec = MethodSpec.constructorBuilder()</span><br><span class="line">               .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">               .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"handler"</span>)</span><br><span class="line">               .addStatement(<span class="string">"this.handler = handler"</span>)</span><br><span class="line">               .build();</span><br><span class="line"></span><br><span class="line">       typeSpecBuilder.addMethod(constructorMethodSpec);</span><br><span class="line"></span><br><span class="line">       Method[] methods = inf.getDeclaredMethods();</span><br><span class="line">       <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">           MethodSpec methodSpec = MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                   .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                   .addAnnotation(Override.<span class="keyword">class</span>)</span><br><span class="line">                   .returns(method.getReturnType())</span><br><span class="line">                   .addCode(<span class="string">"try &#123;\n"</span>)</span><br><span class="line">                   .addStatement(<span class="string">"\t$T method = "</span> + inf.getName() + <span class="string">".class.getMethod(\""</span> + method.getName() + <span class="string">"\")"</span>, Method.<span class="keyword">class</span>)</span><br><span class="line">                   <span class="comment">// 为了简单起见，这里参数直接写死为空</span></span><br><span class="line">                   .addStatement(<span class="string">"\tthis.handler.invoke(this, method, null)"</span>)</span><br><span class="line">                   .addCode(<span class="string">"&#125; catch(Exception e) &#123;\n"</span>)</span><br><span class="line">                   .addCode(<span class="string">"\te.printStackTrace();\n"</span>)</span><br><span class="line">                   .addCode(<span class="string">"&#125;\n"</span>)</span><br><span class="line">                   .build();</span><br><span class="line">           typeSpecBuilder.addMethod(methodSpec);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.proxy"</span>, typeSpecBuilder.build()).build();</span><br><span class="line">       <span class="comment">// 为了看的更清楚，我将源码文件生成到桌面</span></span><br><span class="line">       String sourcePath = <span class="string">"/Users/ouyangfeng/Desktop/"</span>;</span><br><span class="line">       javaFile.writeTo(<span class="keyword">new</span> <span class="keyword">File</span>(sourcePath));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 编译</span></span><br><span class="line">       JavaCompiler.<span class="keyword">compile</span>(<span class="keyword">new</span> <span class="keyword">File</span>(sourcePath + <span class="string">"/com/youngfeng/proxy/TimeProxy.java"</span>));</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用反射load到内存</span></span><br><span class="line">       URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + sourcePath)&#125;;</span><br><span class="line">       URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">       <span class="keyword">Class</span> clazz = classLoader.loadClass(<span class="string">"com.youngfeng.proxy.TimeProxy"</span>);</span><br><span class="line">       Constructor constructor = clazz.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">       Object obj = constructor.newInstance(handler);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码你可能看起来比较吃力，我们直接调用该方法，查看最后生成的源码。在main方法中测试newProxyInstance查看生成的TimeProxy源码：</p>
<p><strong>测试代码</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">Proxy.<span class="keyword">new</span><span class="type">ProxyInstance</span>(Flyable.class, <span class="keyword">new</span> <span class="type">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="type">Bird</span>()));</span><br></pre></td></tr></table></figure>
<p><strong>生成的TimeProxy.java源码</strong></p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youngfeng.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeProxy</span> <span class="keyword">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> InvocationHandler <span class="keyword">handler</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimeProxy</span><span class="params">(InvocationHandler <span class="keyword">handler</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">handler</span> = <span class="keyword">handler</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	Method method = com.youngfeng.proxy.Flyable.class.getMethod(<span class="string">"fly"</span>);</span><br><span class="line">    	<span class="keyword">this</span>.<span class="keyword">handler</span>.invoke(<span class="keyword">this</span>, method, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>MyInvocationHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Bird bird;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Bird bird)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bird = bird;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(bird, <span class="keyword">new</span> Object[] &#123;&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Fly time = "</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个方法栈的调用栈变成了这样：<br><img src="http://upload-images.jianshu.io/upload_images/703764-4ff1323a12cb9c39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>看到这里，估计很多同学已经晕了，在静态代理部分，我们在代理类中传入了被代理对象。可是，使用newProxyInstance生成动态代理对象的时候，我们居然不再需要传入被代理对象了。我们传入了的实际对象是InvocationHandler实现类的实例，这看起来有点像生成了InvocationHandler的代理对象，在动态生成的代理类的任意方法中都会间接调用InvocationHandler-&gt;invoke(proxy, method, args)方法。</p>
<p>其实的确是这样。TimeProxy真正代理的对象就是InvocationHandler，不过这里设计的巧妙之处在于，InvocationHandler是一个接口，真正的实现由用户指定。另外，在每一个方法执行的时候，invoke方法都会被调用 ，这个时候如果你需要对某个方法进行自定义逻辑处理，可以根据method的特征信息进行判断分别处理。</p>
<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>上面这段解释是告诉你在执行Proxy-&gt;newProxyInstance方法的时候真正发生的事情，而在实际使用过程中你完全可以忘掉上面的解释。按照设计者的初衷，我们做如下简单归纳：</p>
<ul>
<li>Proxy-&gt;newProxyInstance(infs, handler) 用于生成代理对象</li>
<li>InvocationHandler：这个接口主要用于自定义代理逻辑处理</li>
<li>为了完成对被代理对象的方法拦截，我们需要在InvocationHandler对象中传入被代理对象实例。</li>
</ul>
<p>查看上面的代码，你可以看到我将Bird实例已经传入到了MyInvocationHandler中，原因就是第三点。</p>
<p>这样设计有什么好处呢？有人说，我们大费周章，饶了一大圈，最终变成了这个样子，到底图什么呢？</p>
<p>想象一下，到此为止，如果我们还需要对其它任意对象进行代理，是否还需要改动newProxyInstance方法的源码，答案是：完全不需要！</p>
<p>只要你在newProxyInstance方法中指定代理需要实现的接口，指定用于自定义处理的InvocationHandler对象，整个代理的逻辑处理都在你自定义的InvocationHandler实现类中进行处理。至此，而我们终于可以从不断地写代理类用于实现自定义逻辑的重复工作中解放出来了，从此需要做什么，交给InvocationHandler。</p>
<p>事实上，我们之前给自己定下的目标“使用同一个类来计算任意对象的任一方法的执行时间”已经实现了。严格来说，是我们超额完成了任务，TimeProxy不仅可以计算方法执行的时间，也可以打印方法执行日志，这完全取决于你的InvocationHandler接口实现。因此，这里取名为TimeProxy其实已经不合适了。我们可以修改为和JDK命名一致，即$Proxy0，感兴趣的同学请自行实践，本篇文章的代码将放到我的Github仓库，文章结尾会给出代码地址。</p>
<h3 id="JDK实现揭秘"><a href="#JDK实现揭秘" class="headerlink" title="JDK实现揭秘"></a>JDK实现揭秘</h3><p>通过上面的这些步骤，我们完成了一个简易的仿JDK实现的动态代理逻辑。接下来，我们一起来看一看JDK实现的动态代理和我们到底有什么不同。</p>
<p><strong>Proxy.java</strong><br><img src="http://upload-images.jianshu.io/upload_images/703764-2f5a7b2762949e11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>InvocationHandler</strong><br><img src="http://upload-images.jianshu.io/upload_images/703764-9d58bd4930a28081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看到，官方版本Proxy类提供的方法多一些，而我们主要使用的接口newProxyInstance参数也和我们设计的不太一样。这里给大家简单解释一下，每个参数的意义：</p>
<ul>
<li>Classloader：类加载器，你可以使用自定义的类加载器，我们的实现版本为了简化，直接在代码中写死了Classloader。</li>
<li>Class&lt;?&gt;[]：第二个参数也和我们的实现版本不一致，这个其实很容易理解，我们应该允许我们自己实现的代理类同时实现多个接口。前面设计只传入一个接口，只是为了简化实现，让你专注核心逻辑实现而已。</li>
</ul>
<p>最后一个参数就不用说了，和我们实现的版本完全是一样的。</p>
<p>仔细观察官方版本的InvocationHandler，它和我们自己的实现的版本也有一个细微的差别：官方版本invoke方法有返回值，而我们的版本中是没有返回值的。那么，返回值到底有什么作用呢？直接来看官方文档：<br><img src="http://upload-images.jianshu.io/upload_images/703764-940eef4374694714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><em>核心思想：这里的返回值类型必须和传入接口的返回值类型一致，或者与其封装对象的类型一致。</em></p>
<p>遗憾的是，这里并没有说明返回值的用途，其实这里稍微发挥一下想象力就知道了。在我们的版本实现中，Flyable接口的所有方法都是没有返回值的，问题是，如果有返回值呢？是的，你没有猜错，这里的invoke方法对应的就是传入接口中方法的返回值。</p>
<h3 id="答疑解惑"><a href="#答疑解惑" class="headerlink" title="答疑解惑"></a>答疑解惑</h3><h5 id="invoke方法的第一个参数proxy到底有什么作用？"><a href="#invoke方法的第一个参数proxy到底有什么作用？" class="headerlink" title="invoke方法的第一个参数proxy到底有什么作用？"></a>invoke方法的第一个参数proxy到底有什么作用？</h5><p>这个问题其实也好理解，如果你的接口中有方法需要返回自身，如果在invoke中没有传入这个参数，将导致实例无法正常返回。在这种场景中，proxy的用途就表现出来了。简单来说，这其实就是最近非常火的链式编程的一种应用实现。</p>
<h5 id="动态代理到底有什么用？"><a href="#动态代理到底有什么用？" class="headerlink" title="动态代理到底有什么用？"></a>动态代理到底有什么用？</h5><p>学习任何一门技术，一定要问一问自己，这到底有什么用。其实，在这篇文章的讲解过程中，我们已经说出了它的主要用途。你发现没，使用动态代理我们居然可以在不改变源码的情况下，直接在方法中插入自定义逻辑。这有点不太符合我们的一条线走到底的编程逻辑，这种编程模型有一个专业名称叫 <a href="https://baike.baidu.com/item/AOP/1332219" target="_blank" rel="noopener">AOP</a>。所谓的AOP，就像刀一样，抓住时机，趁机插入。<br><img src="http://upload-images.jianshu.io/upload_images/703764-4b3ff894932ec1e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>基于这样一种动态特性，我们可以用它做很多事情，例如：</p>
<ul>
<li>事务提交或回退（Web开发中很常见）</li>
<li>权限管理</li>
<li>自定义缓存逻辑处理</li>
<li>SDK Bug修复<br>…</li>
</ul>
<p>如果你阅读过 <a href="https://github.com/yuanhoujun/Android_Slide_To_Close" target="_blank" rel="noopener">Android_Slide_To_Close</a> 的源码会发现，它也在某个地方使用了动态代理设计模式。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>到此为止，关于动态代理的所有讲解已经结束了，原谅我使用了一个诱导性的标题“骗”你进来阅读这篇文章。如果你不是一个久经沙场的“老司机”，10分钟完全看懂动态代理设计模式还是有一定难度的。但即使没有看懂也没关系，如果你在第一次阅读完这篇文章后依然一头雾水，就不妨再仔细阅读一次。在阅读的过程中，一定要跟着文章思路去敲代码。反反复复，一定会看懂的。我在刚刚学习动态代理设计模式的时候就反复看了不下5遍，并且亲自敲代码实践了多次。</p>
<p>为了让你少走弯路，我认为看懂这篇文章，你至少需要学习以下知识点：</p>
<ul>
<li>至少已经理解了面向对象语言的多态特性</li>
<li>了解简单的反射用法</li>
<li>会简单使用 <a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 生成Java源码</li>
</ul>
<p>如果你在阅读文章的过程中，有任何不理解的问题或者建议，欢迎在文章下方留言告诉我！</p>
<p>本篇文章例子代码：<a href="https://github.com/yuanhoujun/java-dynamic-proxy" target="_blank" rel="noopener">https://github.com/yuanhoujun/java-dynamic-proxy</a></p>
<hr>
<p>我是欧阳锋，设计模式是一种非常好的编程指导模型，它在所有编程语言中是通用的，并且是亘古不变的。我建议你在这个方面多下苦功，不要纠结在一些重复的劳动中，活用设计模式会让你的代码更显灵动。想要了解我吗？看这里：<a href="http://www.youngfeng.com/2018/02/28/about%20ouyangfeng/%E6%AC%A7%E9%98%B3%E9%94%8B%E6%A1%A3%E6%A1%88%E9%A6%86/" target="_blank" rel="noopener">欧阳锋档案馆</a>。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>动态代理</tag>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
