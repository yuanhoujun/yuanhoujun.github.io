
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>正确使用Kotlin注解，兼容Java代码 - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"欧阳锋工作室","sameAs":["https://github.com/yuanhoujun","assets/images/mpwexin.jpg","https://weibo.com/u/6140262139?is_all=1","mailto:ouyangfeng2016@gmail.com"],"image":"avatar.jpeg"},"articleBody":"\n大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。\n\n\n产生这个问题的根本原因在于：Kotlin语言与Java语言的设计思路不同，部分特性属于Java语言独有，例如静态变量。部分特性属于Kotlin语言独有，例如逆变和协变。\n\n为了抹平这些差异，Kotlin语言提供了一个绝佳的思路，通过添加注解可以改变Kotlin编译器生成的Java字节码，使之按照Java语言可以理解的方向进行，从而实现兼容。\n\n问题答疑：Kotlin语言与Java字节码有什么关系？为什么Kotlin编译器会生成Java字节码？\n不管是Kotlin语言还是Java语言都是建立在JVM平台上面的编程语言，其最终都需要编译成JVM可以识别的Java字节码才能被正确执行。这也是为什么Kotlin语言与Java可以完全互通的原因之一，不要将Java与Java平台混为一谈。\n接下来我们看第一个注解，也是最常见的注解\n@JvmFieldKotlin编译器默认会将类中声明的成员变量编译成私有变量，Java语言要访问该变量必须通过其生成的getter方法。而使用上面的注解可以向Java暴露该变量，即使其访问变为公开（修饰符变为public)。\n我们来做一个实验：\n@JvmFieldKotlinJava1234class Person {    @JvmField    var name: String? = null}123456789public class Client {    public static void main(String[] args) {        Person p = new Person();        // 在添加@JvmField注解之前，这样访问会报错        // 只能通过p.getName()的方式进行访问        String name = p.name;    }}\n在Person类中我们定义了一个成员变量name，在添加@JvmField属性前我们试图通过p.name的方式进行访问，编译器会报错。因为，默认生成的成员变量name是私有的。而添加该注解之后我们却可以正常访问了。\n由此可见，@JvmField注解的确使生成的字节码发生了变化，我们将字节码用Java语言的形式表示，具体发生的变化类似下面的代码展示：\n添加@JvmField注解的变化beforeafter1234567891011public final class Person {   private String name;   public final String getName() {      return this.name;   }   public final void setName(@Nullable String var1) {      this.name = var1;   }}123public final class Person {   public String name;}\n注：before与after分别为添加注解前与添加之后\n以上场景是将@JvmField注解添加到普通变量上方，如果添加到伴随对象的成员变量上方，会发生什么呢？我们来试试看：\n添加到伴随对象KotlinJava12345678class Person {    var name: String? = null    companion object {        @JvmField        val GENDER_MALE = 1    }}1234567public static void main(String[] args) {  // 未添加之前  // int gender = Person.Companion.getGENDER_MALE();  // 添加之后，可直接访问   int gender = Person.GENDER_MALE;   System.out.println(gender);}\n同样地，添加注解之后我们可以通过点语法直接对其进行访问。\n由此可见，@JvmField注解会使伴随对象在伴生类中生成静态成员变量，通过伴生类类名可直接对其进行访问。\n结论@JvmField注解可改变字节码的生成，其作用的目标是类成员变量或伴随对象成员变量。作用在类成员中可使该变量对外暴露，通过点语法直接访问。即将私有成员变量公有化（public），并去掉setter/getter方法。作用在伴随对象成员变量中，可以使该伴随对象中的变量生成在伴生对象中，成为伴生对象的公有静态成员变量，通过伴生类可直接访问。\n那么问题来了，如果该注解作用在私有成员变量上方会发生什么呢？请大家自行做实验验证。\n@JvmStatic这个注解与@JvmField非常容易出现混淆，两者都可以作用在伴随对象成员变量上方，我们来试试看，如果同样作用在伴随对象成员变量中，会出现什么情况。\n添加@JvmField注解的效果，上面我们已经看到了，我们直接将注解修改为@JvmStatic试试看：\n添加到伴随对象KotlinJava12345678class Person {    var name: String? = null    companion object {        @JvmStatic        val GENDER_MALE = 1    }}12345678910public static void main(String[] args) {       // 1) 这样访问报错    int gender = Person.GENDER_MALE;    // 2) 这样访问正常    int gender = Person.Companion.getGENDER_MALE();    // 3) 这样访问也正常    int gender = Person.getGENDER_MALE();    System.out.println(gender);}\n切换到Java代码，你可以看到，我一共提供了三种访问方式。第一种访问方式是通过点语法直接访问，编译器报错，由此可见，@JvmStatic注解并没有在伴生类中生成静态的公有成员变量。第三种方式可以正常访问，证明该注解在伴生类中生成了静态的公有getter方法。第二种方式可以正常访问，证明该注解不会破坏伴随对象中原有成员的访问方式。\n由此，我们可以大胆猜测，@JvmStatic注解的作用应该是生成静态的setter/getter方法，而不会改变属性（成员变量）的访问权限。\n为了进一步验证我们的猜想，我们将val修改为var试试看。\n12345678910111213public static void main(String[] args) &#123;    // 1) 这样访问报错    int gender = Person.GENDER_MALE;    // 2) 这样访问正常    int gender = Person.Companion.getGENDER_MALE();    // 3) 这样访问也正常    int gender = Person.getGENDER_MALE();    // 4) 以下访问正常    Person.setGENDER_MALE(1);    System.out.println(gender);&#125;\n第四种方式调用正常，证明我们的猜测没有错，@JvmStatic仅会改变伴随对象或对象（object）中setter/getter方法的生成方式，而不会改变属性访问权限，这是与注解@JvmField的本质区别。\n注意：由于@JvmField不仅会改变属性的访问权限，同时也会改变setter/getter方法的生成，细心的同学应该已经注意到了。一旦添加了@JvmField注解，setter/getter方法也消失了（变量可以通过点语法直接访问，setter/getter方法也就没必要存在了）。而@JvmStatic仅仅是使setter/getter方法变为静态方法，同时生成位置放置到伴生类中。这与@JvmField的处理方式有些冲突（@JvmField会直接删除掉setter/getter方法）。为了避免冲突，Kotlin语言禁止将这两个注解混淆使用。\n以上是将@JvmStatic与@JvmField作用在伴随对象成员变量上的区别。实际上，@JvmStatic不仅可以修饰属性（成员变量），还可以修饰方法，修饰方法的作用与修饰属性的作用一致，都是将方法变成静态类型。\n为了更直观地表示两种的区别，我们用一个表格完整展示两个注解的区别：\n\n\n\n注解\n作用位置\n作用\n\n\n\n\n@JvmField\n类属性或对象属性\n使属性修饰符成为public\n\n\n@JvmStatic\n对象方法（包括伴生对象）\n使用方法成为静态类型，如果作用在伴生对象方法中，其方法会成为伴生类的静态方法\n\n\n\n@JvmName这个注解可以改变字节码中生成的类名或方法名称，如果作用在顶级作用域（文件中），则会改变生成对应Java类的名称。如果作用在方法上，则会改变生成对应Java方法的名称。\n@JvmNameKotlinJava123456@file:JvmName(\"FooKt\")@JvmName(\"foo1\")fun foo() {    println(\"Hello, Jvm...\")}1234567// 相当于下面的Java代码public final class FooKt {   public static final void foo1() {      String var0 = \"Hello, Jvm...\";      System.out.println(var0);   }}\n可以看到第一个注解@file:JvmName(&quot;FooKt&quot;)的作用是使生成的类名变为FooKt，第二个注解的作用是使生成的方法名称变为foo1。\n注意：该注解不能改变类中生成的属性（成员变量）的名称。\n这里的注解中，我们看到了一个特殊的前缀@file:，这个注解前缀是Kotlin语言特有的一种标识，其作用是标记该注解最终会作用在生成的字节码的具体位置（属性、setter、getter等），关于这个部分，大家可以先跳过，下一篇文章将给大家详细讲解。\n@JvmMultifileClass说完了上面这个注解，就不得不提到@JvmMultifileClass这个注解，这个注解通常是与@JvmName结合使用的。其使用场景比较单一，看下面的例子：\n@JvmMultifileClassUtil1Util212345@file:JvmName(\"Utils\")fun isEmpty(str: String?): Boolean {    return null == str || str.length &lt;= 0}12345@file:JvmName(\"Utils\")fun isPhoneNumber(str: String): Boolean {    return str.startsWith(\"1\") &amp;&amp; str.length == 11}\n编译以上代码，Kotlin编译器会提示错误Error:(1, 1) Kotlin: Duplicate JVM class name &#39;Utils&#39; generated from: package-fragment, package-fragment，即生成的类名出现了重复。可是，如果我们就是希望声明使用多个文件，但方法生成到同一个类中呢？@JvmMultifileClass就是为解决这个问题而生的。\n我们在上面代码的基础上分别添加注解@JvmMultifileClass试试看:\n@JvmMultifileClassUtil1Util2Java123456@file:JvmName(\"Utils\")@file:JvmMultifileClasfun isEmpty(str: String?): Boolean {    return null == str || str.length &lt;= 0}123456@file:JvmName(\"Utils\")@file:JvmMultifileClassfun isPhoneNumber(str: String): Boolean {    return str.startsWith(\"1\") &amp;&amp; str.length == 11}12345678910// 生成的代码相当于下面这段Java代码public final class Utils {   public static final boolean isEmpty(@Nullable String str) {      return Utils__A1Kt.isEmpty(str);   }   public static final boolean isPhoneNumber(@NotNull String str) {      return Utils__A2Kt.isPhoneNumber(str);   }}\n这个注解在处理多个文件声明，合并到一个类的场景中发挥着举足轻重的作用。如果你有这样的需求，一定要谨记这个注解。\n@JvmOverloads由于Kotlin语言支持方法参数默认值，而实现类似功能Java需要使用方法重载来实现，这个注解就是为解决这个问题而生的，添加这个注解会自动生成重载方法。我们来试一下：\n@JvmOverloadsKotlinJava1234@JvmOverloadsfun foo(x: Int, y: Int = 0, z: Int = 0): Int {    return x + y + z}123456789101112// 生成的代码相当于下面这段Java代码public static final int foo(int x, int y, int z) {  return x + y + z;}   public static final int foo(int x, int y) {  return foo(x, y, 0);}public static final int foo(int x) {  return foo(x, 0, 0);}\n由此可见，通过这个注解可以影响带有参数默认值方法的生成，添加该注解将自动生成带有默认值参数数量的重载方法。这是一个非常有用的特性，方便Java端可以更高效地调用Kotlin端代码。\n@Throws由于Kotlin语言不支持CE（Checked Exception），所谓CE，即方法可能抛出的异常是已知的。Java语言通过throws关键字在方法上声明CE。为了兼容这种写法，Kotlin语言新增了@Throws注解，该注解的接收一个可变参数，参数类型是多个异常的KClass实例。Kotlin编译器通过读取注解参数，在生成的字节码中自动添加CE声明。\n为了便于理解，看一个简单的例子：\n@JvmOverloadsKotlinJava1234@Throws(IllegalArgumentException::class)fun div(x: Int, y: Int): Float {    return x.toFloat() / y}1234// 生成的代码相当于下面这段Java代码public static final float div(int x, int y) throws IllegalArgumentException {      return (float)x / (float)y;}\n可以看到，添加了@Throws(IllegalArgumentException::class)注解后，在生成的方法签名上自动添加了可能抛出的异常声明（throws IllegalArgumentException），即CE。\n这个注解在保证逻辑的严谨性方面非常有用，但如果你的工程中仅使用Kotlin代码，可以不用理会该注解。在Kotlin语言的设计哲学里面，CE被认为是一个错误的设计。\n@Synchronized这个注解很容易理解，顾名思义，主要用于产生同步方法。Kotlin语言不支持synchronized关键字，处理类似Java语言的并发问题，Kotlin语言建议使用同步方法进行处理。\nKotlin团队认为同步的逻辑应该交给代码处理，而不应该在语言层面处理：\n\n但为了兼容Java，Kotlin语言支持使用该注解让编译器自动生成同步方法：\n@SynchronizedKotlinJava1234@Synchronizedfun start() {    println(\"Start do something...\")}12345// 生成的代码相当于下面这段Java代码public static final synchronized void start() {  String var0 = \"Start do something...\";  System.out.println(var0);}\n@JvmWildcard这个注解主要用于处理泛型参数，这涉及到两个新的知识点：逆变与协变。由于Java语言不支持协变，为了保证安全地相互调用，可以通过在泛型参数声明的位置添加该注解使用Kotlin编译器生成通配符形式的泛型参数（？extends ...)。\n看下面这段代码：\n1234567class Box&lt;out T&gt;(val value: T)interface Baseclass Derived : Basefun boxDerived(value: Derived): Box&lt;Derived&gt; = Box(value)fun unboxBase(box: Box&lt;Base&gt;): Base = box.value\n按照正常思维，下面的两个方法转换到Java代码应该是这样：\n12Box&lt;Derived&gt; boxDerived(Derived value) &#123; …… &#125;Base unboxBase(Box&lt;Base&gt; box) &#123; …… &#125;\n但问题是，Kotlin泛型支持型变，在Kotlin中，我们可以这样写unboxBase(Box(Derived()))，而在Java语言中，泛型参数类型是不可变的，按照上面的写法显然已经做不到了。\n正确转换到Java代码应该是这样：\n1Base unboxBase(Box&lt;? extends Base&gt; box) &#123; …… &#125;\n为了使这样的转换正确生成，我们需要在泛型参数的位置添加上面的注解:\n1fun unboxBase(box: Box&lt;@JvmWildcard Base&gt;): Base = box.value\n@JvmSuppressWildcards这个注解的作用与@JvmWildcard恰恰相反，它是用来抑制通配符泛型参数的生成，即在不需要型变泛型参数的情况下，我们可以通过添加这个注解来避免生成型变泛型参数。\n@JvmSuppressWildcardsKotlinJava1fun unboxBase(box: Box&lt;@JvmSuppressWildcards Base&gt;): Base = box.value12// 生成的代码相当于下面这段Java代码Base unboxBase(Box&lt;Base&gt; box) { …… }\n正确使用上述注解，可以抹平Kotlin与Java泛型处理的差异，避免出现安全转换问题。\n@Volatile @Transient这两个注解恰好对应Java端的两个关键字volatile与transient，前者主要用于解决多线程脏数据问题，后者用于标记序列化对象中不参与序列化的属性。\n这两个注解比较简单，就不举例说明了。在遇到类似需要与Java互通的场景时，只需要将其关键字替换为该注解即可。\n以上就是我们日常开发过程中能够遇到的所有注解了，在Kotlin 1.3版本中，还增加了一个新的注解@JvmDefault用于在接口中处理默认实现的方法。接口中允许有默认实现是从JDK 1.8版本开始的，为了兼容低版本JDK，Kotlin语言新增了该注解用于生成兼容性字节码，但该注解目前仍处于实验阶段，名称或行为均可能发生改变，建议大家先不要使用，推荐大家始终使用JDK 1.8及其以上版本。\n最佳实践如果在工程中必须存在部分Java代码，为了实现完美调用，一定要谨慎并正确地使用上述注解。要充分理解Kotlin编译器与Java编译器生成的字节码差异。\n如果是由于现存Java库仅兼容Java字节码，导致部分框架在遇到Kotlin语言生成的字节码时会出现解析错误，不能正常使用。这个时候要尝试检查是否需要通过上述注解矫正字节码的生成，使Java库能够正常使用。\n如果是新工程，建议大家全部使用Kotlin代码，避免出现上述注解，减少阅读上的困难。目前，Kotlin版本已经非常稳定了，请大家放心使用。\n阅读更多技术文章，请关注微信公众号”欧阳锋工作室“\n参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958\n","dateCreated":"2019-11-12T12:40:50+08:00","dateModified":"2022-09-08T16:13:27+08:00","datePublished":"2019-11-12T12:40:50+08:00","description":"\n大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。\n","headline":"正确使用Kotlin注解，兼容Java代码","image":["http://youngfeng.com/assets/images/kotlin/jvmanno/thumb.jpg"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"},"publisher":{"@type":"Organization","name":"欧阳锋工作室","sameAs":["https://github.com/yuanhoujun","assets/images/mpwexin.jpg","https://weibo.com/u/6140262139?is_all=1","mailto:ouyangfeng2016@gmail.com"],"image":"avatar.jpeg","logo":{"@type":"ImageObject","url":"avatar.jpeg"}},"url":"http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/","keywords":"Kotlin, Jvm, 注解","thumbnailUrl":"http://youngfeng.com/assets/images/kotlin/jvmanno/thumb.jpg"}</script>
    <meta name="description" content="大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。">
<meta name="keywords" content="Kotlin,Jvm,注解">
<meta property="og:type" content="blog">
<meta property="og:title" content="正确使用Kotlin注解，兼容Java代码">
<meta property="og:url" content="http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://youngfeng.com/assets/images/kotlin/jvmanno/syn.png">
<meta property="og:image" content="http://youngfeng.com/assets/images/mpwexin.jpg">
<meta property="og:updated_time" content="2022-09-08T08:13:27.736Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正确使用Kotlin注解，兼容Java代码">
<meta name="twitter:description" content="大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。">
<meta name="twitter:image" content="http://youngfeng.com/assets/images/kotlin/jvmanno/syn.png">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/kotlin/jvmanno/thumb.jpg"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://youngfeng.com/assets/images/kotlin/jvmanno/thumb.jpg"/>
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/yuanhoujun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/assets/images/mpwexin.jpg"
                            
                            rel="noopener"
                            title="微信公众号"
                        >
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://weibo.com/u/6140262139?is_all=1"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="微博"
                        >
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:ouyangfeng2016@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            正确使用Kotlin注解，兼容Java代码
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-11-12T12:40:50+08:00">
	
		    11月 12, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/Kotlin/">Kotlin</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>大多数情况下，你不需要关注这个问题。但是，如果你的代码中包含了部分Java代码，理解这些注解将帮助你解决很多棘手问题。</p>
</blockquote>
<a id="more"></a>
<p>产生这个问题的根本原因在于：Kotlin语言与Java语言的设计思路不同，部分特性属于Java语言独有，例如静态变量。部分特性属于Kotlin语言独有，例如逆变和协变。</p>
<blockquote>
<p>为了抹平这些差异，Kotlin语言提供了一个绝佳的思路，通过添加注解可以改变Kotlin编译器生成的Java字节码，使之按照Java语言可以理解的方向进行，从而实现兼容。</p>
</blockquote>
<p><strong>问题答疑：Kotlin语言与Java字节码有什么关系？为什么Kotlin编译器会生成Java字节码？</strong></p>
<p>不管是Kotlin语言还是Java语言都是建立在JVM平台上面的编程语言，其最终都需要编译成JVM可以识别的Java字节码才能被正确执行。这也是为什么Kotlin语言与Java可以完全互通的原因之一，不要将Java与Java平台混为一谈。</p>
<p>接下来我们看第一个注解，也是最常见的注解</p>
<h3 id="JvmField"><a href="#JvmField" class="headerlink" title="@JvmField"></a>@JvmField</h3><p>Kotlin编译器默认会将类中声明的成员变量编译成私有变量，Java语言要访问该变量必须通过其生成的getter方法。而使用上面的注解可以向Java暴露该变量，即使其访问变为公开（修饰符变为public)。</p>
<p>我们来做一个实验：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmField</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="meta">@JvmField</span></span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 在添加@JvmField注解之前，这样访问会报错</span></span><br><span class="line">        <span class="comment">// 只能通过p.getName()的方式进行访问</span></span><br><span class="line">        String name = p.name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>在Person类中我们定义了一个成员变量<code>name</code>，在添加<code>@JvmField</code>属性前我们试图通过<code>p.name</code>的方式进行访问，编译器会报错。因为，默认生成的成员变量<code>name</code>是私有的。而添加该注解之后我们却可以正常访问了。</p>
<p>由此可见，<code>@JvmField</code>注解的确使生成的字节码发生了变化，我们将字节码用Java语言的形式表示，具体发生的变化类似下面的代码展示：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">添加@JvmField注解的变化</a><ul class="tabs"><li class="tab active">before</li><li class="tab">after</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public final class Person {</span><br><span class="line">   private String name;</span><br><span class="line"></span><br><span class="line">   public final String getName() {</span><br><span class="line">      return this.name;</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   public final void setName(@Nullable String var1) {</span><br><span class="line">      this.name = var1;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final class Person {</span><br><span class="line">   public String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p><strong>注：before与after分别为添加注解前与添加之后</strong></p>
<p>以上场景是将<code>@JvmField</code>注解添加到普通变量上方，如果添加到伴随对象的成员变量上方，会发生什么呢？我们来试试看：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">添加到伴随对象</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">        <span class="meta">@JvmField</span></span><br><span class="line">        <span class="keyword">val</span> GENDER_MALE = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">  <span class="comment">// 未添加之前</span></span><br><span class="line">  <span class="comment">// int gender = Person.Companion.getGENDER_MALE();</span></span><br><span class="line">  <span class="comment">// 添加之后，可直接访问</span></span><br><span class="line">   <span class="keyword">int</span> gender = Person.GENDER_MALE;</span><br><span class="line">   System.out.println(gender);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>同样地，添加注解之后我们可以通过点语法直接对其进行访问。</p>
<p>由此可见，<code>@JvmField</code>注解会使伴随对象在伴生类中生成静态成员变量，通过伴生类类名可直接对其进行访问。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><code>@JvmField</code>注解可改变字节码的生成，其作用的目标是类成员变量或伴随对象成员变量。作用在类成员中可使该变量对外暴露，通过点语法直接访问。即将私有成员变量公有化（public），并去掉setter/getter方法。作用在伴随对象成员变量中，可以使该伴随对象中的变量生成在伴生对象中，成为伴生对象的公有静态成员变量，通过伴生类可直接访问。</p>
<p>那么问题来了，如果该注解作用在私有成员变量上方会发生什么呢？请大家自行做实验验证。</p>
<h3 id="JvmStatic"><a href="#JvmStatic" class="headerlink" title="@JvmStatic"></a>@JvmStatic</h3><p>这个注解与<code>@JvmField</code>非常容易出现混淆，两者都可以作用在伴随对象成员变量上方，我们来试试看，如果同样作用在伴随对象成员变量中，会出现什么情况。</p>
<p>添加<code>@JvmField</code>注解的效果，上面我们已经看到了，我们直接将注解修改为<code>@JvmStatic</code>试试看：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">添加到伴随对象</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> name: String? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> {</span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">val</span> GENDER_MALE = <span class="number">1</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{   </span><br><span class="line">    <span class="comment">// 1) 这样访问报错</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.GENDER_MALE;</span><br><span class="line">    <span class="comment">// 2) 这样访问正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.Companion.getGENDER_MALE();</span><br><span class="line">    <span class="comment">// 3) 这样访问也正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.getGENDER_MALE();</span><br><span class="line"></span><br><span class="line">    System.out.println(gender);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>切换到Java代码，你可以看到，我一共提供了三种访问方式。第一种访问方式是通过点语法直接访问，编译器报错，由此可见，<code>@JvmStatic</code>注解并没有在伴生类中生成静态的公有成员变量。第三种方式可以正常访问，证明该注解在伴生类中生成了静态的公有getter方法。第二种方式可以正常访问，证明该注解不会破坏伴随对象中原有成员的访问方式。</p>
<p>由此，我们可以大胆猜测，<code>@JvmStatic</code>注解的作用应该是生成静态的setter/getter方法，而不会改变属性（成员变量）的访问权限。</p>
<p>为了进一步验证我们的猜想，我们将<code>val</code>修改为<code>var</code>试试看。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">    <span class="comment">// 1) 这样访问报错</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.GENDER_MALE;</span><br><span class="line">    <span class="comment">// 2) 这样访问正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.Companion.getGENDER_MALE();</span><br><span class="line">    <span class="comment">// 3) 这样访问也正常</span></span><br><span class="line">    <span class="keyword">int</span> gender = Person.getGENDER_MALE();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4) 以下访问正常</span></span><br><span class="line">    Person.setGENDER_MALE(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(gender);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种方式调用正常，证明我们的猜测没有错，<code>@JvmStatic</code>仅会改变伴随对象或对象（object）中setter/getter方法的生成方式，而不会改变属性访问权限，这是与注解<code>@JvmField</code>的本质区别。</p>
<p><strong>注意：由于<code>@JvmField</code>不仅会改变属性的访问权限，同时也会改变setter/getter方法的生成，细心的同学应该已经注意到了。一旦添加了<code>@JvmField</code>注解，setter/getter方法也消失了（变量可以通过点语法直接访问，setter/getter方法也就没必要存在了）。而<code>@JvmStatic</code>仅仅是使setter/getter方法变为静态方法，同时生成位置放置到伴生类中。这与<code>@JvmField</code>的处理方式有些冲突（<code>@JvmField</code>会直接删除掉setter/getter方法）。为了避免冲突，Kotlin语言禁止将这两个注解混淆使用。</strong></p>
<p>以上是将<code>@JvmStatic</code>与<code>@JvmField</code>作用在伴随对象成员变量上的区别。实际上，<code>@JvmStatic</code>不仅可以修饰属性（成员变量），还可以修饰方法，修饰方法的作用与修饰属性的作用一致，都是将方法变成静态类型。</p>
<p>为了更直观地表示两种的区别，我们用一个表格完整展示两个注解的区别：</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">作用位置</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@JvmField</code></td>
<td style="text-align:center">类属性或对象属性</td>
<td style="text-align:center">使属性修饰符成为public</td>
</tr>
<tr>
<td style="text-align:center"><code>@JvmStatic</code></td>
<td style="text-align:center">对象方法（包括伴生对象）</td>
<td style="text-align:center">使用方法成为静态类型，如果作用在伴生对象方法中，其方法会成为伴生类的静态方法</td>
</tr>
</tbody>
</table>
<h3 id="JvmName"><a href="#JvmName" class="headerlink" title="@JvmName"></a>@JvmName</h3><p>这个注解可以改变字节码中生成的类名或方法名称，如果作用在顶级作用域（文件中），则会改变生成对应Java类的名称。如果作用在方法上，则会改变生成对应Java方法的名称。</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmName</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@file:JvmName</span>(<span class="string">"FooKt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@JvmName(<span class="meta-string">"foo1"</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"Hello, Jvm..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于下面的Java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FooKt</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span> </span>{</span><br><span class="line">      String var0 = <span class="string">"Hello, Jvm..."</span>;</span><br><span class="line">      System.out.println(var0);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>可以看到第一个注解<code>@file:JvmName(&quot;FooKt&quot;)</code>的作用是使生成的类名变为<code>FooKt</code>，第二个注解的作用是使生成的方法名称变为<code>foo1</code>。</p>
<p><strong>注意：该注解不能改变类中生成的属性（成员变量）的名称。</strong></p>
<p>这里的注解中，我们看到了一个特殊的前缀<code>@file:</code>，这个注解前缀是Kotlin语言特有的一种标识，其作用是标记该注解最终会作用在生成的字节码的具体位置（属性、setter、getter等），关于这个部分，大家可以先跳过，下一篇文章将给大家详细讲解。</p>
<h3 id="JvmMultifileClass"><a href="#JvmMultifileClass" class="headerlink" title="@JvmMultifileClass"></a>@JvmMultifileClass</h3><p>说完了上面这个注解，就不得不提到<code>@JvmMultifileClass</code>这个注解，这个注解通常是与<code>@JvmName</code>结合使用的。其使用场景比较单一，看下面的例子：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmMultifileClass</a><ul class="tabs"><li class="tab active">Util1</li><li class="tab">Util2</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line"></span><br><span class="line">fun isEmpty(str: String?): Boolean {</span><br><span class="line">    return null == str || str.length &lt;= 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line"></span><br><span class="line">fun isPhoneNumber(str: String): Boolean {</span><br><span class="line">    return str.startsWith("1") &amp;&amp; str.length == 11</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>编译以上代码，Kotlin编译器会提示错误<code>Error:(1, 1) Kotlin: Duplicate JVM class name &#39;Utils&#39; generated from: package-fragment, package-fragment</code>，即生成的类名出现了重复。可是，如果我们就是希望声明使用多个文件，但方法生成到同一个类中呢？<code>@JvmMultifileClass</code>就是为解决这个问题而生的。</p>
<p>我们在上面代码的基础上分别添加注解<code>@JvmMultifileClass</code>试试看:</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmMultifileClass</a><ul class="tabs"><li class="tab active">Util1</li><li class="tab">Util2</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight plaintext" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line">@file:JvmMultifileClas</span><br><span class="line"></span><br><span class="line">fun isEmpty(str: String?): Boolean {</span><br><span class="line">    return null == str || str.length &lt;= 0</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@file:JvmName("Utils")</span><br><span class="line">@file:JvmMultifileClass</span><br><span class="line"></span><br><span class="line">fun isPhoneNumber(str: String): Boolean {</span><br><span class="line">    return str.startsWith("1") &amp;&amp; str.length == 11</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="meta">@Nullable</span> String str)</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> Utils__A1Kt.isEmpty(str);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isPhoneNumber</span><span class="params">(<span class="meta">@NotNull</span> String str)</span> </span>{</span><br><span class="line">      <span class="keyword">return</span> Utils__A2Kt.isPhoneNumber(str);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>这个注解在处理多个文件声明，合并到一个类的场景中发挥着举足轻重的作用。如果你有这样的需求，一定要谨记这个注解。</p>
<h3 id="JvmOverloads"><a href="#JvmOverloads" class="headerlink" title="@JvmOverloads"></a>@JvmOverloads</h3><p>由于Kotlin语言支持方法参数默认值，而实现类似功能Java需要使用方法重载来实现，这个注解就是为解决这个问题而生的，添加这个注解会自动生成重载方法。我们来试一下：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmOverloads</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JvmOverloads</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">foo</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span> = <span class="number">0</span>, z: <span class="type">Int</span> = <span class="number">0</span>)</span></span>: <span class="built_in">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">}</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> foo(x, y, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> x)</span> </span>{</span><br><span class="line">  <span class="keyword">return</span> foo(x, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>由此可见，通过这个注解可以影响带有参数默认值方法的生成，添加该注解将自动生成带有默认值参数数量的重载方法。这是一个非常有用的特性，方便Java端可以更高效地调用Kotlin端代码。</p>
<h3 id="Throws"><a href="#Throws" class="headerlink" title="@Throws"></a>@Throws</h3><p>由于Kotlin语言不支持CE（Checked Exception），所谓CE，即方法可能抛出的异常是已知的。Java语言通过<code>throws</code>关键字在方法上声明CE。为了兼容这种写法，Kotlin语言新增了<code>@Throws</code>注解，该注解的接收一个可变参数，参数类型是多个异常的KClass实例。Kotlin编译器通过读取注解参数，在生成的字节码中自动添加CE声明。</p>
<p>为了便于理解，看一个简单的例子：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmOverloads</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Throws(IllegalArgumentException::class)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">div</span><span class="params">(x: <span class="type">Int</span>, y: <span class="type">Int</span>)</span></span>: <span class="built_in">Float</span> {</span><br><span class="line">    <span class="keyword">return</span> x.toFloat() / y</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> <span class="keyword">throws</span> IllegalArgumentException </span>{</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">float</span>)x / (<span class="keyword">float</span>)y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>可以看到，添加了<code>@Throws(IllegalArgumentException::class)</code>注解后，在生成的方法签名上自动添加了可能抛出的异常声明（throws IllegalArgumentException），即CE。</p>
<p>这个注解在保证逻辑的严谨性方面非常有用，但如果你的工程中仅使用Kotlin代码，可以不用理会该注解。在Kotlin语言的设计哲学里面，CE被认为是一个错误的设计。</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h3><p>这个注解很容易理解，顾名思义，主要用于产生同步方法。Kotlin语言不支持<code>synchronized</code>关键字，处理类似Java语言的并发问题，Kotlin语言建议使用同步方法进行处理。</p>
<p>Kotlin团队认为同步的逻辑应该交给代码处理，而不应该在语言层面处理：</p>
<p><img src="http://youngfeng.com/assets/images/kotlin/jvmanno/syn.png" alt=""></p>
<p>但为了兼容Java，Kotlin语言支持使用该注解让编译器自动生成同步方法：</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@Synchronized</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span><span class="params">()</span></span> {</span><br><span class="line">    println(<span class="string">"Start do something..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">  String var0 = <span class="string">"Start do something..."</span>;</span><br><span class="line">  System.out.println(var0);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></figure>
<h3 id="JvmWildcard"><a href="#JvmWildcard" class="headerlink" title="@JvmWildcard"></a>@JvmWildcard</h3><p>这个注解主要用于处理泛型参数，这涉及到两个新的知识点：<strong>逆变</strong>与<strong>协变</strong>。由于Java语言不支持协变，为了保证安全地相互调用，可以通过在泛型参数声明的位置添加该注解使用Kotlin编译器生成通配符形式的泛型参数（<code>？extends ...</code>)。</p>
<p>看下面这段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">out T</span>&gt;</span>(<span class="keyword">val</span> value: T)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> : <span class="type">Base</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">boxDerived</span><span class="params">(value: <span class="type">Derived</span>)</span></span>: Box&lt;Derived&gt; = Box(value)</span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;<span class="type">Base</span>&gt;)</span></span>: Base = box.value</span><br></pre></td></tr></table></figure>
<p>按照正常思维，下面的两个方法转换到Java代码应该是这样：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Box&lt;Derived&gt; </span><span class="keyword">boxDerived(Derived </span>value) &#123; …… &#125;</span><br><span class="line"><span class="keyword">Base </span>unboxBase(<span class="keyword">Box&lt;Base&gt; </span><span class="keyword">box) </span>&#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>但问题是，Kotlin泛型支持型变，在Kotlin中，我们可以这样写<code>unboxBase(Box(Derived()))</code>，而在Java语言中，泛型参数类型是不可变的，按照上面的写法显然已经做不到了。</p>
<p>正确转换到Java代码应该是这样：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Base </span>unboxBase(<span class="keyword">Box&lt;? </span><span class="keyword">extends </span><span class="keyword">Base&gt; </span><span class="keyword">box) </span>&#123; …… &#125;</span><br></pre></td></tr></table></figure>
<p>为了使这样的转换正确生成，我们需要在泛型参数的位置添加上面的注解:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;@<span class="type">JvmWildcard</span> <span class="type">Base</span>&gt;)</span></span>: Base = box.value</span><br></pre></td></tr></table></figure>
<h3 id="JvmSuppressWildcards"><a href="#JvmSuppressWildcards" class="headerlink" title="@JvmSuppressWildcards"></a>@JvmSuppressWildcards</h3><p>这个注解的作用与<code>@JvmWildcard</code>恰恰相反，它是用来抑制通配符泛型参数的生成，即在不需要型变泛型参数的情况下，我们可以通过添加这个注解来避免生成型变泛型参数。</p>
<figure class="codeblock codeblock--tabbed"><figcaption><a href="http://youngfeng.com">@JvmSuppressWildcards</a><ul class="tabs"><li class="tab active">Kotlin</li><li class="tab">Java</li></ul></figcaption><div class="tabs-content"><figure class="highlight kotlin" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">unboxBase</span><span class="params">(box: <span class="type">Box</span>&lt;@<span class="type">JvmSuppressWildcards</span> <span class="type">Base</span>&gt;)</span></span>: Base = box.value</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java" style="display: none;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成的代码相当于下面这段Java代码</span></span><br><span class="line"><span class="function">Base <span class="title">unboxBase</span><span class="params">(Box&lt;Base&gt; box)</span> </span>{ …… }</span><br></pre></td></tr></tbody></table></figure></div></figure>
<p>正确使用上述注解，可以抹平Kotlin与Java泛型处理的差异，避免出现安全转换问题。</p>
<h3 id="Volatile-Transient"><a href="#Volatile-Transient" class="headerlink" title="@Volatile @Transient"></a>@Volatile @Transient</h3><p>这两个注解恰好对应Java端的两个关键字<code>volatile</code>与<code>transient</code>，前者主要用于解决多线程脏数据问题，后者用于标记序列化对象中不参与序列化的属性。</p>
<p>这两个注解比较简单，就不举例说明了。在遇到类似需要与Java互通的场景时，只需要将其关键字替换为该注解即可。</p>
<p>以上就是我们日常开发过程中能够遇到的所有注解了，在Kotlin 1.3版本中，还增加了一个新的注解<code>@JvmDefault</code>用于在接口中处理默认实现的方法。接口中允许有默认实现是从JDK 1.8版本开始的，为了兼容低版本JDK，Kotlin语言新增了该注解用于生成兼容性字节码，但该注解目前仍处于实验阶段，名称或行为均可能发生改变，建议大家先不要使用，推荐大家始终使用JDK 1.8及其以上版本。</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>如果在工程中必须存在部分Java代码，为了实现完美调用，一定要谨慎并正确地使用上述注解。要充分理解Kotlin编译器与Java编译器生成的字节码差异。</p>
<p>如果是由于现存Java库仅兼容Java字节码，导致部分框架在遇到Kotlin语言生成的字节码时会出现解析错误，不能正常使用。这个时候要尝试检查是否需要通过上述注解矫正字节码的生成，使Java库能够正常使用。</p>
<p>如果是新工程，建议大家全部使用Kotlin代码，避免出现上述注解，减少阅读上的困难。目前，Kotlin版本已经非常稳定了，请大家放心使用。</p>
<p>阅读更多技术文章，请关注微信公众号”欧阳锋工作室“<br><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>
<p>参与Kotlin技术讨论，请添加唯一官方QQ交流群：329673958</p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/Jvm/">Jvm</a> <a class="tag tag--primary tag--small t-link" href="/tags/Kotlin/">Kotlin</a> <a class="tag tag--primary tag--small t-link" href="/tags/注解/">注解</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/11/15/理解Kotlin语言独有的位置注解，让注解控制更精准/"
                    data-tooltip="理解Kotlin语言独有的位置注解，让注解控制更精准"
                    aria-label="上一篇: 理解Kotlin语言独有的位置注解，让注解控制更精准"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/03/02/design pattern/10分钟看懂动态代理设计模式/"
                    data-tooltip="10分钟看懂动态代理设计模式"
                    aria-label="下一篇: 10分钟看懂动态代理设计模式"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/&amp;title=正确使用Kotlin注解，兼容Java代码"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <div id="SOHUCS" sid="正确使用Kotlin注解，兼容Java代码" ></div>


            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <p>
        <a href="https://beian.miit.gov.cn">粤ICP备2022110674号-1</a>
    </p>
    <p class="copyrights">
        Copyrights &copy; 2023 欧阳锋工作室. All Rights Reserved.
    </p>
</footer>
            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/11/15/理解Kotlin语言独有的位置注解，让注解控制更精准/"
                    data-tooltip="理解Kotlin语言独有的位置注解，让注解控制更精准"
                    aria-label="上一篇: 理解Kotlin语言独有的位置注解，让注解控制更精准"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2018/03/02/design pattern/10分钟看懂动态代理设计模式/"
                    data-tooltip="10分钟看懂动态代理设计模式"
                    aria-label="下一篇: 10分钟看懂动态代理设计模式"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/&amp;title=正确使用Kotlin注解，兼容Java代码"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/&amp;title=正确使用Kotlin注解，兼容Java代码"
                        aria-label="分享到 QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2019/11/12/正确使用Kotlin注解，兼容Java代码/"
                        aria-label="分享到 Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    
       <!--PC和WAP自适应版-->
       <script type="text/javascript">
        (function () {
          var appid = "cyudElu9x";
          var conf = "prod_7c706c18e17b3672472c2f770b724efb";
          
          var width = window.innerWidth || document.documentElement.clientWidth;
          if (width < 1000) {
            var head = document.getElementsByTagName('head')[0] || document.head || document.documentElement;
            var script = document.createElement('script');
            script.type = 'text/javascript';
            script.charset = 'utf-8';
            script.id = 'changyan_mobile_js';
            script.src = 'https://cy-cdn.kuaizhan.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf;
            head.appendChild(script);
          } else { var loadJs = function (d, a) { var c = document.getElementsByTagName("head")[0] || document.head || document.documentElement; var b = document.createElement("script"); b.setAttribute("type", "text/javascript"); b.setAttribute("charset", "UTF-8"); b.setAttribute("src", d); if (typeof a === "function") { if (window.attachEvent) { b.onreadystatechange = function () { var e = b.readyState; if (e === "loaded" || e === "complete") { b.onreadystatechange = null; a() } } } else { b.onload = a } } c.appendChild(b) }; loadJs("https://cy-cdn.kuaizhan.com/upload/changyan.js", function () { window.changyan.api.config({ appid: appid, conf: conf }) }); }
        })(); </script>
    




    </body>
</html>
