
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="欧阳锋工作室">
    <title>10分钟看懂动态代理设计模式（升级篇） - 欧阳锋工作室</title>
    <meta name="author" content="欧阳锋工作室">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"欧阳锋工作室","sameAs":["https://github.com/yuanhoujun","assets/images/mpwexin.jpg","https://weibo.com/u/6140262139?is_all=1","mailto:ouyangfeng2016@gmail.com"],"image":"avatar.jpeg"},"articleBody":"\n关于动态代理，我之前写过一篇文章《10分钟看懂动态代理设计模式》。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？\n\n\n这篇文章的思路还是同之前的文章一样，由浅入深，如果你已经看过上一篇文章，部分章节可以跳过。\n静态代理那么，到底什么是代理呢？\n所谓的代理，其实就是中间人的意思。例如：让朋友代替你去取快递，你的朋友就充当了代理的作用。再比如，让你的朋友帮你去借款，你的朋友实际上也充当了代理的作用，最终这笔钱的受益人还是你自己。\n理解了代理的意思，接下来我们一起来看一下，在面向对象编程语言中，到底应该如何体现代理呢。\n这里我们就以上面提到的代取快递为例，来写一个简单的代理实现。\n我们用Friend类表示你的朋友，用Self表示你自己，上面的例子用代码实现应该是这样：\n1234567891011public class Friend &#123;    private String name;    public Friend(String name) &#123;        this.name = name;    &#125;    public void collectPack() &#123;        System.out.println(this.name + \"去取快递...\");    &#125;&#125;\n1234567891011121314151617181920public class Self &#123;    private Friend friend;    public Self(Friend friend) &#123;        this.friend = friend;    &#125;    // 由于实际动作的执行者是你的朋友    // 因此，这里直接调用Friend的collectPack方法    public void collectPack() &#123;        friend.collectPack();    &#125;    public static void main(String[] args) &#123;        Friend friend = new Friend(\"张三\");        Self self = new Self(friend);        // 这里将打印”张三去取快递...“        self.collectPack();    &#125;&#125;\n在上面这段代码中，我们实现了一个简单的代理。这里的代理类是Friend，被代理类是Self，通过这段代码，我们知道了一个基本事实：代理对象是真正去执行动作的对象，被代理对象是被动执行动作的对象（并不真正执行动作）。\n上面的实现看似没有问题，实际上却不够友好，由于代理对象能够替被代理对象执行动作。所以，他们应该具有同样的一些方法。换句话说，应该实现他们应该实现同样的接口，这个接口中的方法表示双方都可以执行的一些动作，或者说可能要被代理的一些动作。\n因此，上面的代码可以改写成下面这样：\n12345// 这个接口表示代理类与被代理类可以共同执行的动作//  或者说，具体想要被代理的动作方法集合public interface Collectable &#123;    void collectPack();&#125;\n1234567891011public class Friend implements Collectable &#123;    private String name;    public Friend(String name) &#123;        this.name = name;    &#125;    public void collectPack() &#123;        System.out.println(this.name + \"去取快递...\");    &#125;&#125;\n12345678910111213141516171819public class Self implements Collectable &#123;    private Friend friend;    public Self(Friend friend) &#123;        this.friend = friend;    &#125;    // 由于实际动作的执行者是你的朋友    // 因此，这里直接调用Friend的collectPack方法    public void collectPack() &#123;        friend.collectPack();    &#125;    public static void main(String[] args) &#123;        Friend friend = new Friend(\"张三\");        Self self = new Self(friend);        self.collectPack();    &#125;&#125;\n恭喜你！通过上面的改造，我们已经完成了一个标准的静态代理实现。之所以称之为静态代理，是因为这里的逻辑是写死的，并不具备动态特性。与之相对的，就是今天这篇文章的主角：动态代理。\n代理的作用是什么看到这里，应该有人会问了，说了这么多，代理到底有什么用呢。这个问题并不容易回答，为了回答你的这个问题，我们先来看一个场景。\n假设有一个类Driver，类中只有一个方法drive，我们不能改动这个类的源码，如何获取这个方法的执行时间呢？\n12345678public class Driver &#123;        public void drive() throws InterruptedException &#123;        System.out.println(\"I'm driving...\");        Thread.sleep(1000);        System.out.println(\"Drive completed...\");    &#125;&#125;\n有的同学可能会说，这还不简单，在main方法中，方法执行前记录一个时间，方法执行后记录一个时间，两个时间相减就得到了方法最终的执行时间。\n位置p1\n123456789public static void main(String[] args) throws InterruptedException &#123;    Driver driver = new Driver();    long start = System.currentTimeMillis();    driver.drive();    long end = System.currentTimeMillis();    System.out.println(end - start);&#125;\n这个方法到底对不对呢，先说结论：不对！这里的时间会大于方法实际执行的时间，因为这里包含了准备方法的那些时间。\n除了这个方法之外，还有一个比较容易想到的方法就是继承。通过继承Driver类，在drive方法前后打印时间，计算时间差，这种方式似乎可行！\n12345678910public class Driver1 extends Driver &#123;    @Override    public void drive() throws InterruptedException &#123;        long start = System.currentTimeMillis();        super.drive();        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n位置p2\n1234public static void main(String[] args) throws InterruptedException &#123;    Driver1 driver1 = new Driver1();    driver1.drive();&#125;\n这里有一个疑点，有些同学在问，到底方法的准备时间是什么，为什么会有准备方法的这些时间。这两种方式不是都需要准备方法吗？\n上面我们说到，直接打印的方式包含了准备方法的那些时间，准备一个方法通常需要先压栈，调用后自动出栈，这些都需要时间，尤其在一些性能比较低的机器上会体现的特别明显。不信，大家可以执行位置p1处的代码与位置p2处的代码，你会发现，位置p2处的执行时间几乎总是比位置p1处的执行时间少3~5毫秒（在我的Macbook Pro 15.4 2017上执行是这样的结果，其它机型时间可能略有差异）。在继承中不需要这些时间的原因是：我们是方法内部执行的，这个时候方法已经准备好，就不存在这个准备时间了。\nOk，说完了上面这个问题，我们继续回到上面的代码。在上面的代码中，我们通过继承的方式获得了方法的执行时间。接下来，新需求来了，我要你在drive方法前后各打印一条日志。\n你会怎么做呢，当然毫无疑问，我们继续沿用上面的解决方案，继承Driver类创建新类Driver2。然后，在super调用前后各打印一条日志。\n123456789public class Driver2 extends Driver &#123;    @Override    public void drive() throws InterruptedException &#123;        System.out.println(\"Drive start...\");        super.drive();        System.out.println(\"Drive complete...\");    &#125;&#125;\n问题似乎很简单，可是，新的需求又来了。我要你先打印日志再获取方法的执行时间。其实，这也很简单。我们只要继承上面的Driver2类，重写drive方法获取方法执行的时间即可：\n12345678910public class Driver3 extends Driver2 &#123;    @Override    public void drive() throws InterruptedException &#123;        long start = System.currentTimeMillis();        super.drive();        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n接下来，麻烦来了。需求又变了，我要你先获取方法的执行时间再打印日志，怎么办。\n有人说，这也没毛病啊。我们只要继承Driver1创建新类Driver4，然后在drive方法中打印日志即可：\n123456789public class Driver4 extends Driver1 &#123;    @Override    public void drive() throws InterruptedException &#123;        System.out.println(\"Drive start...\");        super.drive();        System.out.println(\"Drive complete...\");    &#125;&#125;\n也许你已经发现了，这个解决方案存在着明显的问题，如果一个类有100个方法，实现上述这些逻辑大概需要创建400个类，这显然不是一个可取的方法。那么，是否有更好的解决方案呢？\n在上面的解决方案中，我们通过继承的方式获取到了父类方法的执行时间。但是，如果Driver类被final修饰呢，大家知道final类是无法被继承的，继承这条路显然走不通了。\n但这似乎恰好为我们打开了一扇窗，我们尝试使用文章开头静态代理的方式传入不同功能的Driver类实例，看看能否发生一些特殊的化学反应。\n同样，我们以获取方法的执行时间为例，如果要通过静态代理的方式获取方法的执行时间，我们应该这样做：\n1234567891011121314public class Driver5 &#123;    private Driver driver;    public Driver5(Driver driver) &#123;        this.driver = driver;    &#125;    public void drive() throws InterruptedException &#123;        long start = System.currentTimeMillis();        driver.drive();        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n前面说到，我们应该将统一的动作抽象化。因此，这里我们新增统一的接口Drivable，我们让所有的Driver类都实现Drivable接口：\n1234567891011121314public class Driver5 implements Drivable &#123;    private Driver driver;    public Driver5(Driver driver) &#123;        this.driver = driver;    &#125;    public void drive() throws InterruptedException &#123;        long start = System.currentTimeMillis();        driver.drive();        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n同样地，为了在方法的执行前后打印日志，我们创建Driver6通过代理的方式实现日志的打印：\n12345678910111213public class Driver6 implements Drivable &#123;    private Driver driver;    public Driver6(Driver driver) &#123;        this.driver = driver;    &#125;    public void drive() throws InterruptedException &#123;        System.out.println(\"Drive start...\");        driver.drive();        System.out.println(\"Drive complete...\");    &#125;&#125;\n为了与前面的方式区分开来，我们将Driver5重命名为DriverTimeProxy，Driver6重命名为DriverLogProxy，接下来我们尝试先打印日志再获取方法的执行时间。\n咋一看，似乎毫无头绪。别急，我们先尝试将聚合对象Driver抽象化。参数类型修改为Drivable（由于Driver类也实现了Drivable接口），修改完成后代码如下：\n12345678910111213public class DriverLogProxy implements Drivable &#123;    private Drivable drivable;    public DriverLogProxy(Drivable drivable) &#123;        this.drivable = drivable;    &#125;    public void drive() throws InterruptedException &#123;        System.out.println(\"Drive start...\");        drivable.drive();        System.out.println(\"Drive complete...\");    &#125;&#125;\n1234567891011121314public class DriverTimeProxy implements Drivable &#123;    private Drivable drivable;    public DriverTimeProxy(Drivable drivable) &#123;        this.drivable = drivable;    &#125;    public void drive() throws InterruptedException &#123;        long start = System.currentTimeMillis();        drivable.drive();        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n至此，神奇的化学反应出现了。由于DriverLogProxy与DriveTimeProxy都实现了Drivable接口，我们可以将这两个对象相互聚合到对方的类中。\n例如，如果我们要先打印方法的执行时间再打印日志，可以这样做：\n12345678public static void main(String[] args) throws InterruptedException &#123;    Driver driver = new Driver();        DriverTimeProxy driverTimeProxy = new DriverTimeProxy(driver);    DriverLogProxy driverLogProxy = new DriverLogProxy(driverTimeProxy);        driverLogProxy.drive();&#125;\n而如果我们要先打印日志再打印方法的执行时间，可以这样做：\n12345678public static void main(String[] args) throws InterruptedException &#123;    Driver driver = new Driver();    DriverLogProxy driverLogProxy = new DriverLogProxy(driver);    DriverTimeProxy driverTimeProxy = new DriverTimeProxy(driverLogProxy);    driverTimeProxy.drive();&#125;\n在前面的例子中，为了实现相同的功能，我们至少需要创建四个类，而这里似乎只需要两个类就搞定了。显然，这种通过代理处理的方式更优。\n动态代理在上面的例子中，我们通过静态代理仅使用两个类就完成了四种不同顺序调用的组合，这种在一个类中持有另一个类的实例引用的方式也被称之为聚合。在这种场景中，我们可以说，聚合优于继承。\n接下来，我们继续加大问题的难度，我们是否可以在任意对象的任意方法前后添加任意的操作呢？并且不需要增加额外的类。\n这个问题的难度一下提高了不少，为了简化问题的难度，我们将问题分解一下。\n首先，第一个要点是，必须在任意对象的任意方法前后执行任意的操作，这就要求我们必须拿到对象中的任意方法。要拿到对象的任意方法怎么做呢，反射恰好可以解决你的问题。\n第二个要点，不能增加额外的类，换句话说，DriverLogProxy与DriverTimeProxy都不需要增加，怎么办！这个地方不太容易想到，其实我们可以帮助用户生成这样的类，使用Java代码编译并通过ClassLoader将字节码加载到内存中，再通过反射的方式进行调用。这样看起来虽然生成了额外的类，但用户是无法感知的，也就做到了不增加额外类的要求。\n接下来，我们先来尝试动态生成针对时间的代理类DriverTimeProxy，这个类的完整代码如下所示：\n1234567891011121314public class DriverTimeProxy implements Drivable &#123;    private Drivable drivable;    public DriverTimeProxy(Drivable drivable) &#123;        this.drivable = drivable;    &#125;    public void drive() throws InterruptedException &#123;        long start = System.currentTimeMillis();        drivable.drive();        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n为了生成这样的代码，我们需要分两步处理：\n第一步：将上面的代码当成字符串拼接到变量str中\n第二步：使用File类将文件输出到硬盘\n以上是我们生成DriverTimeProxy类源码的基本思路，为了简化第一步的处理，这里我们使用JavaPoet来处理。\nJavaPoet是什么呢，JavaPoet其实就是一个Java源码生成工具，为了让大家对JavaPoet有一个更直观的了解，我们先来看一段使用JavaPoet编写的代码：\n12345678910111213141516MethodSpec main = MethodSpec.methodBuilder(\"main\")    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)    .returns(void.class)    .addParameter(String[].class, \"args\")    .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")    .build();TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)    .addMethod(main)    .build();JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)    .build();javaFile.writeTo(System.out);\n将以上代码复制到main方法中执行，你将得到下面这样的输出结果：\n1234567package com.example.helloworld;public final class HelloWorld &#123;  public static void main(String[] args) &#123;    System.out.println(\"Hello, JavaPoet!\");  &#125;&#125;\n怎么样，明白了吧。通过使用上面的一段API对Java代码进行描述，JavaPoet就自动帮我们生成了一段非常漂亮的Java代码，连排版都省了，这就是JavaPoet的作用。\nOk，接下来我们增加下面这段代码帮助我们生成DriverTimeProxy：\n123456789101112131415161718192021222324252627282930MethodSpec drive = MethodSpec.methodBuilder(\"drive\")        .addModifiers(Modifier.PUBLIC)        .addAnnotation(Override.class)        .addException(InterruptedException.class)        .addStatement(\"long start = $T.currentTimeMillis()\", System.class)        .addStatement(\"drivable.drive()\")        .addStatement(\"long end = $T.currentTimeMillis()\", System.class)        .addStatement(\"$T.out.println(end - start)\", System.class)        .build();FieldSpec fieldSpec = FieldSpec.builder(Drivable.class, \"drivable\")        .addModifiers(Modifier.PRIVATE)        .build();MethodSpec constructor = MethodSpec.constructorBuilder()        .addModifiers(Modifier.PUBLIC)        .addParameter(Drivable.class, \"drivable\")        .addStatement(\"this.$N = $N\", \"drivable\", \"drivable\")        .build();TypeSpec driverTimeProxy = TypeSpec.classBuilder(\"DriverTimeProxy\")        .addModifiers(Modifier.PUBLIC)        .addSuperinterface(Drivable.class)        .addMethod(drive)        .addMethod(constructor)        .addField(fieldSpec)        .build();JavaFile javaFile = JavaFile.builder(\"com.youngfeng.designmode.proxy\", driverTimeProxy).build();javaFile.writeTo(System.out);\n在main运行以上代码，你将得到下面这样的结果：\n12345678910111213141516171819202122package com.youngfeng.designmode.proxy;import com.youngfeng.designmode.proxy.juhe.Drivable;import java.lang.InterruptedException;import java.lang.Override;import java.lang.System;public class DriverTimeProxy implements Drivable &#123;  private Drivable drivable;  public DriverTimeProxy(Drivable drivable) &#123;    this.drivable = drivable;  &#125;  @Override  public void drive() throws InterruptedException &#123;    long start = System.currentTimeMillis();    drivable.drive();    long end = System.currentTimeMillis();    System.out.println(end - start);  &#125;&#125;\n这恰好就是DriverTimeProxy类的完整代码。接下来，我们继续尝试第二步，将生成的DriverTimeProxy类动态编译并加载到内存中，同时通过反射的方式创建该对象。为了让大家看的更清晰，我们创建一个新类Proxy并增加一个静态方法newProxyInstance专门用来处理这个问题。\n为了实现动态编译，我们需要将文件输出到硬盘中，简单起见，这里我直接将其输出到我的电脑桌面。为了将其编译为Java字节码，我们需要使用JDK自带的工具类JavaCompiler进行处理，这是第一步处理。\n第二步处理，通过JavaCompiler编译完成后需要通过ClassLoader将生成的字节码加载到内存中，再通过反射获取DriverTimeProxy实例，其完整的处理流程如下：\n12345678910111213141516171819JavaFile javaFile = JavaFile.builder(\"com.youngfeng.designmode.proxy\", driverTimeProxy).build();File sourceFile = new File(PATH);javaFile.writeTo(sourceFile);// 编译生成的Java源码javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);Iterable iterable = fileManager.getJavaFileObjects(PATH + \"/com/youngfeng/designmode/proxy/DriverTimeProxy.java\");javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);task.call();fileManager.close();// 通过反射将源码加载到内存中URL[] urls = new URL[] &#123;new URL(\"file:\" + PATH)&#125;;URLClassLoader classLoader = new URLClassLoader(urls);Class cls = classLoader.loadClass(\"com.youngfeng.designmode.proxy.DriverTimeProxy\");Constructor constr = cls.getConstructor(Drivable.class);Object obj = constr.newInstance(drivable);\n结合上面的分析，Proxy类的完整代码如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class Proxy &#123;    // 这里需要修改为你自己期望的源码生成路径    private static String PATH = \"/Users/ouyangfeng/Desktop\";    public static Object newProxyInstance(Drivable drivable) &#123;        try &#123;            MethodSpec drive = MethodSpec.methodBuilder(\"drive\")                    .addModifiers(Modifier.PUBLIC)                    .addAnnotation(Override.class)                    .addException(InterruptedException.class)                    .addStatement(\"long start = $T.currentTimeMillis()\", System.class)                    .addStatement(\"drivable.drive()\")                    .addStatement(\"long end = $T.currentTimeMillis()\", System.class)                    .addStatement(\"$T.out.println(end - start)\", System.class)                    .build();            FieldSpec fieldSpec = FieldSpec.builder(Drivable.class, \"drivable\")                    .addModifiers(Modifier.PRIVATE)                    .build();            MethodSpec constructor = MethodSpec.constructorBuilder()                    .addModifiers(Modifier.PUBLIC)                    .addParameter(Drivable.class, \"drivable\")                    .addStatement(\"this.$N = $N\", \"drivable\", \"drivable\")                    .build();            TypeSpec driverTimeProxy = TypeSpec.classBuilder(\"DriverTimeProxy\")                    .addModifiers(Modifier.PUBLIC)                    .addSuperinterface(Drivable.class)                    .addMethod(drive)                    .addMethod(constructor)                    .addField(fieldSpec)                    .build();            JavaFile javaFile = JavaFile.builder(\"com.youngfeng.designmode.proxy\", driverTimeProxy).build();            File sourceFile = new File(PATH);            javaFile.writeTo(sourceFile);            // 编译生成的Java源码            javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();            StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);            Iterable iterable = fileManager.getJavaFileObjects(PATH + \"/com/youngfeng/designmode/proxy/DriverTimeProxy.java\");            javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);            task.call();            fileManager.close();            // 通过反射将源码加载到内存中            URL[] urls = new URL[] &#123;new URL(\"file:\" + PATH)&#125;;            URLClassLoader classLoader = new URLClassLoader(urls);            Class cls = classLoader.loadClass(\"com.youngfeng.designmode.proxy.DriverTimeProxy\");            Constructor constr = cls.getConstructor(Drivable.class);            Object obj = constr.newInstance(drivable);            return obj;        &#125; catch (Exception e) &#123;            e.printStackTrace();            return null;        &#125;    &#125;&#125;\n这里的整个过程相对比较复杂，为了让大家更直观地看到整个过程，我用一张图来描述一下整个过程到底发生了什么。\n\n在上图中，大家可以看到，有三个小助手在帮助我们完成整个过程。他们分别是JavaPoet，帮助生成Java源码文件；JavaCompiler，帮助编译Java源码文件；Reflect（反射)，帮助动态创建DriverTimeProxy实例。\n至此，我们终于完成了DriverTimeProxy动态实例的创建，从现在开始，DriverTimeProxy.java的源码文件可以从我们的工程中删除掉了。换句话说，我们完成了前面需求中的其中一个，不需要新增额外的类这个部分。\n等等，是否任意实现了Drivable接口的类都可以通过Proxy.newProxyInstance()方法创建代理实例增加日志打印功能呢？\n是的，没错，你已经做到了。因为newProxyInstance的参数是Drivable接口类型，任意实现了该接口的对象都可以作为参数传入进来。\n万里长征我们似乎已经走了一大半了。但，还不够！说好的实现任意自定义操作呢，这里只不过是打印日志而已。别急，我们继续往下看。\n为了实现任意的自定义操作，我们需要增加进一步抽象。既然操作是任意的，那么这个操作部分就不能由我们做主，应该交给用户。可问题是，到底应该如何只交出自定义操作权限，其它交给Proxy类实现呢。\n这里比较容易想到的一个思路是，增加一个统一的接口，接口中只需要包含一个方法，每次调用代理类接口方法的时候都去调用该方法。至于在该方法中到底要做什么，交给用户去处理。\n这个思路是完全可行的，我们还是用一张图来描述整个过程。\n\n上图中的InvocatinHandler是计划用来拦截代理类的drive方法调用的。当调用drive方法的时候实际上是调用InvocationHandler的invoke方法。\n这样做的好处是什么呢，很明显，我们已经交出了自定义逻辑的主动权，用户可以在invoke方法中实现任意的自定义操作。为了能够实现自定义操作，这里的InvocationHandler也必须是一个接口。\n按照这个设计，InvocationHandler实例必须作为参数传入到newInstanceProxy方法中。为了让大家看的更清晰，我们先手动实现新版本的DriverTimeProxy类。\n我想，大家首先能够想到的第一个版本应该是这样：\n123public interface InvocationHandler &#123;    void invoke(Object proxy);&#125;\n123456789101112public class DriverTimeProxy implements Drivable &#123;    private InvocationHandler invocationHandler;    public DriverTimeProxy(InvocationHandler invocationHandler) &#123;        this.invocationHandler = invocationHandler;    &#125;    @Override    public void drive() throws InterruptedException &#123;       invocationHandler.invoke(this);    &#125;&#125;\n这样的设计确实存在一些问题，我们先不管，先按照这个设计，使用JavaPoet帮助我们生成这样的代码。这个时候，newProxyInstance应该修改为下面这样：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static Object newProxyInstance(InvocationHandler handler, Class ints) &#123;    try &#123;        MethodSpec drive = MethodSpec.methodBuilder(\"drive\")                .addModifiers(Modifier.PUBLIC)                .addAnnotation(Override.class)                .addException(InterruptedException.class)                .addStatement(\"invocationHandler.invoke(this)\")                .build();        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, \"invocationHandler\")                .addModifiers(Modifier.PRIVATE)                .build();        MethodSpec constructor = MethodSpec.constructorBuilder()                .addModifiers(Modifier.PUBLIC)                .addParameter(InvocationHandler.class, \"invocationHandler\")                .addStatement(\"this.$N = $N\", \"invocationHandler\", \"invocationHandler\")                .build();        TypeSpec driverTimeProxy = TypeSpec.classBuilder(\"DriverTimeProxy\")                .addModifiers(Modifier.PUBLIC)                .addSuperinterface(ints)                .addMethod(drive)                .addMethod(constructor)                .addField(fieldSpec)                .build();        JavaFile javaFile = JavaFile.builder(\"com.youngfeng.designmode.proxy\", driverTimeProxy).build();        File sourceFile = new File(PATH);        javaFile.writeTo(sourceFile);        // 编译生成的Java源码        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);        Iterable iterable = fileManager.getJavaFileObjects(PATH + \"com/youngfeng/designmode/proxy/DriverTimeProxy.java\");        javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);        task.call();        fileManager.close();        // 通过反射将源码加载到内存中        URL[] urls = new URL[] &#123;new URL(\"file:\" + PATH)&#125;;        URLClassLoader classLoader = new URLClassLoader(urls);        Class cls = classLoader.loadClass(\"com.youngfeng.designmode.proxy.DriverTimeProxy\");        Constructor constr = cls.getConstructor(InvocationHandler.class);        Object obj = constr.newInstance(handler);        return obj;    &#125; catch (Exception e) &#123;        e.printStackTrace();        return null;    &#125;&#125;\n这里我们的DriverTimeProxy构造函数的参数换成了InvocationHandler实例，Drivable实例参数也就不再需要了，但必须传入代理类需要实现的接口类型。因此，newProxyInstance方法的参数变成了两个：InvocationHandler实例与接口的Class类型。\n这个版本的newProxyInstance与上一个版本到底有什么不同呢。这里，我们先来做一个简单的总结。\n在这个版本的实现中，我们不再需要传入真正的被代理类实例了。我们也去掉了获取方法执行时间的逻辑，这就意味着我们可以在方法的执行前后添加任意的操作了。\n这样说起来可能有点抽象，我们继续回到打印方法时间的问题，在这个版本的实现中，如果要打印方法的执行时间，需要怎么做呢。看下面，我们可以这样做：\n1234567891011121314151617181920212223242526272829// 增加自己的InvocationHandler实现类，在类中包含目标代理类Driver实例public class MyInvocationHandler implements InvocationHandler &#123;    private Driver target;    public MyInvocationHandler(Driver target) &#123;        this.target = target;    &#125;    @Override    public void invoke(Object proxy) &#123;        long start = System.currentTimeMillis();        try &#123;            target.drive();        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;// 运行测试public static void main(String[] args) throws InterruptedException &#123;    Driver driver = new Driver();    Object proxy = Proxy.newProxyInstance(new MyInvocationHandler(driver), Drivable.class);    ((Drivable)proxy).drive();&#125;\n很神奇，是吗？我们最终将自定义逻辑的实现转移到了接口InvocationHandler的实现类中，至于要对方法做日志打印还是统计时间，只需要自己实现即可，例如，如果要打印日志，在invoke方法中，增加日志打印语句即可：\n1234567891011121314151617@Overridepublic void invoke(Object proxy) &#123;    long start = System.currentTimeMillis();    System.out.println(\"Drive start...\");    try &#123;        target.drive();    &#125; catch (InterruptedException e) &#123;        e.printStackTrace();    &#125;    System.out.println(\"Drive complete...\");    long end = System.currentTimeMillis();    System.out.println(end - start);&#125;\n有人说，如果调换日志打印与时间打印的顺序呢，很简单，直接修改invoke方法中的打印顺序即可，逻辑的设计已经完全掌握在了你自己手中，想怎么操作就怎么操作。\n至此，经过艰难的长途跋涉，我们终于完全地抛弃掉了DriverTimeProxy与DriverLogProxy两个类，仅需要实现InvocationHandler接口就可以完成各种逻辑的排列组合了。而且，真正的代理类实现对用户来说是完全不可见的，这就是所谓的动态代理。\n但，还不够！如果这里我们需要实现另外一个类型的类代理，而这个类中的方法存在参数和返回值的话，这里的设计又出现问题了。为什么呢，看下面的代码：\n1234// ICreatorpublic interface ICreator &#123;    Person.Builder create(String name);&#125;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344// Person.javapublic class Person &#123;    private String name;    private int age;    private Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public static class Builder &#123;        private String name;        private int age;        public Builder(String name) &#123;            this.name = name;        &#125;        public Builder age(int age) &#123;            this.age = age;            return this;        &#125;        public Person build() &#123;            return new Person(this.name, this.age);        &#125;    &#125;&#125;\n12345678// BuilderCreatorpublic class BuilderCreator implements ICreator &#123;    @Override    public Person.Builder create(String name) &#123;        return new Person.Builder(name);    &#125;&#125;\n这里我们增加了三个类，一个接口，这里需要被代理的类是BuilderCreator。\n与之前的Drivable接口不同的是，这里的ICreator接口中的方法不仅存在参数，而且还有返回值。那么，问题来了！\n这里暴露出了我们之前设计存在的两个问题：\n第一个问题：参数无法传入到InvocationHandler中。\n第二个问题：无法获取到目标代理实例方法调用的返回值。\n先来看第一个问题，假设我们自己实现了InvocationHandler，代码如下：\n12345678910111213public class MyInvocationHandler implements InvocationHandler &#123;    private BuilderCreator target;    public MyInvocationHandler(BuilderCreator target) &#123;        this.target = target;    &#125;    @Override    public void invoke(Object proxy) &#123;        // create方法的参数无法获取到，这里将无法被调用        this.target.create(xxx)    &#125;&#125;\n在上面的代码中，我们发现，当我们对目标代理对象调用create方法的时候，发现create方法的参数无法传入进来了。\n怎么办呢！为了保证方法参数可以被传入进来，这里的invoke方法必须再增加一个参数表示外部传入的参数值。由于方法参数可能有多个，这里的参数类型我们用一个对象数组来表示。\n这是第一个问题，再来看第二个问题。\n由于我们的create方法实际会返回BuilderCreator实例，而在我们的设计中invoke方法是无返回值的。因此，当我们调用代理类的接口方法时，将无法获取到create方法的返回值，也就无法实现后面的调用。因此，为了可以获取到方法的返回值，这里的invoke方法还需要增加一个返回值，类型未知，我们就用Object类型。\n按照上面的修正，我们的InvocationHandler接口应该这样设计：\n123public interface InvocationHandler &#123;   Object invoke(Object proxy, Object[] args);&#125;\n按照这样的设计，newProxyInstance方法应该这样修改：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public static Object newProxyInstance(InvocationHandler handler, Class ints) &#123;    try &#123;        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, \"invocationHandler\")                .addModifiers(Modifier.PRIVATE)                .build();        MethodSpec constructor = MethodSpec.constructorBuilder()                .addModifiers(Modifier.PUBLIC)                .addParameter(InvocationHandler.class, \"invocationHandler\")                .addStatement(\"this.$N = $N\", \"invocationHandler\", \"invocationHandler\")                .build();        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(\"DriverTimeProxy\")                .addModifiers(Modifier.PUBLIC)                .addSuperinterface(ints)                .addMethod(constructor)                .addField(fieldSpec);        // 为了保证灵活性，这里需要遍历接口中的方法，逐一实现        Method[] methods = ints.getMethods();        for (Method method: methods) &#123;            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName())                    .addModifiers(Modifier.PUBLIC)                    .addAnnotation(Override.class);            Class[] params = method.getParameterTypes();            String args = params.length &lt;= 0 ? null : \"new Object[] &#123;\";            for (int i = 0; i &lt; params.length; i++) &#123;                Class param = params[i];                methodSpecBuilder.addParameter(ParameterSpec.builder(param, \"p\" + i).build());                args += \"p\" + i + \",\";            &#125;            args = args == null ? args : args.substring(0, args.length() - 1) + \"&#125;\";            Class[] exceptions = method.getExceptionTypes();            for (int i = 0; i &lt; exceptions.length; i++) &#123;                methodSpecBuilder.addException(exceptions[i]);            &#125;            Class returnType = method.getReturnType();            methodSpecBuilder.returns(returnType);            // 方法没有返回值的情况下，这里需要额外处理            if (returnType.getName().equals(\"void\")) &#123;                methodSpecBuilder.addStatement(\"this.invocationHandler.invoke(this, \" + args + \")\");            &#125; else &#123;                // 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型                methodSpecBuilder.addStatement(\"Object result = this.invocationHandler.invoke(this, \" + args + \")\")                        .addCode(\"if (result instanceof $T) &#123;\\n\", TypeName.get(method.getReturnType()).box())                        .addStatement(\"\\treturn ($T) result\", TypeName.get(returnType).box())                        .addCode(\"&#125; else &#123;\\n\")                        .addStatement(\"\\treturn ($T) null\", TypeName.get(returnType).box())                        .addCode(\"&#125;\\n\");            &#125;            typeSpecBuilder.addMethod(methodSpecBuilder.build());        &#125;        JavaFile javaFile = JavaFile.builder(\"com.youngfeng.designmode.proxy\", typeSpecBuilder.build()).build();        File sourceFile = new File(PATH);        javaFile.writeTo(sourceFile);        // 编译生成的Java源码        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);        Iterable iterable = fileManager.getJavaFileObjects(PATH + \"com/youngfeng/designmode/proxy/DriverTimeProxy.java\");        javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);        task.call();        fileManager.close();        // 通过反射将源码加载到内存中        URL[] urls = new URL[] &#123;new URL(\"file:\" + PATH)&#125;;        URLClassLoader classLoader = new URLClassLoader(urls);        Class cls = classLoader.loadClass(\"com.youngfeng.designmode.proxy.DriverTimeProxy\");        Constructor constr = cls.getConstructor(InvocationHandler.class);        Object obj = constr.newInstance(handler);        return obj;    &#125; catch (Exception e) &#123;        e.printStackTrace();        return null;    &#125;&#125;\nnewProxyInstance方法似乎又复杂了许多，为了可以获取到用户传入的参数，我们必须严格匹配参数的命名。因此，这里将参数统一命名为pN。由于每个接口可能有多个方法，这里我们修改为通过遍历的方式获取传入接口的所有方法。同时，为了保证返回值类型与所需类型一致，在代码中，我们增加了类型判断，自动转换到预期的数据类型。\n接下来，我们简单测试一下方法是否按照我们预期的情况运行。实现InvocationHandler接口，在main方法中添加如下测试代码，尝试运行，查看结果：\n12345678910111213141516171819202122public class MyInvocationHandler implements InvocationHandler &#123;    private BuilderCreator target;    public MyInvocationHandler(BuilderCreator target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Object[] args) &#123;        return this.target.create((String) args[0]);    &#125;&#125;public static void main(String[] args) &#123;    BuilderCreator builderCreator = new BuilderCreator();    MyInvocationHandler handler = new MyInvocationHandler(builderCreator);    Object proxy = Proxy.newProxyInstance(handler, ICreator.class);    Person person = ((ICreator)proxy).create(\"Scott\").age(18).build();    System.out.println(person.getAge());&#125;\n运行上面的代码，输出结果18，很显然，代码按照预期的结果输出了。\n但是，我们还是忽略了一个问题，是什么问题呢，这里先卖个关子，我们先来回顾一下每一次的方法调用过程。\n\n在上面这张流程图中，在第一步调用中，我增加了几个方法，因为一个接口可能存在多个方法。通过newProxyInstance的处理，这些方法的调用最终都会通过调用InvocationHandler的invoke方法来实现间接调用。\n所以，这里的invoke方法的调用次数与接口的方法数是一致的。如果某个接口有5个方法，这里就会调用5次。而这个时候，我们之前设计的问题也就出现了。\n什么问题呢，通常来说，我们需要针对不同的方法进行不同的处理。而用户在invoke方法中无法知道当前究竟调用的是哪个方法，也就无法在invoke方法中针对不同的方法调用进行不同的处理。\n这样说起来还是有点抽象，为了让大家看的更直观，我们在ICreator接口中再增加一个方法foo, 运行，查看生成的代码是什么。\n12345public interface ICreator &#123;    Person.Builder create(String name);    int foo(int x, int y);&#125;\n最终动态生成的代码如下：\n12345678910111213141516171819202122232425262728293031323334package com.youngfeng.designmode.proxy;import com.youngfeng.designmode.proxy.juhe.InvocationHandler;import java.lang.Integer;import java.lang.Override;import java.lang.String;public class DriverTimeProxy implements ICreator &#123;  private InvocationHandler invocationHandler;  public DriverTimeProxy(InvocationHandler invocationHandler) &#123;    this.invocationHandler = invocationHandler;  &#125;  @Override  public Person.Builder create(String p0) &#123;    Object result = this.invocationHandler.invoke(this, new Object[] &#123;p0&#125;);    if (result instanceof Person.Builder) &#123;    \treturn (Person.Builder) result;    &#125; else &#123;    \treturn (Person.Builder) null;    &#125;  &#125;  @Override  public int foo(int p0, int p1) &#123;    Object result = this.invocationHandler.invoke(this, new Object[] &#123;p0,p1&#125;);    if (result instanceof Integer) &#123;    \treturn (Integer) result;    &#125; else &#123;    \treturn (Integer) null;    &#125;  &#125;&#125;\n可以看到每次调用实际调用的都是InvocationHandler的invoke方法。这个地方会让用户产生疑惑，究竟调用这个方法是发生在调用create还是foo的时候呢。\n为了让大家看的更清晰，我们还是看一眼用户端需要实现的InvocationHandler接口类，已经明白的同学可以跳过这个部分继续往下看：\n123456789101112131415public class MyInvocationHandler implements InvocationHandler &#123;    private BuilderCreator target;    public MyInvocationHandler(BuilderCreator target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Object[] args) &#123;\t // 这里会让用户产生疑惑，target实际有两个方法，而无论是\t // 调用create方法还是foo方法最终都会走这里。\t // 如果用户需要对不同的方法进行不同的处理就没法办到了。        return this.target.create((String) args[0]);    &#125;&#125;\n为了让用户知道这一次的调用究竟是调用哪个方法产生的，invoke方法还需要再增加一个参数，这个参数必须代表当前调用的方法。这里需要用到反射了，我们可以通过反射拿到当前调用方法的Method实例并传入到invoke方法中。\n我们摘取其中一个方法create来描述我们大概需要怎么做，看下面这段代码：\n12345678910111213141516 @Overridepublic Person.Builder create(String p0) &#123;    try &#123;    \t// 这里是计划新增的代码        Method method = Drivable.class.getMethod(\"create\", String.class);        Object result = this.invocationHandler.invoke(this, method, new Object[]&#123;p0&#125;);        if (result instanceof Person.Builder) &#123;            return (Person.Builder) result;        &#125; else &#123;            return (Person.Builder) null;        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();        return null;    &#125;&#125;\n为了生成上面这样的代码，我们继续改进newProxyInstance方法，改进后的方法如下所示：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public static Object newProxyInstance(InvocationHandler handler, Class ints) &#123;    try &#123;        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.class, \"invocationHandler\")                .addModifiers(Modifier.PRIVATE)                .build();        MethodSpec constructor = MethodSpec.constructorBuilder()                .addModifiers(Modifier.PUBLIC)                .addParameter(InvocationHandler.class, \"invocationHandler\")                .addStatement(\"this.$N = $N\", \"invocationHandler\", \"invocationHandler\")                .build();        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(\"DriverTimeProxy\")                .addModifiers(Modifier.PUBLIC)                .addSuperinterface(ints)                .addMethod(constructor)                .addField(fieldSpec);        // 为了保证灵活性，这里需要遍历接口中的方法，逐一实现        Method[] methods = ints.getMethods();        for (Method method: methods) &#123;            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName())                    .addModifiers(Modifier.PUBLIC)                    .addAnnotation(Override.class);            Class[] params = method.getParameterTypes();            String args = params.length &lt;= 0 ? null : \"new Object[] &#123;\";            String argTypes = params.length &lt;= 0 ? null : \"new Class[] &#123;\";            for (int i = 0; i &lt; params.length; i++) &#123;                Class param = params[i];                methodSpecBuilder.addParameter(ParameterSpec.builder(param, \"p\" + i).build());                args += \"p\" + i + \",\";                argTypes += TypeName.get(param).box().toString() + \".class,\";            &#125;            args = args == null ? args : args.substring(0, args.length() - 1) + \"&#125;\";            argTypes = argTypes == null ? argTypes : argTypes.substring(0, argTypes.length() - 1) + \"&#125;\";            Class[] exceptions = method.getExceptionTypes();            for (int i = 0; i &lt; exceptions.length; i++) &#123;                methodSpecBuilder.addException(exceptions[i]);            &#125;            Class returnType = method.getReturnType();            methodSpecBuilder.returns(returnType);            methodSpecBuilder.beginControlFlow(\"try\");            methodSpecBuilder.addStatement(\"$T method = getClass().getMethod($S, $N)\", Method.class, method.getName(), argTypes);            // 方法没有返回值的情况下，这里需要额外处理            if (returnType.getName().equals(\"void\")) &#123;                methodSpecBuilder.addStatement(\"this.invocationHandler.invoke(this, \" + args + \")\");            &#125; else &#123;                // 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型                methodSpecBuilder.addStatement(\"Object result = this.invocationHandler.invoke(this, method, \" + args + \")\")                        .addCode(\"if (result instanceof $T) &#123;\\n\", TypeName.get(method.getReturnType()).box())                        .addStatement(\"\\treturn ($T) result\", TypeName.get(returnType).box())                        .addCode(\"&#125; else &#123;\\n\")                        .addStatement(\"\\treturn ($T) null\", TypeName.get(returnType).box())                        .addCode(\"&#125;\\n\");            &#125;            methodSpecBuilder.nextControlFlow(\"catch ($T e)\", Exception.class)                    .addStatement(\"e.printStackTrace()\")                    .addStatement(\"return ($T) null\", TypeName.get(returnType).box())                    .endControlFlow();            typeSpecBuilder.addMethod(methodSpecBuilder.build());        &#125;        JavaFile javaFile = JavaFile.builder(\"com.youngfeng.designmode.proxy\", typeSpecBuilder.build()).build();        File sourceFile = new File(PATH);        javaFile.writeTo(sourceFile);        // 编译生成的Java源码        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(null, null, null);        Iterable iterable = fileManager.getJavaFileObjects(PATH + \"com/youngfeng/designmode/proxy/DriverTimeProxy.java\");        javax.tools.JavaCompiler.CompilationTask task = javaCompiler.getTask(null, fileManager, null, null, null, iterable);        task.call();        fileManager.close();        // 通过反射将源码加载到内存中        URL[] urls = new URL[] &#123;new URL(\"file:\" + PATH)&#125;;        URLClassLoader classLoader = new URLClassLoader(urls);        Class cls = classLoader.loadClass(\"com.youngfeng.designmode.proxy.DriverTimeProxy\");        Constructor constr = cls.getConstructor(InvocationHandler.class);        Object obj = constr.newInstance(handler);        return obj;    &#125; catch (Exception e) &#123;        e.printStackTrace();        return null;    &#125;&#125;\n至此，如果我们需要对不同的方法进行不同的处理，这里就可以通过method参数进行判断了。\n我们继续以代理BuilderCreator类为例，如果我们要在create与foo方法前后分别打印当前方法被调用的日志，可以这样做：\n12345678910111213141516171819202122public class MyInvocationHandler implements InvocationHandler &#123;\tprivate BuilderCreator target;\t\tpublic MyInvocationHandler(BuilderCreator target) &#123;\t    this.target = target;\t&#125;\t\t@Override\tpublic Object invoke(Object proxy, Method method, Object[] args) &#123;\t    try &#123;\t    \t// 通过method.getName()可以获取到方法名\t        System.out.println(method.getName() + \" invoke start...\");\t        Object result = method.invoke(target, args);\t        System.out.println(method.getName() + \" invoke end...\");\t\t        return result;\t    &#125; catch (Exception e) &#123;\t        e.printStackTrace();\t        return null;\t    &#125;\t&#125;&#125;\n到现在为止，我们的动态代理实现基本完整了，我们的旅程也快要结束了。终于，如果我们要在某个类的某个方法前后插入任意的逻辑，不再需要新增额外的类了（InvocationHandler实现类除外），而且添加的逻辑也可以完全自定义了，我们的目标达到了！\n回顾一下我们的整个探索过程，在文章的开篇部分我们从为Driver类的drive方法增加时间打印需求开始，最终选择通过代理的方式进行处理，这样做的灵活性明显高于继承。而为了去掉额外新增的类，我们使用了动态编译的方式在运行期间帮助用户生成相应的代理类。但我们并未满足于此，为了让插入的逻辑也实现自定义，我们又对插入进行了抽象，新增了插入逻辑抽象类InvocationHandler，最终将对Driver类的代理转换到对InvocationHandler实现类的代理中。将方法调用的主动权交给用户（InvocationHandler的实现类处理）。这样，无论是多么复杂的需求，对用户来说，只需要实现InvocationHandler接口增加自定义处理即可，即使某个类有100个方法，他需要的也只是一个InvocationHandler的实现类而已。\n等等，我们似乎还忘记了一件事情。一直以来我们生成的动态代理类名称都叫做DriverTimeProxy，而此刻它的功能已经不再仅仅是为Driver类增加时间打印而已了。因此，这里我们将最终生成的代理类名称修改为Proxy$0。最终版本的实现大家可以查看文章的附录部分，点击下方链接前去查看。\n动态代理到底有什么用在上面的整个过程中，我们可谓是经历了千难万险，终于完成了一个简易版本的动态代理。那么动态代理到底有什么作用呢。为了让大家直观地感受到，动态代理到底可以做什么，我们先一起来看一个简单的例子。\n这里我们创建两个类来简单模拟数据库事务的提交过程（以下代码仅作为演示使用，不具有实际使用价值）：\n123public interface TransactionConstr &#123;    void commit(int x);&#125;\n12345678910111213141516public class Database implements TransactionConstr &#123;    public static Database getInstance() &#123;        return new Database();    &#125;    @Override    public void commit(int x) &#123;        if (x &lt; 0) throw new IllegalArgumentException();        System.out.println(\"Transaction commit success...\");    &#125;    public void rollback() &#123;        System.out.println(\"Transaction rollback...\");    &#125;&#125;\n为了防止出现脏数据，我们需要在事务提交失败的时候将数据回滚。在没有动态代理之前，我们会这样处理：\n1234567891011public static void main(String[] args) &#123;    Database db = Database.getInstance();           // 通过try catch的方式手动回滚数据    try &#123;        db.commit(-1);    &#125; catch (Exception e) &#123;        e.printStackTrace();        db.rollback();    &#125;&#125;\n而使用动态代理，我们这样做：实现InvocationHandler，代理Database类，在invoke方法中捕获方法可能抛出的异常，一旦发现异常就调用rollback方法自动回滚。\n1234567891011121314151617public class AutoRollbackInvocationHandler implements InvocationHandler &#123;    private Database target;    public AutoRollbackInvocationHandler(Database target) &#123;        this.target = target;    &#125;    @Override    public Object invoke(Object proxy, Method method, Object[] args) &#123;        try &#123;            method.invoke(target, args);        &#125; catch (Exception e) &#123;            target.rollback();        &#125;        return null;    &#125;&#125;\n这里一定还是会有人说，这两种调用方式貌似没有什么区别啊。第二种写法在每次调用的时候不也需要先使用newProxyInstance生成代理类，然后再调用吗，这样反而麻烦了许多。\n其实，这两种方式有一个本质上的区别，前者免不了每次都添加try-catch语句。而后者由于是使用模板化的实现，我们可以在框架层帮助用户自动生成动态代理类，自动添加try-catch语句，这样用户就可以使用非常简单的方式实现事务的自动回滚了。例如，在方法上面添加一个自动回滚的注解，框架层识别注解自动生成代理类实例。这样，你需要的仅仅是一个注解而已了。如果你了解Java后端开发，你应该就知道我在说什么了。\n以上是动态代理设计模式的一个经典应用场景，但实际上，动态代理的使用场景还有很多。仔细观察动态代理的执行过程，它似乎为我们开辟了一个新的编程方式。相对于传统的流线型编程方式，动态代理可以在任意已经实现的类中的任意方法中插入自定义的逻辑，就像一把刀一样，将代码的执行过程切成片段，再往里插入自定义的逻辑。至此，计算机的编程方式就变成了cut-insert（切开-插入）的方式进行。这种编程方式，在计算机科学中，被称之为面向切面编程（AOP）。\nAOP动态代理是面向切面编程的一种经典实现。在大部分框架中，实现AOP都会使用JDK自带的动态代理处理。当然，JDK的实现其实也有一定的局限性，这就是为什么CGLIB这样的动态代理库大行其道的原因。不过，这不是本文讨论的重点，大家如果对CGLIB感兴趣的话，可以在文章下方给留言。\n说回AOP，到底什么是面向切面编程呢？前面其实已经有了一个简单的解释了，为了让大家看的更直观，我们先来看一张图：\n\n以上是面向切面编程框架AspectJ的示例图，AspectJ是一个非常流行面向切面编程Java库。我们就用这张图来给大家讲一下相对于传统编程，面向切面编程到底有什么不同。\n图中绿色箭头表示正常代码的执行过程，PointCut表示切入点，即在哪个类的哪些位置插入自定义逻辑。Join Points表示连接点，即具体的插入位置，例如方法调用前，调用后，异常抛出等等。\n由此可见，相当于传统的编程模型，AOP的思考点是：找到匹配的切入点，插入自定义逻辑，而且这种插入对原有框架代码是无侵入性的。相对于面向对象编程模型使用继承的方式进行扩展这种侵入性的处理方式，显然是一个巨大的进步。\n正是因为AOP具备高度自由、无侵入性的这些特点，才使得它在Spring等知名开源框架中有着大量的应用，而这一切的核心都依赖于AOP最经典的实现方式：动态代理。我想，这应该是动态代理到底有什么用这个问题最好的回答。\nJDK实现揭秘实际上，在上面的整个探索过程中，我们都是参照JDK实现来进行讲解的。但还有哪些地方是我们考虑不周的呢，一起来看看JDK实现吧。\n打开JavaSE官方文档，找到Proxy与InvocationHandler类。\nProxy.java\n\nInvocationHandler\n\n可以看到，JDK版本的newProxyInstance方法中一个有三个参数，第一个参数是ClassLoader，这就意味着我们可以指定自己的类加载器。第二个参数是接口数组，这是因为需要被代理的接口可能不止一个，或者说代理类实现的接口可能不止一个。这是在我们的版本中没有考虑到的一点，实际使用场景中这种情况其实是很常见的。\nJDK版本中，InvocationHandler接口的定义与我们的版本是完全一致的。在前一篇文章中，关于这个接口中方法里面几个参数的意思，有不少同学问到，甚至有同学在微信公众号“欧阳锋工作室”给我私信，问到了这个问题。这里统一给大家解答一下：\nproxy：这个参数表示动态生成的代理类实例，在某些场景中你可能需要对代理实例做一些特殊的处理，这个时候，这个参数的作用就出来了，大多数情况下你不需要用到这个参数。\nmethod：这个参数在前面的文章中其实已经讲过了，它表示实际调用的代理类的接口方法的Method实例，用户可以使用它调用目标代理类的方法。\nargs：这个参数表示method对应方法传入的参数值，这里可以提供给method方法反射调用，也可以通过直接调用的方式逐一传入参数值到目标代理类方法中。\n返回值：invoke方法的返回值，这里也有一些同学问到，这个也是上一篇文章中解释不够到位的地方。这一次我们在前面的例子中详细解释了invoke方法的返回值到底有什么作用。它实际上对应的是被代理类对应method方法的返回值。这是与接口方法一一对应的，方便调用者轻松获取到实际代理类方法调用的返回值。\n写在最后最后，感谢大家陪伴我走过了这一段艰难的探索旅程，这的确不太容易。如果你完整地看完了整篇文章，并且根据文章的推进过程同步完成了代码开发，应该给自己鼓个掌。因为，这的确不太容易。Java动态代理设计模式是所有设计模式中最难理解的一个。如果你已经看懂了这个设计模式，其它的设计模式就已经是“除却巫山不是云”了。\n希望这篇文章说清楚了前一篇文章大家提的每一个问题，也说清楚了动态代理的每一处细节。如果你还有疑问，欢迎在文章下方给我留言，或者来我的微信公众号“欧阳锋工作室”给我发私信。\n附录例子源码：https://github.com/yuanhoujun/java-dynamic-proxy\n上一篇：点这里前往\n关注微信公众号”欧阳锋工作室“，阅读更多文章。\n\n","dateCreated":"2019-11-29T14:22:47+08:00","dateModified":"2022-09-08T16:13:27+08:00","datePublished":"2019-11-29T14:22:47+08:00","description":"\n关于动态代理，我之前写过一篇文章《10分钟看懂动态代理设计模式》。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？\n","headline":"10分钟看懂动态代理设计模式（升级篇）","image":[],"mainEntityOfPage":{"@type":"WebPage","@id":"http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"},"publisher":{"@type":"Organization","name":"欧阳锋工作室","sameAs":["https://github.com/yuanhoujun","assets/images/mpwexin.jpg","https://weibo.com/u/6140262139?is_all=1","mailto:ouyangfeng2016@gmail.com"],"image":"avatar.jpeg","logo":{"@type":"ImageObject","url":"avatar.jpeg"}},"url":"http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/","keywords":"动态代理"}</script>
    <meta name="description" content="关于动态代理，我之前写过一篇文章《10分钟看懂动态代理设计模式》。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？">
<meta name="keywords" content="动态代理">
<meta property="og:type" content="blog">
<meta property="og:title" content="10分钟看懂动态代理设计模式（升级篇）">
<meta property="og:url" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/index.html">
<meta property="og:site_name" content="欧阳锋工作室">
<meta property="og:description" content="关于动态代理，我之前写过一篇文章《10分钟看懂动态代理设计模式》。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy0.png">
<meta property="og:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy1.png">
<meta property="og:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy2.png">
<meta property="og:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy3.jpg">
<meta property="og:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy4.jpg">
<meta property="og:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy5.jpg">
<meta property="og:image" content="http://youngfeng.com/assets/images/mpwexin.jpg">
<meta property="og:updated_time" content="2022-09-08T08:13:27.233Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="10分钟看懂动态代理设计模式（升级篇）">
<meta name="twitter:description" content="关于动态代理，我之前写过一篇文章《10分钟看懂动态代理设计模式》。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？">
<meta name="twitter:image" content="http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy0.png">
    
    
        
    
    
        <meta property="og:image" content="http://youngfeng.com/assets/images/avatar.jpeg"/>
    
    
    
    
    <!--STYLES-->
    <link rel="stylesheet" href="/assets/css/all.css">
    <link rel="stylesheet" href="/assets/css/jquery.fancybox.css">
    <link rel="stylesheet" href="/assets/css/thumbs.css">
    <link rel="stylesheet" href="/assets/css/tranquilpeak.css">
    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            欧阳锋工作室
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">欧阳锋工作室</h4>
                
                    <h5 class="sidebar-profile-bio"><p>author.bio</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/yuanhoujun"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/assets/images/mpwexin.jpg"
                            
                            rel="noopener"
                            title="微信公众号"
                        >
                        <i class="sidebar-button-icon fab fa-weixin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微信公众号</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://weibo.com/u/6140262139?is_all=1"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="微博"
                        >
                        <i class="sidebar-button-icon fab fa-weibo" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">微博</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:ouyangfeng2016@gmail.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="4"
                 class="
                        hasCoverMetaIn
                        ">
                
<article class="post">
    
    
        <div class="post-header main-content-wrap text-left">
    
        <h1 class="post-title">
            10分钟看懂动态代理设计模式（升级篇）
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2019-11-29T14:22:47+08:00">
	
		    11月 29, 2019
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/设计模式/">设计模式</a>


    
</div>

    
</div>

    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <blockquote>
<p>关于动态代理，我之前写过一篇文章<a href="http://youngfeng.com/2018/03/02/design%20pattern/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">《10分钟看懂动态代理设计模式》</a>。在这篇文章中，我收到了一些关于动态代理的提问，也有同学在微信公众号给我私信，询问关于动态代理的问题。再次Review这篇文章之后，我发现了一些问题。确实有一些细节没有介绍清楚，有一些地方含混过关了。因此，我决定重新写一篇关于动态代理的文章，希望可以讲清楚关于动态代理实现的每一处细节。这注定又是一场艰难的旅程，你愿意加入我们吗？</p>
</blockquote>
<a id="more"></a>
<p>这篇文章的思路还是同之前的文章一样，由浅入深，如果你已经看过上一篇文章，部分章节可以跳过。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>那么，到底什么是代理呢？</p>
<p>所谓的代理，其实就是中间人的意思。例如：让朋友代替你去取快递，你的朋友就充当了代理的作用。再比如，让你的朋友帮你去借款，你的朋友实际上也充当了代理的作用，最终这笔钱的受益人还是你自己。</p>
<p>理解了代理的意思，接下来我们一起来看一下，在面向对象编程语言中，到底应该如何体现代理呢。</p>
<p>这里我们就以上面提到的代取快递为例，来写一个简单的代理实现。</p>
<p>我们用<code>Friend</code>类表示你的朋友，用<code>Self</code>表示你自己，上面的例子用代码实现应该是这样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Friend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Friend</span>(<span class="params">String name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">this</span>.name + <span class="string">"去取快递..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Self</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Friend <span class="keyword">friend</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Self</span><span class="params">(Friend <span class="keyword">friend</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">friend</span> = <span class="keyword">friend</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于实际动作的执行者是你的朋友</span></span><br><span class="line">    <span class="comment">// 因此，这里直接调用Friend的collectPack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">friend</span>.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend <span class="keyword">friend</span> = <span class="keyword">new</span> Friend(<span class="string">"张三"</span>);</span><br><span class="line">        Self self = <span class="keyword">new</span> Self(<span class="keyword">friend</span>);</span><br><span class="line">        <span class="comment">// 这里将打印”张三去取快递...“</span></span><br><span class="line">        self.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，我们实现了一个简单的代理。这里的代理类是<code>Friend</code>，被代理类是<code>Self</code>，通过这段代码，我们知道了一个基本事实：<strong>代理对象</strong>是真正去执行动作的对象，<strong>被代理对象</strong>是被动执行动作的对象（并不真正执行动作）。</p>
<p>上面的实现看似没有问题，实际上却不够友好，由于代理对象能够替被代理对象执行动作。所以，他们应该具有同样的一些方法。换句话说，应该实现他们应该实现同样的接口，这个接口中的方法表示双方都可以执行的一些动作，或者说可能要被代理的一些动作。</p>
<p>因此，上面的代码可以改写成下面这样：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个接口表示代理类与被代理类可以共同执行的动作</span></span><br><span class="line"><span class="comment">//  或者说，具体想要被代理的动作方法集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Collectable</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">collectPack</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Friend</span> <span class="keyword">implements</span> <span class="title">Collectable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Friend</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name + <span class="string">"去取快递..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Self</span> <span class="title">implements</span> <span class="title">Collectable</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Friend <span class="keyword">friend</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Self</span><span class="params">(Friend <span class="keyword">friend</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">friend</span> = <span class="keyword">friend</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于实际动作的执行者是你的朋友</span></span><br><span class="line">    <span class="comment">// 因此，这里直接调用Friend的collectPack方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">collectPack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">friend</span>.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Friend <span class="keyword">friend</span> = <span class="keyword">new</span> Friend(<span class="string">"张三"</span>);</span><br><span class="line">        Self self = <span class="keyword">new</span> Self(<span class="keyword">friend</span>);</span><br><span class="line">        self.collectPack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>恭喜你！通过上面的改造，我们已经完成了一个标准的静态代理实现。之所以称之为静态代理，是因为这里的逻辑是写死的，并不具备动态特性。与之相对的，就是今天这篇文章的主角：动态代理。</p>
<h3 id="代理的作用是什么"><a href="#代理的作用是什么" class="headerlink" title="代理的作用是什么"></a>代理的作用是什么</h3><p>看到这里，应该有人会问了，说了这么多，代理到底有什么用呢。这个问题并不容易回答，为了回答你的这个问题，我们先来看一个场景。</p>
<p>假设有一个类<code>Driver</code>，类中只有一个方法<code>drive</code>，我们不能改动这个类的源码，如何获取这个方法的执行时间呢？</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Driver</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"I'm driving..."</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Drive completed..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的同学可能会说，这还不简单，在main方法中，方法执行前记录一个时间，方法执行后记录一个时间，两个时间相减就得到了方法最终的执行时间。</p>
<p><strong>位置p1</strong></p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    driver.drive();</span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法到底对不对呢，先说结论：不对！这里的时间会大于方法实际执行的时间，因为这里包含了准备方法的那些时间。</p>
<p>除了这个方法之外，还有一个比较容易想到的方法就是<strong>继承</strong>。通过继承Driver类，在drive方法前后打印时间，计算时间差，这种方式似乎可行！</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver1</span> <span class="keyword">extends</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        long start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        long end = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="type">System</span>.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>位置p2</strong></p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Driver1 driver1 = <span class="keyword">new</span> Driver1();</span><br><span class="line">    driver1.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个疑点，有些同学在问，到底方法的准备时间是什么，为什么会有准备方法的这些时间。这两种方式不是都需要准备方法吗？</p>
<p>上面我们说到，直接打印的方式包含了准备方法的那些时间，准备一个方法通常需要先压栈，调用后自动出栈，这些都需要时间，尤其在一些性能比较低的机器上会体现的特别明显。不信，大家可以执行位置p1处的代码与位置p2处的代码，你会发现，位置p2处的执行时间几乎总是比位置p1处的执行时间少3~5毫秒（在我的Macbook Pro 15.4 2017上执行是这样的结果，其它机型时间可能略有差异）。在继承中不需要这些时间的原因是：我们是方法内部执行的，这个时候方法已经准备好，就不存在这个准备时间了。</p>
<p>Ok，说完了上面这个问题，我们继续回到上面的代码。在上面的代码中，我们通过继承的方式获得了方法的执行时间。接下来，新需求来了，我要你在<code>drive</code>方法前后各打印一条日志。</p>
<p>你会怎么做呢，当然毫无疑问，我们继续沿用上面的解决方案，继承Driver类创建新类Driver2。然后，在super调用前后各打印一条日志。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> <span class="keyword">extends</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题似乎很简单，可是，新的需求又来了。我要你先打印日志再获取方法的执行时间。其实，这也很简单。我们只要继承上面的<code>Driver2</code>类，重写<code>drive</code>方法获取方法执行的时间即可：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver3</span> <span class="keyword">extends</span> <span class="title">Driver2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        long start = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        long end = <span class="type">System</span>.currentTimeMillis();</span><br><span class="line">        <span class="type">System</span>.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，麻烦来了。需求又变了，我要你先获取方法的执行时间再打印日志，怎么办。</p>
<p>有人说，这也没毛病啊。我们只要继承<code>Driver1</code>创建新类<code>Driver4</code>，然后在<code>drive</code>方法中打印日志即可：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Driver4</span> <span class="keyword">extends</span> <span class="title">Driver1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void drive() <span class="keyword">throws</span> <span class="type">InterruptedException</span> &#123;</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.drive();</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你已经发现了，这个解决方案存在着明显的问题，如果一个类有100个方法，实现上述这些逻辑大概需要创建400个类，这显然不是一个可取的方法。那么，是否有更好的解决方案呢？</p>
<p>在上面的解决方案中，我们通过继承的方式获取到了父类方法的执行时间。但是，如果Driver类被final修饰呢，大家知道final类是无法被继承的，继承这条路显然走不通了。</p>
<p>但这似乎恰好为我们打开了一扇窗，我们尝试使用文章开头静态代理的方式传入不同功能的Driver类实例，看看能否发生一些特殊的化学反应。</p>
<p>同样，我们以获取方法的执行时间为例，如果要通过静态代理的方式获取方法的执行时间，我们应该这样做：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Driver5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver5</span>(<span class="params">Driver driver</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        driver.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.<span class="keyword">out</span>.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说到，我们应该将统一的动作抽象化。因此，这里我们新增统一的接口<code>Drivable</code>，我们让所有的Driver类都实现<code>Drivable</code>接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver5</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver5</span><span class="params">(Driver driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        driver.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样地，为了在方法的执行前后打印日志，我们创建<code>Driver6</code>通过代理的方式实现日志的打印：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver6</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Driver driver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver6</span><span class="params">(Driver driver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        driver.drive();</span><br><span class="line">        System.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了与前面的方式区分开来，我们将<code>Driver5</code>重命名为<code>DriverTimeProxy</code>，<code>Driver6</code>重命名为<code>DriverLogProxy</code>，接下来我们尝试先打印日志再获取方法的执行时间。</p>
<p>咋一看，似乎毫无头绪。别急，我们先尝试将聚合对象<code>Driver</code>抽象化。参数类型修改为<code>Drivable</code>（由于Driver类也实现了Drivable接口），修改完成后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverLogProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverLogProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Drive start..."</span>);</span><br><span class="line">        drivable.drive();</span><br><span class="line">        System.out.println(<span class="string">"Drive complete..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        drivable.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，神奇的化学反应出现了。由于<code>DriverLogProxy</code>与<code>DriveTimeProxy</code>都实现了<code>Drivable</code>接口，我们可以将这两个对象相互聚合到对方的类中。</p>
<p>例如，如果我们要先打印方法的执行时间再打印日志，可以这样做：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> <span class="type">Driver</span>();</span><br><span class="line">    </span><br><span class="line">    DriverTimeProxy driverTimeProxy = <span class="keyword">new</span> <span class="type">DriverTimeProxy</span>(driver);</span><br><span class="line">    DriverLogProxy driverLogProxy = <span class="keyword">new</span> <span class="type">DriverLogProxy</span>(driverTimeProxy);</span><br><span class="line">    </span><br><span class="line">    driverLogProxy.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果我们要先打印日志再打印方法的执行时间，可以这样做：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) throws InterruptedException &#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> <span class="type">Driver</span>();</span><br><span class="line"></span><br><span class="line">    DriverLogProxy driverLogProxy = <span class="keyword">new</span> <span class="type">DriverLogProxy</span>(driver);</span><br><span class="line">    DriverTimeProxy driverTimeProxy = <span class="keyword">new</span> <span class="type">DriverTimeProxy</span>(driverLogProxy);</span><br><span class="line"></span><br><span class="line">    driverTimeProxy.drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面的例子中，为了实现相同的功能，我们至少需要创建四个类，而这里似乎只需要两个类就搞定了。显然，这种通过代理处理的方式更优。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在上面的例子中，我们通过静态代理仅使用两个类就完成了四种不同顺序调用的组合，这种在一个类中持有另一个类的实例引用的方式也被称之为<strong>聚合</strong>。在这种场景中，我们可以说，聚合优于继承。</p>
<p>接下来，我们继续加大问题的难度，我们是否可以在任意对象的任意方法前后添加任意的操作呢？并且不需要增加额外的类。</p>
<p>这个问题的难度一下提高了不少，为了简化问题的难度，我们将问题分解一下。</p>
<p>首先，第一个要点是，必须在任意对象的任意方法前后执行任意的操作，这就要求我们必须拿到对象中的任意方法。要拿到对象的任意方法怎么做呢，反射恰好可以解决你的问题。</p>
<p>第二个要点，不能增加额外的类，换句话说，DriverLogProxy与DriverTimeProxy都不需要增加，怎么办！这个地方不太容易想到，其实我们可以帮助用户生成这样的类，使用Java代码编译并通过ClassLoader将字节码加载到内存中，再通过反射的方式进行调用。这样看起来虽然生成了额外的类，但用户是无法感知的，也就做到了不增加额外类的要求。</p>
<p>接下来，我们先来尝试动态生成针对时间的代理类DriverTimeProxy，这个类的完整代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        drivable.drive();</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成这样的代码，我们需要分两步处理：</p>
<p>第一步：将上面的代码当成字符串拼接到变量str中</p>
<p>第二步：使用File类将文件输出到硬盘</p>
<p>以上是我们生成<code>DriverTimeProxy</code>类源码的基本思路，为了简化第一步的处理，这里我们使用<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a>来处理。</p>
<p>JavaPoet是什么呢，JavaPoet其实就是一个Java源码生成工具，为了让大家对JavaPoet有一个更直观的了解，我们先来看一段使用JavaPoet编写的代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .<span class="keyword">addModifiers(Modifier.PUBLIC, </span>Modifier.STATIC)</span><br><span class="line">    .returns(void.class)</span><br><span class="line">    .<span class="keyword">addParameter(String[].class, </span><span class="string">"args"</span>)</span><br><span class="line">    .<span class="keyword">addStatement("$T.out.println($S)", </span>System.class, <span class="string">"Hello, JavaPoet!"</span>)</span><br><span class="line">    .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">TypeSpec </span>helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .<span class="keyword">addModifiers(Modifier.PUBLIC, </span>Modifier.FINAL)</span><br><span class="line">    .<span class="keyword">addMethod(main)</span></span><br><span class="line"><span class="keyword"> </span>   .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">JavaFile </span><span class="keyword">javaFile </span>= <span class="keyword">JavaFile.builder("com.example.helloworld", </span>helloWorld)</span><br><span class="line">    .<span class="keyword">build();</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">javaFile.writeTo(System.out);</span></span><br></pre></td></tr></table></figure>
<p>将以上代码复制到main方法中执行，你将得到下面这样的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Hello, JavaPoet!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>怎么样，明白了吧。通过使用上面的一段API对Java代码进行描述，JavaPoet就自动帮我们生成了一段非常漂亮的Java代码，连排版都省了，这就是JavaPoet的作用。</p>
<p>Ok，接下来我们增加下面这段代码帮助我们生成DriverTimeProxy：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec drive = MethodSpec.methodBuilder(<span class="string">"drive"</span>)</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PUBLIC)</span><br><span class="line"><span class="meta">        .addAnnotation</span>(Override.class)</span><br><span class="line"><span class="meta">        .addException</span>(InterruptedException.class)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"long start = $T.currentTimeMillis()"</span>, System.class)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"drivable.drive()"</span>)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"long end = $T.currentTimeMillis()"</span>, System.class)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"$T.out.println(end - start)"</span>, System.class)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">FieldSpec fieldSpec = FieldSpec.builder(Drivable.class, <span class="string">"drivable"</span>)</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PRIVATE)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PUBLIC)</span><br><span class="line"><span class="meta">        .addParameter</span>(Drivable.class, <span class="string">"drivable"</span>)</span><br><span class="line"><span class="meta">        .addStatement</span>(<span class="string">"this.$N = $N"</span>, <span class="string">"drivable"</span>, <span class="string">"drivable"</span>)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">TypeSpec driverTimeProxy = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line"><span class="meta">        .addModifiers</span>(Modifier.PUBLIC)</span><br><span class="line"><span class="meta">        .addSuperinterface</span>(Drivable.class)</span><br><span class="line"><span class="meta">        .addMethod</span>(drive)</span><br><span class="line"><span class="meta">        .addMethod</span>(constructor)</span><br><span class="line"><span class="meta">        .addField</span>(fieldSpec)</span><br><span class="line"><span class="meta">        .build</span>()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build()<span class="comment">;</span></span><br><span class="line">javaFile.writeTo(System.out)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>在main运行以上代码，你将得到下面这样的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youngfeng.designmode.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.youngfeng.designmode.proxy.juhe.Drivable;</span><br><span class="line"><span class="keyword">import</span> java.lang.InterruptedException;</span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Drivable drivable;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(Drivable drivable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.drivable = drivable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    drivable.drive();</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这恰好就是<code>DriverTimeProxy</code>类的完整代码。接下来，我们继续尝试第二步，将生成的DriverTimeProxy类动态编译并加载到内存中，同时通过反射的方式创建该对象。为了让大家看的更清晰，我们创建一个新类<code>Proxy</code>并增加一个静态方法<code>newProxyInstance</code>专门用来处理这个问题。</p>
<p>为了实现动态编译，我们需要将文件输出到硬盘中，简单起见，这里我直接将其输出到我的电脑桌面。为了将其编译为Java字节码，我们需要使用JDK自带的工具类<code>JavaCompiler</code>进行处理，这是第一步处理。</p>
<p>第二步处理，通过JavaCompiler编译完成后需要通过ClassLoader将生成的字节码加载到内存中，再通过反射获取<code>DriverTimeProxy</code>实例，其完整的处理流程如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译生成的Java源码</span></span><br><span class="line">javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"/com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line"><span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">fileManager.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line"><span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">Constructor constr = cls.getConstructor(Drivable.<span class="keyword">class</span>);</span><br><span class="line">Object obj = constr.newInstance(drivable);</span><br></pre></td></tr></table></figure>
<p>结合上面的分析，Proxy类的完整代码如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Proxy &#123;</span><br><span class="line">    <span class="comment">// 这里需要修改为你自己期望的源码生成路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PATH = <span class="string">"/Users/ouyangfeng/Desktop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(Drivable drivable) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            MethodSpec drive = MethodSpec.methodBuilder(<span class="string">"drive"</span>)</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>)</span><br><span class="line">                    .addException(InterruptedException.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"long start = $T.currentTimeMillis()"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"drivable.drive()"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"long end = $T.currentTimeMillis()"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"$T.out.println(end - start)"</span>, System.<span class="keyword">class</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            FieldSpec fieldSpec = FieldSpec.builder(Drivable.<span class="keyword">class</span>, <span class="string">"drivable"</span>)</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addParameter(Drivable.<span class="keyword">class</span>, <span class="string">"drivable"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"drivable"</span>, <span class="string">"drivable"</span>)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            TypeSpec driverTimeProxy = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addSuperinterface(Drivable.<span class="keyword">class</span>)</span><br><span class="line">                    .addMethod(drive)</span><br><span class="line">                    .addMethod(constructor)</span><br><span class="line">                    .addField(fieldSpec)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">            javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">            javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">            StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"/com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">            javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">            <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">            fileManager.close();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">            URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">            URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">            <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">            Constructor constr = cls.getConstructor(Drivable.<span class="keyword">class</span>);</span><br><span class="line">            Object obj = constr.newInstance(drivable);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的整个过程相对比较复杂，为了让大家更直观地看到整个过程，我用一张图来描述一下整个过程到底发生了什么。</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy0.png" alt=""></p>
<p>在上图中，大家可以看到，有三个小助手在帮助我们完成整个过程。他们分别是JavaPoet，帮助生成Java源码文件；JavaCompiler，帮助编译Java源码文件；Reflect（反射)，帮助动态创建DriverTimeProxy实例。</p>
<p>至此，我们终于完成了DriverTimeProxy动态实例的创建，从现在开始，DriverTimeProxy.java的源码文件可以从我们的工程中删除掉了。换句话说，我们完成了前面需求中的其中一个，不需要新增额外的类这个部分。</p>
<p>等等，是否任意实现了<code>Drivable</code>接口的类都可以通过<code>Proxy.newProxyInstance()</code>方法创建代理实例增加日志打印功能呢？</p>
<p>是的，没错，你已经做到了。因为newProxyInstance的参数是Drivable接口类型，任意实现了该接口的对象都可以作为参数传入进来。</p>
<p>万里长征我们似乎已经走了一大半了。但，还不够！说好的实现任意自定义操作呢，这里只不过是打印日志而已。别急，我们继续往下看。</p>
<p>为了实现任意的自定义操作，我们需要增加进一步抽象。既然操作是任意的，那么这个操作部分就不能由我们做主，应该交给用户。可问题是，到底应该如何只交出自定义操作权限，其它交给Proxy类实现呢。</p>
<p>这里比较容易想到的一个思路是，增加一个统一的接口，接口中只需要包含一个方法，每次调用代理类接口方法的时候都去调用该方法。至于在该方法中到底要做什么，交给用户去处理。</p>
<p>这个思路是完全可行的，我们还是用一张图来描述整个过程。</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy1.png" alt=""></p>
<p>上图中的<code>InvocatinHandler</code>是计划用来拦截代理类的<code>drive</code>方法调用的。当调用drive方法的时候实际上是调用InvocationHandler的invoke方法。</p>
<p>这样做的好处是什么呢，很明显，我们已经交出了自定义逻辑的主动权，用户可以在invoke方法中实现任意的自定义操作。为了能够实现自定义操作，这里的<code>InvocationHandler</code>也必须是一个接口。</p>
<p>按照这个设计，InvocationHandler实例必须作为参数传入到newInstanceProxy方法中。为了让大家看的更清晰，我们先手动实现新版本的<code>DriverTimeProxy</code>类。</p>
<p>我想，大家首先能够想到的第一个版本应该是这样：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>InvocationHandler &#123;</span><br><span class="line">    void invoke(Object proxy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">Drivable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InvocationHandler invocationHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.invocationHandler = invocationHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       invocationHandler.invoke(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的设计确实存在一些问题，我们先不管，先按照这个设计，使用<code>JavaPoet</code>帮助我们生成这样的代码。这个时候，<code>newProxyInstance</code>应该修改为下面这样：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(InvocationHandler handler, <span class="keyword">Class</span> ints) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MethodSpec drive = MethodSpec.methodBuilder(<span class="string">"drive"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addAnnotation(Override.<span class="keyword">class</span>)</span><br><span class="line">                .addException(InterruptedException.<span class="keyword">class</span>)</span><br><span class="line">                .addStatement(<span class="string">"invocationHandler.invoke(this)"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"invocationHandler"</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec driverTimeProxy = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addSuperinterface(ints)</span><br><span class="line">                .addMethod(drive)</span><br><span class="line">                .addMethod(constructor)</span><br><span class="line">                .addField(fieldSpec)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, driverTimeProxy).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">        javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">        Constructor constr = cls.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">        Object obj = constr.newInstance(handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们的DriverTimeProxy构造函数的参数换成了InvocationHandler实例，Drivable实例参数也就不再需要了，但必须传入代理类需要实现的接口类型。因此，newProxyInstance方法的参数变成了两个：InvocationHandler实例与接口的Class类型。</p>
<p>这个版本的newProxyInstance与上一个版本到底有什么不同呢。这里，我们先来做一个简单的总结。</p>
<p>在这个版本的实现中，我们不再需要传入真正的被代理类实例了。我们也去掉了获取方法执行时间的逻辑，这就意味着我们可以在方法的执行前后添加任意的操作了。</p>
<p>这样说起来可能有点抽象，我们继续回到打印方法时间的问题，在这个版本的实现中，如果要打印方法的执行时间，需要怎么做呢。看下面，我们可以这样做：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加自己的InvocationHandler实现类，在类中包含目标代理类Driver实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Driver <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(Driver <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">target</span>.drive();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(end - start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Driver driver = <span class="keyword">new</span> Driver();</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(<span class="keyword">new</span> MyInvocationHandler(driver), Drivable.class);</span><br><span class="line">    ((Drivable)proxy).drive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很神奇，是吗？我们最终将自定义逻辑的实现转移到了接口InvocationHandler的实现类中，至于要对方法做日志打印还是统计时间，只需要自己实现即可，例如，如果要打印日志，在invoke方法中，增加日志打印语句即可：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> invoke(Object proxy) &#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Drive start..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">try</span> &#123;</span><br><span class="line">        target.drive();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"Drive complete..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">end</span> - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人说，如果调换日志打印与时间打印的顺序呢，很简单，直接修改invoke方法中的打印顺序即可，逻辑的设计已经完全掌握在了你自己手中，想怎么操作就怎么操作。</p>
<p>至此，经过艰难的长途跋涉，我们终于完全地抛弃掉了<code>DriverTimeProxy</code>与<code>DriverLogProxy</code>两个类，仅需要实现InvocationHandler接口就可以完成各种逻辑的排列组合了。而且，真正的代理类实现对用户来说是完全不可见的，这就是所谓的<strong>动态代理</strong>。</p>
<p>但，还不够！如果这里我们需要实现另外一个类型的类代理，而这个类中的方法存在参数和返回值的话，这里的设计又出现问题了。为什么呢，看下面的代码：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ICreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICreator</span> &#123;</span><br><span class="line">    Person.<span class="function">Builder <span class="title">create</span>(<span class="params">String name</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> &#123;</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BuilderCreator</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderCreator</span> <span class="keyword"><span class="keyword">implements</span> <span class="type">ICreator</span></span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> Person.Builder create(<span class="keyword">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Person</span>.Builder(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们增加了三个类，一个接口，这里需要被代理的类是<code>BuilderCreator</code>。</p>
<p>与之前的<code>Drivable</code>接口不同的是，这里的<code>ICreator</code>接口中的方法不仅存在参数，而且还有返回值。那么，问题来了！</p>
<p>这里暴露出了我们之前设计存在的两个问题：</p>
<p>第一个问题：参数无法传入到InvocationHandler中。</p>
<p>第二个问题：无法获取到目标代理实例方法调用的返回值。</p>
<p>先来看第一个问题，假设我们自己实现了InvocationHandler，代码如下：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BuilderCreator <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(BuilderCreator <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Object proxy)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// create方法的参数无法获取到，这里将无法被调用</span></span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span>.create(xxx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们发现，当我们对目标代理对象调用create方法的时候，发现create方法的参数无法传入进来了。</p>
<p>怎么办呢！为了保证方法参数可以被传入进来，这里的invoke方法必须再增加一个参数表示外部传入的参数值。由于方法参数可能有多个，这里的参数类型我们用一个对象数组来表示。</p>
<p>这是第一个问题，再来看第二个问题。</p>
<p>由于我们的create方法实际会返回<code>BuilderCreator</code>实例，而在我们的设计中invoke方法是无返回值的。因此，当我们调用代理类的接口方法时，将无法获取到create方法的返回值，也就无法实现后面的调用。因此，为了可以获取到方法的返回值，这里的invoke方法还需要增加一个返回值，类型未知，我们就用Object类型。</p>
<p>按照上面的修正，我们的InvocationHandler接口应该这样设计：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>InvocationHandler &#123;</span><br><span class="line">   Object invoke(Object proxy, Object[] args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照这样的设计，newProxyInstance方法应该这样修改：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(InvocationHandler handler, <span class="keyword">Class</span> ints) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"invocationHandler"</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addSuperinterface(ints)</span><br><span class="line">                .addMethod(constructor)</span><br><span class="line">                .addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证灵活性，这里需要遍历接口中的方法，逐一实现</span></span><br><span class="line">        Method[] methods = ints.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method: methods) &#123;</span><br><span class="line">            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] params = method.getParameterTypes();</span><br><span class="line">            String args = params.length &lt;= <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">"new Object[] &#123;"</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                <span class="keyword">Class</span> param = params[i];</span><br><span class="line">                methodSpecBuilder.addParameter(ParameterSpec.builder(param, <span class="string">"p"</span> + i).build());</span><br><span class="line">                args += <span class="string">"p"</span> + i + <span class="string">","</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            args = args == <span class="keyword">null</span> ? args : args.substring(<span class="number">0</span>, args.length() - <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] exceptions = method.getExceptionTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exceptions.length; i++) &#123;</span><br><span class="line">                methodSpecBuilder.addException(exceptions[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span> returnType = method.getReturnType();</span><br><span class="line">            methodSpecBuilder.returns(returnType);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 方法没有返回值的情况下，这里需要额外处理</span></span><br><span class="line">            <span class="keyword">if</span> (returnType.getName().equals(<span class="string">"void"</span>)) &#123;</span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"this.invocationHandler.invoke(this, "</span> + args + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型</span></span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"Object result = this.invocationHandler.invoke(this, "</span> + args + <span class="string">")"</span>)</span><br><span class="line">                        .addCode(<span class="string">"if (result instanceof $T) &#123;\n"</span>, TypeName.get(method.getReturnType()).box())</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) result"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125; else &#123;\n"</span>)</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) null"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            typeSpecBuilder.addMethod(methodSpecBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, typeSpecBuilder.build()).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">        javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">        Constructor constr = cls.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">        Object obj = constr.newInstance(handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>newProxyInstance方法似乎又复杂了许多，为了可以获取到用户传入的参数，我们必须严格匹配参数的命名。因此，这里将参数统一命名为<strong>pN</strong>。由于每个接口可能有多个方法，这里我们修改为通过遍历的方式获取传入接口的所有方法。同时，为了保证返回值类型与所需类型一致，在代码中，我们增加了类型判断，自动转换到预期的数据类型。</p>
<p>接下来，我们简单测试一下方法是否按照我们预期的情况运行。实现<code>InvocationHandler</code>接口，在main方法中添加如下测试代码，尝试运行，查看结果：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BuilderCreator <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(BuilderCreator <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">target</span>.create((String) args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BuilderCreator builderCreator = <span class="keyword">new</span> BuilderCreator();</span><br><span class="line"></span><br><span class="line">    MyInvocationHandler <span class="keyword">handler</span> = <span class="keyword">new</span> MyInvocationHandler(builderCreator);</span><br><span class="line">    Object proxy = Proxy.newProxyInstance(<span class="keyword">handler</span>, ICreator.class);</span><br><span class="line"></span><br><span class="line">    Person person = ((ICreator)proxy).create(<span class="string">"Scott"</span>).age(<span class="number">18</span>).build();</span><br><span class="line">    System.out.println(person.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，输出结果18，很显然，代码按照预期的结果输出了。</p>
<p>但是，我们还是忽略了一个问题，是什么问题呢，这里先卖个关子，我们先来回顾一下每一次的方法调用过程。</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy2.png" alt=""></p>
<p>在上面这张流程图中，在第一步调用中，我增加了几个方法，因为一个接口可能存在多个方法。通过newProxyInstance的处理，这些方法的调用最终都会通过调用InvocationHandler的invoke方法来实现间接调用。</p>
<p>所以，这里的invoke方法的调用次数与接口的方法数是一致的。如果某个接口有5个方法，这里就会调用5次。而这个时候，我们之前设计的问题也就出现了。</p>
<p>什么问题呢，通常来说，我们需要针对不同的方法进行不同的处理。而用户在invoke方法中无法知道当前究竟调用的是哪个方法，也就无法在invoke方法中针对不同的方法调用进行不同的处理。</p>
<p>这样说起来还是有点抽象，为了让大家看的更直观，我们在ICreator接口中再增加一个方法foo, 运行，查看生成的代码是什么。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>ICreator &#123;</span><br><span class="line">    Person.Builder create(String name);</span><br><span class="line"></span><br><span class="line">    int foo(int x, int y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终动态生成的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.youngfeng.designmode.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.youngfeng.designmode.proxy.juhe.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.Integer;</span><br><span class="line"><span class="keyword">import</span> java.lang.Override;</span><br><span class="line"><span class="keyword">import</span> java.lang.String;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverTimeProxy</span> <span class="keyword">implements</span> <span class="title">ICreator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> InvocationHandler invocationHandler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DriverTimeProxy</span><span class="params">(InvocationHandler invocationHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.invocationHandler = invocationHandler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Person.<span class="function">Builder <span class="title">create</span><span class="params">(String p0)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">this</span>.invocationHandler.invoke(<span class="keyword">this</span>, <span class="keyword">new</span> Object[] &#123;p0&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Person.Builder) &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Person.Builder) result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Person.Builder) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> p0, <span class="keyword">int</span> p1)</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">this</span>.invocationHandler.invoke(<span class="keyword">this</span>, <span class="keyword">new</span> Object[] &#123;p0,p1&#125;);</span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Integer) result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> (Integer) <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到每次调用实际调用的都是InvocationHandler的invoke方法。这个地方会让用户产生疑惑，究竟调用这个方法是发生在调用create还是foo的时候呢。</p>
<p>为了让大家看的更清晰，我们还是看一眼用户端需要实现的InvocationHandler接口类，已经明白的同学可以跳过这个部分继续往下看：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BuilderCreator <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyInvocationHandler</span><span class="params">(BuilderCreator <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Object[] args)</span> </span>&#123;</span><br><span class="line">	 <span class="comment">// 这里会让用户产生疑惑，target实际有两个方法，而无论是</span></span><br><span class="line">	 <span class="comment">// 调用create方法还是foo方法最终都会走这里。</span></span><br><span class="line">	 <span class="comment">// 如果用户需要对不同的方法进行不同的处理就没法办到了。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.<span class="keyword">target</span>.create((String) args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让用户知道这一次的调用究竟是调用哪个方法产生的，invoke方法还需要再增加一个参数，这个参数必须代表当前调用的方法。这里需要用到反射了，我们可以通过反射拿到当前调用方法的Method实例并传入到invoke方法中。</p>
<p>我们摘取其中一个方法create来描述我们大概需要怎么做，看下面这段代码：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Person.Builder create(String p0) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	<span class="comment">// 这里是计划新增的代码</span></span><br><span class="line">        Method method = Drivable.<span class="keyword">class</span>.getMethod(<span class="string">"create"</span>, String.<span class="keyword">class</span>);</span><br><span class="line">        Object result = <span class="keyword">this</span>.invocationHandler.invoke(<span class="keyword">this</span>, method, new Object[]&#123;p0&#125;);</span><br><span class="line">        <span class="keyword">if</span> (result instanceof Person.Builder) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person.Builder) result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Person.Builder) <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了生成上面这样的代码，我们继续改进newProxyInstance方法，改进后的方法如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object newProxyInstance(InvocationHandler handler, <span class="keyword">Class</span> ints) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FieldSpec fieldSpec = FieldSpec.builder(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PRIVATE</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        MethodSpec constructor = MethodSpec.constructorBuilder()</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addParameter(InvocationHandler.<span class="keyword">class</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .addStatement(<span class="string">"this.$N = $N"</span>, <span class="string">"invocationHandler"</span>, <span class="string">"invocationHandler"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        TypeSpec.Builder typeSpecBuilder = TypeSpec.classBuilder(<span class="string">"DriverTimeProxy"</span>)</span><br><span class="line">                .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                .addSuperinterface(ints)</span><br><span class="line">                .addMethod(constructor)</span><br><span class="line">                .addField(fieldSpec);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 为了保证灵活性，这里需要遍历接口中的方法，逐一实现</span></span><br><span class="line">        Method[] methods = ints.getMethods();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method: methods) &#123;</span><br><span class="line">            MethodSpec.Builder methodSpecBuilder = MethodSpec.methodBuilder(method.getName())</span><br><span class="line">                    .addModifiers(Modifier.<span class="keyword">PUBLIC</span>)</span><br><span class="line">                    .addAnnotation(Override.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] params = method.getParameterTypes();</span><br><span class="line">            String args = params.length &lt;= <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">"new Object[] &#123;"</span>;</span><br><span class="line">            String argTypes = params.length &lt;= <span class="number">0</span> ? <span class="keyword">null</span> : <span class="string">"new Class[] &#123;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">                <span class="keyword">Class</span> param = params[i];</span><br><span class="line">                methodSpecBuilder.addParameter(ParameterSpec.builder(param, <span class="string">"p"</span> + i).build());</span><br><span class="line">                args += <span class="string">"p"</span> + i + <span class="string">","</span>;</span><br><span class="line">                argTypes += TypeName.get(param).box().toString() + <span class="string">".class,"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            args = args == <span class="keyword">null</span> ? args : args.substring(<span class="number">0</span>, args.length() - <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line">            argTypes = argTypes == <span class="keyword">null</span> ? argTypes : argTypes.substring(<span class="number">0</span>, argTypes.length() - <span class="number">1</span>) + <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span>[] exceptions = method.getExceptionTypes();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; exceptions.length; i++) &#123;</span><br><span class="line">                methodSpecBuilder.addException(exceptions[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">Class</span> returnType = method.getReturnType();</span><br><span class="line">            methodSpecBuilder.returns(returnType);</span><br><span class="line"></span><br><span class="line">            methodSpecBuilder.beginControlFlow(<span class="string">"try"</span>);</span><br><span class="line">            methodSpecBuilder.addStatement(<span class="string">"$T method = getClass().getMethod($S, $N)"</span>, Method.<span class="keyword">class</span>, method.getName(), argTypes);</span><br><span class="line">            <span class="comment">// 方法没有返回值的情况下，这里需要额外处理</span></span><br><span class="line">            <span class="keyword">if</span> (returnType.getName().equals(<span class="string">"void"</span>)) &#123;</span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"this.invocationHandler.invoke(this, "</span> + args + <span class="string">")"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 为了保证逻辑的严谨性，这里需要判断实际返回数据类型是否是接口中方法的返回值类型</span></span><br><span class="line">                methodSpecBuilder.addStatement(<span class="string">"Object result = this.invocationHandler.invoke(this, method, "</span> + args + <span class="string">")"</span>)</span><br><span class="line">                        .addCode(<span class="string">"if (result instanceof $T) &#123;\n"</span>, TypeName.get(method.getReturnType()).box())</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) result"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125; else &#123;\n"</span>)</span><br><span class="line">                        .addStatement(<span class="string">"\treturn ($T) null"</span>, TypeName.get(returnType).box())</span><br><span class="line">                        .addCode(<span class="string">"&#125;\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            methodSpecBuilder.nextControlFlow(<span class="string">"catch ($T e)"</span>, Exception.<span class="keyword">class</span>)</span><br><span class="line">                    .addStatement(<span class="string">"e.printStackTrace()"</span>)</span><br><span class="line">                    .addStatement(<span class="string">"return ($T) null"</span>, TypeName.get(returnType).box())</span><br><span class="line">                    .endControlFlow();</span><br><span class="line"></span><br><span class="line">            typeSpecBuilder.addMethod(methodSpecBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JavaFile javaFile = JavaFile.builder(<span class="string">"com.youngfeng.designmode.proxy"</span>, typeSpecBuilder.build()).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">File</span> sourceFile = <span class="keyword">new</span> <span class="keyword">File</span>(PATH);</span><br><span class="line">        javaFile.writeTo(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译生成的Java源码</span></span><br><span class="line">        javax.tools.JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();</span><br><span class="line">        StandardJavaFileManager fileManager = javaCompiler.getStandardFileManager(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        Iterable iterable = fileManager.getJavaFileObjects(PATH + <span class="string">"com/youngfeng/designmode/proxy/DriverTimeProxy.java"</span>);</span><br><span class="line">        javax.tools.JavaCompiler.CompilationTask <span class="keyword">task</span> = javaCompiler.getTask(<span class="keyword">null</span>, fileManager, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, iterable);</span><br><span class="line">        <span class="keyword">task</span>.<span class="keyword">call</span>();</span><br><span class="line">        fileManager.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过反射将源码加载到内存中</span></span><br><span class="line">        URL[] urls = <span class="keyword">new</span> URL[] &#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + PATH)&#125;;</span><br><span class="line">        URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(urls);</span><br><span class="line">        <span class="keyword">Class</span> cls = classLoader.loadClass(<span class="string">"com.youngfeng.designmode.proxy.DriverTimeProxy"</span>);</span><br><span class="line">        Constructor constr = cls.getConstructor(InvocationHandler.<span class="keyword">class</span>);</span><br><span class="line">        Object obj = constr.newInstance(handler);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，如果我们需要对不同的方法进行不同的处理，这里就可以通过method参数进行判断了。</p>
<p>我们继续以代理BuilderCreator类为例，如果我们要在create与foo方法前后分别打印当前方法被调用的日志，可以这样做：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> BuilderCreator target;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> MyInvocationHandler(BuilderCreator target) &#123;</span><br><span class="line">	    this.target = target;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	<span class="keyword">public</span> Object invoke(Object proxy, <span class="function"><span class="keyword">Method</span> <span class="title">method</span>, <span class="title">Object</span>[] <span class="title">args</span>) &#123;</span></span><br><span class="line">	    <span class="keyword">try</span> &#123;</span><br><span class="line">	    	// 通过<span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>)可以获取到方法名</span><br><span class="line">	        System.out.println(<span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>) + <span class="string">" invoke start..."</span>);</span><br><span class="line">	        Object result = <span class="function"><span class="keyword">method</span>.<span class="title">invoke</span>(</span>target, args);</span><br><span class="line">	        System.out.println(<span class="function"><span class="keyword">method</span>.<span class="title">getName</span>(</span>) + <span class="string">" invoke end..."</span>);</span><br><span class="line">	</span><br><span class="line">	        <span class="keyword">return</span> result;</span><br><span class="line">	    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	        e.printStackTrace();</span><br><span class="line">	        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到现在为止，我们的动态代理实现基本完整了，我们的旅程也快要结束了。终于，如果我们要在某个类的某个方法前后插入任意的逻辑，不再需要新增额外的类了（InvocationHandler实现类除外），而且添加的逻辑也可以完全自定义了，我们的目标达到了！</p>
<p>回顾一下我们的整个探索过程，在文章的开篇部分我们从为Driver类的drive方法增加时间打印需求开始，最终选择通过代理的方式进行处理，这样做的灵活性明显高于继承。而为了去掉额外新增的类，我们使用了动态编译的方式在运行期间帮助用户生成相应的代理类。但我们并未满足于此，为了让插入的逻辑也实现自定义，我们又对插入进行了抽象，新增了插入逻辑抽象类InvocationHandler，最终将对Driver类的代理转换到对InvocationHandler实现类的代理中。将方法调用的主动权交给用户（InvocationHandler的实现类处理）。这样，无论是多么复杂的需求，对用户来说，只需要实现InvocationHandler接口增加自定义处理即可，即使某个类有100个方法，他需要的也只是一个InvocationHandler的实现类而已。</p>
<p>等等，我们似乎还忘记了一件事情。一直以来我们生成的动态代理类名称都叫做<code>DriverTimeProxy</code>，而此刻它的功能已经不再仅仅是为<code>Driver</code>类增加时间打印而已了。因此，这里我们将最终生成的代理类名称修改为<code>Proxy$0</code>。最终版本的实现大家可以查看文章的附录部分，点击下方链接前去查看。</p>
<h3 id="动态代理到底有什么用"><a href="#动态代理到底有什么用" class="headerlink" title="动态代理到底有什么用"></a>动态代理到底有什么用</h3><p>在上面的整个过程中，我们可谓是经历了千难万险，终于完成了一个简易版本的动态代理。那么动态代理到底有什么作用呢。为了让大家直观地感受到，动态代理到底可以做什么，我们先一起来看一个简单的例子。</p>
<p>这里我们创建两个类来简单模拟数据库事务的提交过程（以下代码仅作为演示使用，不具有实际使用价值）：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public<span class="built_in"> interface </span>TransactionConstr &#123;</span><br><span class="line">    void commit(int x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> <span class="keyword">implements</span> <span class="title">TransactionConstr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Database <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Database();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        System.out.println(<span class="string">"Transaction commit success..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Transaction rollback..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止出现脏数据，我们需要在事务提交失败的时候将数据回滚。在没有动态代理之前，我们会这样处理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Database db = Database.getInstance();</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 通过try catch的方式手动回滚数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        db.commit(<span class="number">-1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        db.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而使用动态代理，我们这样做：实现InvocationHandler，代理Database类，在invoke方法中捕获方法可能抛出的异常，一旦发现异常就调用rollback方法自动回滚。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoRollbackInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Database <span class="keyword">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoRollbackInvocationHandler</span><span class="params">(Database <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">target</span> = <span class="keyword">target</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method.invoke(<span class="keyword">target</span>, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">target</span>.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一定还是会有人说，这两种调用方式貌似没有什么区别啊。第二种写法在每次调用的时候不也需要先使用newProxyInstance生成代理类，然后再调用吗，这样反而麻烦了许多。</p>
<p>其实，这两种方式有一个本质上的区别，前者免不了每次都添加<code>try-catch</code>语句。而后者由于是使用模板化的实现，我们可以在框架层帮助用户自动生成动态代理类，自动添加<code>try-catch</code>语句，这样用户就可以使用非常简单的方式实现事务的自动回滚了。例如，在方法上面添加一个自动回滚的注解，框架层识别注解自动生成代理类实例。这样，你需要的仅仅是一个注解而已了。如果你了解Java后端开发，你应该就知道我在说什么了。</p>
<p>以上是动态代理设计模式的一个经典应用场景，但实际上，动态代理的使用场景还有很多。仔细观察动态代理的执行过程，它似乎为我们开辟了一个新的编程方式。相对于传统的流线型编程方式，动态代理可以在任意已经实现的类中的任意方法中插入自定义的逻辑，就像一把刀一样，将代码的执行过程切成片段，再往里插入自定义的逻辑。至此，计算机的编程方式就变成了<strong>cut-insert</strong>（切开-插入）的方式进行。这种编程方式，在计算机科学中，被称之为<strong>面向切面编程（AOP）</strong>。</p>
<h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p>动态代理是面向切面编程的一种经典实现。在大部分框架中，实现AOP都会使用JDK自带的动态代理处理。当然，JDK的实现其实也有一定的局限性，这就是为什么CGLIB这样的动态代理库大行其道的原因。不过，这不是本文讨论的重点，大家如果对CGLIB感兴趣的话，可以在文章下方给留言。</p>
<p>说回AOP，到底什么是面向切面编程呢？前面其实已经有了一个简单的解释了，为了让大家看的更直观，我们先来看一张图：</p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy3.jpg" alt=""></p>
<p>以上是面向切面编程框架<a href="https://www.eclipse.org/aspectj/" target="_blank" rel="noopener">AspectJ</a>的示例图，AspectJ是一个非常流行面向切面编程Java库。我们就用这张图来给大家讲一下相对于传统编程，面向切面编程到底有什么不同。</p>
<p>图中绿色箭头表示正常代码的执行过程，<strong>PointCut</strong>表示切入点，即在哪个类的哪些位置插入自定义逻辑。<strong>Join Points</strong>表示连接点，即具体的插入位置，例如方法调用前，调用后，异常抛出等等。</p>
<p>由此可见，相当于传统的编程模型，AOP的思考点是：找到匹配的切入点，插入自定义逻辑，而且这种插入对原有框架代码是无侵入性的。相对于面向对象编程模型使用继承的方式进行扩展这种侵入性的处理方式，显然是一个巨大的进步。</p>
<p>正是因为AOP具备高度自由、无侵入性的这些特点，才使得它在Spring等知名开源框架中有着大量的应用，而这一切的核心都依赖于AOP最经典的实现方式：<strong>动态代理</strong>。我想，这应该是动态代理到底有什么用这个问题最好的回答。</p>
<h3 id="JDK实现揭秘"><a href="#JDK实现揭秘" class="headerlink" title="JDK实现揭秘"></a>JDK实现揭秘</h3><p>实际上，在上面的整个探索过程中，我们都是参照JDK实现来进行讲解的。但还有哪些地方是我们考虑不周的呢，一起来看看JDK实现吧。</p>
<p>打开JavaSE官方文档，找到Proxy与InvocationHandler类。</p>
<p><strong>Proxy.java</strong></p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy4.jpg" alt=""></p>
<p><strong>InvocationHandler</strong></p>
<p><img src="/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/proxy5.jpg" alt=""></p>
<p>可以看到，JDK版本的newProxyInstance方法中一个有三个参数，第一个参数是ClassLoader，这就意味着我们可以指定自己的类加载器。第二个参数是接口数组，这是因为需要被代理的接口可能不止一个，或者说代理类实现的接口可能不止一个。这是在我们的版本中没有考虑到的一点，实际使用场景中这种情况其实是很常见的。</p>
<p>JDK版本中，<strong>InvocationHandler</strong>接口的定义与我们的版本是完全一致的。在前一篇文章中，关于这个接口中方法里面几个参数的意思，有不少同学问到，甚至有同学在微信公众号“欧阳锋工作室”给我私信，问到了这个问题。这里统一给大家解答一下：</p>
<p><strong>proxy</strong>：这个参数表示动态生成的代理类实例，在某些场景中你可能需要对代理实例做一些特殊的处理，这个时候，这个参数的作用就出来了，大多数情况下你不需要用到这个参数。</p>
<p><strong>method</strong>：这个参数在前面的文章中其实已经讲过了，它表示实际调用的代理类的接口方法的Method实例，用户可以使用它调用目标代理类的方法。</p>
<p><strong>args</strong>：这个参数表示method对应方法传入的参数值，这里可以提供给method方法反射调用，也可以通过直接调用的方式逐一传入参数值到目标代理类方法中。</p>
<p><strong>返回值</strong>：invoke方法的返回值，这里也有一些同学问到，这个也是上一篇文章中解释不够到位的地方。这一次我们在前面的例子中详细解释了invoke方法的返回值到底有什么作用。它实际上对应的是被代理类对应method方法的返回值。这是与接口方法一一对应的，方便调用者轻松获取到实际代理类方法调用的返回值。</p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>最后，感谢大家陪伴我走过了这一段艰难的探索旅程，这的确不太容易。如果你完整地看完了整篇文章，并且根据文章的推进过程同步完成了代码开发，应该给自己鼓个掌。因为，这的确不太容易。Java动态代理设计模式是所有设计模式中最难理解的一个。如果你已经看懂了这个设计模式，其它的设计模式就已经是“除却巫山不是云”了。</p>
<p>希望这篇文章说清楚了前一篇文章大家提的每一个问题，也说清楚了动态代理的每一处细节。如果你还有疑问，欢迎在文章下方给我留言，或者来我的微信公众号“欧阳锋工作室”给我发私信。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>例子源码：<a href="https://github.com/yuanhoujun/java-dynamic-proxy" target="_blank" rel="noopener">https://github.com/yuanhoujun/java-dynamic-proxy</a></p>
<p>上一篇：<a href="http://youngfeng.com/2018/03/02/design%20pattern/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">点这里前往</a></p>
<p>关注微信公众号”欧阳锋工作室“，阅读更多文章。</p>
<p><img src="http://youngfeng.com/assets/images/mpwexin.jpg" alt=""></p>

            


        </div>
    </div>
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-link" href="/tags/动态代理/">动态代理</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/12/06/是时候跟Dagger2说再见了！/"
                    data-tooltip="是时候跟Dagger2说再见了！"
                    aria-label="上一篇: 是时候跟Dagger2说再见了！"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/11/18/深入链表数据结构，助你搞定链表算法题/"
                    data-tooltip="深入链表数据结构，助你搞定链表算法题"
                    aria-label="下一篇: 深入链表数据结构，助你搞定链表算法题"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/&amp;title=10分钟看懂动态代理设计模式（升级篇）"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
        
    </div>
</article>



                <footer id="footer" class="main-content-wrap">
    <p>
        <a href="https://beian.miit.gov.cn">粤ICP备2022110674号-1</a>
    </p>
    <p class="copyrights">
        Copyrights &copy; 2022 欧阳锋工作室. All Rights Reserved.
    </p>
</footer>
            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/12/06/是时候跟Dagger2说再见了！/"
                    data-tooltip="是时候跟Dagger2说再见了！"
                    aria-label="上一篇: 是时候跟Dagger2说再见了！"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/2019/11/18/深入链表数据结构，助你搞定链表算法题/"
                    data-tooltip="深入链表数据结构，助你搞定链表算法题"
                    aria-label="下一篇: 深入链表数据结构，助你搞定链表算法题"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/&amp;title=10分钟看懂动态代理设计模式（升级篇）"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#" aria-label="Nach oben">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/&amp;title=10分钟看懂动态代理设计模式（升级篇）"
                        aria-label="分享到 QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://youngfeng.com/2019/11/29/10分钟看懂动态代理设计模式（升级篇）/"
                        aria-label="分享到 Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="/assets/images/avatar.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">欧阳锋工作室</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                广东深圳
            </div>
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->
<script src="/assets/js/jquery.js"></script>
<script src="/assets/js/jquery.fancybox.js"></script>
<script src="/assets/js/thumbs.js"></script>
<script src="/assets/js/tranquilpeak.js"></script>
<!--SCRIPTS END-->


    




    </body>
</html>
